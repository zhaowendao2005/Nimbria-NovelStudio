# Vue 多例组件模式完整指南

## 📚 目录
- [什么是多例组件模式](#什么是多例组件模式)
- [为什么需要多例模式](#为什么需要多例模式)
- [核心原理](#核心原理)
- [实现步骤](#实现步骤)
- [常见陷阱与解决方案](#常见陷阱与解决方案)
- [维护清单](#维护清单)
- [最佳实践](#最佳实践)
- [实战案例](#实战案例)

---

## 什么是多例组件模式

**多例组件模式**（Multiple Instance Pattern）是指同一个组件类型可以有多个独立的实例同时存在，每个实例都维护自己独立的状态和生命周期。

### 典型场景
- 📄 **多标签页编辑器**：每个标签页都是独立的Markdown编辑器
- 🔍 **多搜索面板**：每个搜索标签页维护自己的搜索历史和结果
- 📊 **多图表实例**：同一个图表组件的多个实例，展示不同数据
- 🎬 **多视频播放器**：每个播放器独立播放、暂停、控制

---

## 为什么需要多例模式

### ❌ 不使用多例模式的问题

```vue
<!-- 错误示例：多个标签页共享状态 -->
<SearchPanel v-if="activeTab === 'search-1'" />
<SearchPanel v-if="activeTab === 'search-2'" />
```

**问题**：
- ❌ Vue会复用组件实例
- ❌ 切换标签页时，状态会混乱
- ❌ 第二个标签页会继承第一个的状态

### ✅ 使用多例模式的优势

```vue
<!-- 正确示例：每个标签页独立实例 -->
<SearchPanel 
  v-if="activeTab === 'search-1'" 
  :key="'search-1'"
  :tab-id="'search-1'"
/>
<SearchPanel 
  v-if="activeTab === 'search-2'" 
  :key="'search-2'"
  :tab-id="'search-2'"
/>
```

**优势**：
- ✅ 每个实例完全独立
- ✅ 状态不会相互影响
- ✅ 生命周期清晰可控
- ✅ 易于调试和维护

---

## 核心原理

### 1. Vue的key机制

Vue使用`key`属性来标识每个组件的唯一性：

```vue
<Component :key="uniqueId" />
```

**规则**：
- 相同key → Vue复用组件实例
- 不同key → Vue创建新的组件实例

### 2. 生命周期

```
创建实例A (key="a")
  ↓
mounted A
  ↓
切换到实例B (key="b")
  ↓
unmounted A → mounted B
  ↓
再切换回A (key="a")
  ↓
mounted A (重新创建)
```

### 3. 状态持久化

由于组件会被销毁和重建，需要在外部存储状态：

```typescript
// Store层维护多实例状态
const instances = new Map<string, InstanceState>()

// 组件挂载时恢复
onMounted(() => {
  const state = store.initInstance(tabId)
  // 恢复状态...
})

// 组件卸载时保存
onUnmounted(() => {
  store.updateInstance(tabId, currentState)
})
```

---

## 实现步骤

### 第一步：组件层 - 添加唯一标识

```vue
<!-- PaneContent.vue -->
<template>
  <SearchPanel
    v-if="activeTabId && tabType === 'search'"
    :key="`search-${activeTabId}`"
    :tab-id="activeTabId"
  />
</template>
```

**关键点**：
- `:key`：确保Vue创建独立实例
- `:tab-id`：组件内部用于区分状态

### 第二步：Store层 - 多实例状态管理

```typescript
// searchPanel.store.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'

interface InstanceState {
  tabId: string
  searchQuery: string
  results: any[]
  // 其他状态...
}

export const useSearchPanelStore = defineStore('searchPanel', () => {
  // 使用Map存储每个实例的状态
  const instances = ref<Map<string, InstanceState>>(new Map())
  
  /**
   * 初始化实例状态
   */
  const initInstance = (tabId: string): InstanceState => {
    if (instances.value.has(tabId)) {
      return instances.value.get(tabId)!
    }
    
    const newInstance: InstanceState = {
      tabId,
      searchQuery: '',
      results: []
    }
    
    instances.value.set(tabId, newInstance)
    return newInstance
  }
  
  /**
   * 更新实例状态
   */
  const updateInstance = (
    tabId: string, 
    updates: Partial<InstanceState>
  ): void => {
    const instance = instances.value.get(tabId)
    if (instance) {
      Object.assign(instance, updates)
    }
  }
  
  /**
   * 移除实例状态
   */
  const removeInstance = (tabId: string): void => {
    instances.value.delete(tabId)
  }
  
  return {
    instances,
    initInstance,
    updateInstance,
    removeInstance
  }
})
```

### 第三步：组件层 - 状态同步

```vue
<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useSearchPanelStore } from '@stores/searchPanel'

interface Props {
  tabId: string
}

const props = defineProps<Props>()
const store = useSearchPanelStore()

// 组件内部状态
const searchQuery = ref('')
const results = ref([])

// 挂载时恢复状态
onMounted(() => {
  const state = store.initInstance(props.tabId)
  searchQuery.value = state.searchQuery
  results.value = state.results
  
  console.log(`[Search ${props.tabId}] Component mounted`)
})

// 卸载时保存状态
onUnmounted(() => {
  store.updateInstance(props.tabId, {
    searchQuery: searchQuery.value,
    results: results.value
  })
  
  console.log(`[Search ${props.tabId}] Component unmounted, state saved`)
})

// 状态变化时同步到store
const handleSearch = (query: string) => {
  searchQuery.value = query
  // 执行搜索...
  
  // 同步到store
  store.updateInstance(props.tabId, {
    searchQuery: query,
    results: results.value
  })
}
</script>
```

### 第四步：清理机制

```typescript
// markdown.store.ts (标签页管理器)
const closeTab = (tabId: string) => {
  // 1. 移除标签页
  tabs.value.delete(tabId)
  
  // 2. 清理相关组件的状态
  if (tabId.startsWith('search-')) {
    searchPanelStore.removeInstance(tabId)
  }
  
  // 3. 清理资源（如BrowserView）
  if (searchScraperInstances.has(tabId)) {
    SearchAndScraperService.destroyView(tabId)
    searchScraperInstances.delete(tabId)
  }
}
```

---

## 常见陷阱与解决方案

### 陷阱1：忘记添加key

**问题**：
```vue
<!-- ❌ 错误：缺少key -->
<SearchPanel 
  v-if="activeTab === 'search-1'"
  :tab-id="'search-1'"
/>
<SearchPanel 
  v-if="activeTab === 'search-2'"
  :tab-id="'search-2'"
/>
```

**现象**：两个标签页共享同一个组件实例，状态混乱

**解决方案**：
```vue
<!-- ✅ 正确：添加唯一key -->
<SearchPanel 
  v-if="activeTab === 'search-1'"
  :key="'search-1'"
  :tab-id="'search-1'"
/>
```

### 陷阱2：key不唯一

**问题**：
```vue
<!-- ❌ 错误：多个分支使用相同key -->
<ComponentA v-if="type === 'a'" :key="tabId" />
<ComponentB v-else-if="type === 'b'" :key="tabId" />
```

**Lint错误**：
```
v-if/else branches must use unique keys
```

**解决方案**：
```vue
<!-- ✅ 正确：组合type和id -->
<ComponentA v-if="type === 'a'" :key="`a-${tabId}`" />
<ComponentB v-else-if="type === 'b'" :key="`b-${tabId}`" />
```

### 陷阱3：子组件状态不同步

**问题**：
```vue
<!-- SearchBox.vue -->
<script setup>
// ❌ 错误：创建独立的ref，不同步props
const searchQuery = ref('')
</script>
```

**现象**：父组件切换标签页时，SearchBox显示旧值

**解决方案**：
```vue
<!-- ✅ 正确：使用computed保持同步 -->
<script setup>
const searchQuery = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value)
})
</script>
```

### 陷阱4：忘记清理资源

**问题**：
```typescript
// ❌ 错误：只创建，不清理
onMounted(() => {
  BrowserViewService.create(props.tabId)
})
// 缺少onUnmounted清理
```

**现象**：内存泄漏，资源占用持续增长

**解决方案**：
```typescript
// ✅ 正确：成对的创建和清理
let resizeObserver: ResizeObserver | null = null

onMounted(() => {
  resizeObserver = new ResizeObserver(() => {})
  resizeObserver.observe(element)
})

onUnmounted(() => {
  if (resizeObserver) {
    resizeObserver.disconnect()
    resizeObserver = null
  }
})
```

### 陷阱5：状态未持久化

**问题**：
```typescript
// ❌ 错误：状态只在组件内部
const searchQuery = ref('')
// 组件销毁后，状态丢失
```

**现象**：切换回标签页时，之前的搜索内容消失

**解决方案**：
```typescript
// ✅ 正确：在onUnmounted时保存
onUnmounted(() => {
  store.updateInstance(props.tabId, {
    searchQuery: searchQuery.value,
    results: results.value
  })
})
```

---

## 维护清单

### ✅ 组件层检查清单

- [ ] **所有动态渲染的组件都添加了`:key`**
  ```vue
  <Component :key="`${type}-${id}`" />
  ```

- [ ] **Props包含唯一标识符**
  ```vue
  <Component :tab-id="uniqueId" />
  ```

- [ ] **生命周期钩子成对出现**
  ```typescript
  onMounted(() => { /* 初始化 */ })
  onUnmounted(() => { /* 清理 */ })
  ```

- [ ] **状态在挂载时恢复**
  ```typescript
  const state = store.initInstance(props.tabId)
  localState.value = state.xxx
  ```

- [ ] **状态在卸载时保存**
  ```typescript
  store.updateInstance(props.tabId, {
    xxx: localState.value
  })
  ```

- [ ] **资源正确清理**
  ```typescript
  // ResizeObserver, EventListener, BrowserView等
  ```

### ✅ Store层检查清单

- [ ] **使用Map存储多实例状态**
  ```typescript
  const instances = ref<Map<string, State>>(new Map())
  ```

- [ ] **提供初始化方法**
  ```typescript
  const initInstance = (id: string) => { /* ... */ }
  ```

- [ ] **提供更新方法**
  ```typescript
  const updateInstance = (id: string, updates: Partial<State>) => {}
  ```

- [ ] **提供移除方法**
  ```typescript
  const removeInstance = (id: string) => { /* ... */ }
  ```

- [ ] **添加调试日志**
  ```typescript
  console.log(`[Store] Instance initialized: ${id}`)
  ```

### ✅ 调试检查清单

- [ ] **每个实例挂载时打印日志**
  ```typescript
  console.log(`[Component ${props.tabId}] Mounted`)
  ```

- [ ] **每个实例卸载时打印日志**
  ```typescript
  console.log(`[Component ${props.tabId}] Unmounted`)
  ```

- [ ] **关键状态变化打印日志**
  ```typescript
  console.log(`[Component ${props.tabId}] State updated:`, state)
  ```

- [ ] **可以通过日志确认实例的创建和销毁顺序**

---

## 最佳实践

### 1. 命名约定

```typescript
// Store文件命名
searchPanel.store.ts
searchPanel.types.ts

// 实例ID命名
`${type}-${timestamp}` // search-and-scraper-1761285187072
`${type}-${uuid}` // search-panel-a1b2c3d4
```

### 2. 类型安全

```typescript
// 定义清晰的状态接口
interface SearchPanelState {
  tabId: string
  searchQuery: string
  results: SearchResult[]
  isLoading: boolean
  error: string | null
}

// Store方法使用强类型
const updateInstance = (
  tabId: string, 
  updates: Partial<Omit<SearchPanelState, 'tabId'>>
): void => {
  // 实现...
}
```

### 3. 状态最小化

只持久化必要的状态：

```typescript
// ✅ 好的设计：只保存必要数据
interface InstanceState {
  searchQuery: string    // 需要保存
  currentUrl: string     // 需要保存
  isViewCreated: boolean // 需要保存
}

// ❌ 不好的设计：保存派生状态
interface InstanceState {
  searchQuery: string
  searchQueryLength: number  // 可以从searchQuery计算
  hasQuery: boolean          // 可以从searchQuery计算
}
```

### 4. 清理策略

```typescript
// 立即清理 vs 延迟清理
const removeInstance = (tabId: string, immediate = false) => {
  if (immediate) {
    // 立即删除状态
    instances.value.delete(tabId)
  } else {
    // 延迟删除（给撤销机会）
    setTimeout(() => {
      instances.value.delete(tabId)
    }, 5000)
  }
}
```

### 5. 性能优化

```typescript
// 避免频繁更新store
import { debounce } from 'lodash-es'

const syncToStore = debounce((state) => {
  store.updateInstance(props.tabId, state)
}, 500)

watch(searchQuery, (newValue) => {
  syncToStore({ searchQuery: newValue })
})
```

---

## 实战案例

### 案例1：SearchAndScraper多标签页

**需求**：用户可以打开多个搜索标签页，每个标签页独立搜索和浏览

**实现**：

```vue
<!-- PaneContent.vue -->
<SearchAndScraperPanel
  v-else-if="localActiveTabId && activeTabType === 'search-and-scraper'"
  :key="`search-and-scraper-${localActiveTabId}`"
  :tab-id="localActiveTabId"
/>
```

```typescript
// searchAndScraper.store.ts
export const useSearchAndScraperStore = defineStore('searchAndScraper', () => {
  const instances = ref<Map<string, SearchInstanceState>>(new Map())
  
  const initInstance = (tabId: string): SearchInstanceState => {
    if (instances.value.has(tabId)) {
      return instances.value.get(tabId)!
    }
    
    const newInstance: SearchInstanceState = {
      tabId,
      searchQuery: '',
      currentUrl: '',
      isViewCreated: false,
      isBrowserViewVisible: false
    }
    
    instances.value.set(tabId, newInstance)
    return newInstance
  }
  
  return { instances, initInstance, updateInstance, removeInstance }
})
```

```vue
<!-- SearchAndScraperPanel.vue -->
<script setup lang="ts">
const props = defineProps<{ tabId: string }>()
const store = useSearchAndScraperStore()

const searchQuery = ref('')
const isBrowserViewVisible = ref(false)

onMounted(() => {
  // 恢复状态
  const state = store.initInstance(props.tabId)
  searchQuery.value = state.searchQuery
  isBrowserViewVisible.value = state.isBrowserViewVisible
  
  console.log(`[SearchAndScraper ${props.tabId}] Mounted`)
})

onUnmounted(() => {
  // 保存状态
  store.updateInstance(props.tabId, {
    searchQuery: searchQuery.value,
    isBrowserViewVisible: isBrowserViewVisible.value
  })
  
  console.log(`[SearchAndScraper ${props.tabId}] Unmounted`)
})
</script>
```

**效果验证**：

```javascript
// 期望的日志输出
[Markdown] SearchAndScraper tab created: search-and-scraper-111
[SearchAndScraper search-and-scraper-111] Mounted ✅

[Markdown] SearchAndScraper tab created: search-and-scraper-222
[SearchAndScraper search-and-scraper-222] Mounted ✅

// 切换标签页
[SearchAndScraper search-and-scraper-222] Unmounted
[SearchAndScraper search-and-scraper-111] Mounted ✅

// 关闭标签页
[SearchAndScraper search-and-scraper-111] Unmounted
[SearchAndScraper Store] Instance removed: search-and-scraper-111 ✅
```

---

## 总结

### 核心要点

1. **`:key`是关键**：确保每个实例的唯一性
2. **Store层管理状态**：使用Map存储多实例状态
3. **生命周期对称**：创建和清理成对出现
4. **状态持久化**：在挂载时恢复，卸载时保存
5. **类型安全**：使用TypeScript确保类型正确

### 决策树

```
需要多个同类型组件? 
  ├─ 是 → 是否需要独立状态?
  │      ├─ 是 → 使用多例模式 ✅
  │      │      ├─ 添加 :key
  │      │      ├─ Store管理状态
  │      │      └─ 生命周期同步
  │      └─ 否 → 使用单例模式
  └─ 否 → 常规组件
```

### 参考文档

- [Vue官方文档 - key特殊attribute](https://cn.vuejs.org/api/built-in-special-attributes.html#key)
- [Pinia官方文档 - State](https://pinia.vuejs.org/core-concepts/state.html)
- [Vue生命周期图示](https://cn.vuejs.org/guide/essentials/lifecycle.html)

---

**文档版本**：v1.0  
**最后更新**：2025-01-24  
**维护者**：开发团队

