# Nimbria项目：Obsidian风格项目页集成总结

**生成时间**：2025年10月6日  
**项目阶段**：Obsidian风格Markdown编辑器集成  
**工作性质**：原型系统迁移与多窗口集成

---

## 📋 目录

1. [项目概述](#项目概述)
2. [已实现功能](#已实现功能)
3. [技术实现细节](#技术实现细节)
4. [项目规范与架构](#项目规范与架构)
5. [遇到的问题与解决方案](#遇到的问题与解决方案)
6. [经验总结](#经验总结)
7. [标准工作流程](#标准工作流程)

---

## 项目概述

### 🎯 目标
将独立的Obsidian风格Markdown编辑器原型（`Reference-Page/ReferencePage`）集成到Nimbria主应用中，作为ProjectPage系统的核心功能，支持多窗口架构下的Markdown文档编辑与管理。

### 📦 核心特性
- **三栏布局**：左侧文件树 + 中间编辑器 + 右侧大纲
- **多标签页管理**：支持同时打开多个Markdown文档
- **编辑/预览模式切换**：基于Vditor的双模式支持
- **自定义窗口控制**：实现跨平台一致的窗口操作体验

---

## 已实现功能

### 1. 多窗口系统集成 ✅

#### 1.1 项目窗口创建
- **功能**：在主窗口点击项目卡片后，创建独立的项目编辑窗口
- **实现位置**：
  - `src-electron/core/app-manager.ts` - 窗口生命周期管理
  - `src-electron/services/window-service/window-manager.ts` - 窗口进程管理

#### 1.2 独立路由系统
- **功能**：为项目窗口配置独立的路由入口 `/project`
- **实现位置**：
  - `Client/GUI/router/routes.ts` - 路由配置
  - `Client/GUI/Index/ProjectPageSystem.vue` - 项目系统入口组件

#### 1.3 自定义窗口控制栏
- **功能**：实现Windows/macOS风格的窗口控制栏
- **控制功能**：最小化、最大化/还原、关闭
- **实现位置**：
  - `Client/GUI/layouts/ProjectMainLayout.vue` - 窗口控制UI
  - `src-electron/core/app-manager.ts` - IPC窗口操作处理

### 2. 三栏布局系统 ✅

#### 2.1 响应式分隔面板
- **技术栈**：Element Plus `<el-container>` + 自定义分隔器
- **功能**：
  - 左右面板可拖动调整宽度
  - 宽度状态持久化（localStorage）
  - 最小宽度限制（150px）
- **实现位置**：
  - `Client/GUI/layouts/ProjectMainLayout.vue` - 布局主体
  - `Client/GUI/layouts/ProjectMainLayout.scss` - Flexbox布局样式

#### 2.2 Shell设计模式
- **设计理念**：左右侧栏共享同一组件，通过props区分行为
- **组件**：`Client/GUI/PagesLayout/ProjectPage.Shell.vue`
- **Props**：`type: 'left' | 'right'`
- **内容分发**：
  - **左侧**：导航栏 + 文件树
  - **右侧**：大纲面板

### 3. Markdown编辑系统 ✅

#### 3.1 文件树管理
- **功能**：
  - 递归渲染文件夹结构
  - 文件/文件夹展开折叠
  - 点击文件打开标签页
- **实现位置**：
  - `Client/GUI/components/ProjectPage.Shell/FileTree/FileTreeContent.vue`
  - `Client/stores/projectPage/Markdown/markdown.store.ts`

#### 3.2 多标签页系统
- **技术栈**：Element Plus `<el-tabs>`
- **功能**：
  - 动态添加/关闭标签页
  - 标签页切换
  - 文件路径面包屑导航
- **实现位置**：
  - `Client/GUI/PagesLayout/ProjectPage.MainPanel.vue`

#### 3.3 Vditor编辑器集成
- **编辑模式**：
  - **编辑模式**：所见即所得编辑器（`MarkdownEditor.vue`）
  - **预览模式**：只读渲染视图（`MarkdownViewer.vue`）
- **实现位置**：
  - `Client/GUI/components/ProjectPage.MainPanel/Markdown/MarkdownTab.vue`
  - `Client/GUI/components/ProjectPage.MainPanel/Markdown/MarkdownEditor.vue`
  - `Client/GUI/components/ProjectPage.MainPanel/Markdown/MarkdownViewer.vue`

### 4. 数据层架构 ✅

#### 4.1 Pinia Store模块化
- **模块**：`stores/projectPage/Markdown/`
- **文件结构**：
  ```
  stores/projectPage/
    ├── Markdown/
    │   ├── index.ts          # 模块导出
    │   ├── markdown.store.ts # 状态管理逻辑
    │   ├── markdown.mock.ts  # Mock数据
    │   └── types.ts          # TypeScript类型定义
    └── index.ts              # projectPage模块总导出
  ```

#### 4.2 Mock数据支持
- **数据类型**：
  - `MarkdownFile[]` - 文件树数据
  - `MarkdownTab[]` - 打开的标签页列表
- **实现位置**：`Client/stores/projectPage/Markdown/markdown.mock.ts`

---

## 技术实现细节

### 使用的核心API与方法

#### Electron IPC通信

##### 1. 窗口操作IPC（Main Process）
**文件**：`src-electron/core/app-manager.ts`

```typescript
// 窗口最小化
ipcMain.handle('window:minimize', async (event, request: IPCRequest<'window:minimize'>) => {
  return this.handleWindowOperationFromEvent(event, 'minimize', request)
})

// 窗口最大化
ipcMain.handle('window:maximize', async (event, request: IPCRequest<'window:maximize'>) => {
  return this.handleWindowOperationFromEvent(event, 'maximize', request)
})

// 窗口取消最大化
ipcMain.handle('window:unmaximize', async (event, request: IPCRequest<'window:unmaximize'>) => {
  return this.handleWindowOperationFromEvent(event, 'unmaximize', request)
})

// 窗口关闭
ipcMain.handle('window:close', async (event, request: IPCRequest<'window:close'>) => {
  return this.handleWindowOperationFromEvent(event, 'close', request)
})

// 查询窗口是否最大化
ipcMain.handle('window:is-maximized', async (event, request: IPCRequest<'window:is-maximized'>) => {
  return this.handleWindowIsMaximizedFromEvent(event, request)
})
```

**关键改进**：使用 `event.sender` 识别调用窗口
```typescript
private resolveWindowProcessFromEvent(
  event: Electron.IpcMainInvokeEvent,
  windowId?: string
): WindowProcess | null {
  if (!this.windowManager) return null
  
  // 优先使用提供的windowId
  if (windowId) {
    return this.windowManager.getProcess(windowId)
  }
  
  // 🔑 关键：通过event.sender获取调用窗口
  const senderWindow = BrowserWindow.fromWebContents(event.sender)
  if (!senderWindow) {
    return null
  }
  
  return this.windowManager.getProcessByWindowId(senderWindow.id)
}
```

##### 2. 窗口操作IPC（Renderer Process）
**文件**：`Client/GUI/layouts/ProjectMainLayout.vue`

```typescript
// 最小化窗口
async function minimizeWindow() {
  try {
    await (window as any).nimbria.window.minimize()
  } catch (error) {
    console.error('Failed to minimize window:', error)
  }
}

// 切换最大化状态
async function toggleMaximize() {
  try {
    if (isMaximized.value) {
      await (window as any).nimbria.window.unmaximize()
      isMaximized.value = false
    } else {
      await (window as any).nimbria.window.maximize()
      isMaximized.value = true
    }
  } catch (error) {
    console.error('Failed to toggle maximize:', error)
  }
}

// 关闭窗口
async function closeWindow() {
  try {
    await (window as any).nimbria.window.close()
  } catch (error) {
    console.error('Failed to close window:', error)
  }
}
```

**类型断言策略**：使用 `as any` 临时绕过TypeScript类型检查

##### 3. 窗口URL加载
**文件**：`src-electron/core/app-manager.ts`

```typescript
private loadProjectWindow(windowProcess: ProjectWindowProcess) {
  // 开发环境：加载带hash的开发服务器URL
  if (isDevEnvironment) {
    const baseUrl = process.env.APP_URL as string
    const projectUrl = `${baseUrl}#/project`
    void windowProcess.window.loadURL(projectUrl)
    windowProcess.window.webContents.openDevTools()
    return
  }
  
  // 生产环境：加载打包后的index.html
  void windowProcess.window.loadFile(
    path.join(__dirname, '../../index.html'),
    { hash: '/project' }
  )
}
```

#### Vue Router命名视图

**文件**：`Client/GUI/router/routes.ts`

```typescript
{
  path: '/project',
  component: () => import('@index/ProjectPageSystem.vue'),
  children: [
    {
      path: '',
      component: () => import('@layouts/ProjectMainLayout.vue'),
      children: [
        {
          path: '',
          name: 'project-workspace',
          components: {
            left: () => import('@pages/ProjectPage.Shell.vue'),
            center: () => import('@pages/ProjectPage.MainPanel.vue'),
            right: () => import('@pages/ProjectPage.Shell.vue')
          },
          props: {
            left: { type: 'left' },
            center: {},
            right: { type: 'right' }
          }
        }
      ]
    }
  ]
}
```

**关键特性**：
- 使用 `components`（复数）定义多个命名视图
- 通过 `props` 为相同组件传递不同的配置

#### Pinia状态管理

**文件**：`Client/stores/projectPage/Markdown/markdown.store.ts`

```typescript
export const useMarkdownStore = defineStore('projectPage-markdown', () => {
  // 状态定义
  const fileTree = ref<MarkdownFile[]>([])
  const openTabs = ref<MarkdownTab[]>([])
  const activeTabId = ref<string | null>(null)
  
  // 操作方法
  function openFile(file: MarkdownFile) {
    // 检查是否已打开
    const existingTab = openTabs.value.find(tab => tab.filePath === file.path)
    if (existingTab) {
      activeTabId.value = existingTab.id
      return
    }
    
    // 创建新标签页
    const newTab: MarkdownTab = {
      id: `tab-${Date.now()}`,
      filePath: file.path,
      fileName: file.name,
      content: file.content,
      mode: 'edit',
      isDirty: false
    }
    openTabs.value.push(newTab)
    activeTabId.value = newTab.id
  }
  
  function closeTab(tabId: string) {
    const index = openTabs.value.findIndex(tab => tab.id === tabId)
    if (index === -1) return
    
    openTabs.value.splice(index, 1)
    
    // 自动切换到相邻标签页
    if (activeTabId.value === tabId) {
      if (openTabs.value.length > 0) {
        const nextIndex = Math.min(index, openTabs.value.length - 1)
        activeTabId.value = openTabs.value[nextIndex].id
      } else {
        activeTabId.value = null
      }
    }
  }
  
  return {
    fileTree,
    openTabs,
    activeTabId,
    openFile,
    closeTab,
    // ... 其他方法
  }
})
```

#### Element Plus组件

##### 1. 容器布局
```vue
<el-container class="project-content">
  <el-aside :width="leftWidth" class="left-panel">
    <router-view name="left" />
  </el-aside>
  
  <el-main class="center-panel">
    <router-view name="center" />
  </el-main>
  
  <el-aside :width="rightWidth" class="right-panel">
    <router-view name="right" />
  </el-aside>
</el-container>
```

##### 2. 标签页系统
```vue
<el-tabs
  v-model="markdownStore.activeTabId"
  type="card"
  closable
  @tab-remove="handleTabRemove"
  @tab-click="handleTabClick"
>
  <el-tab-pane
    v-for="tab in markdownStore.openTabs"
    :key="tab.id"
    :label="tab.fileName"
    :name="tab.id"
  >
    <MarkdownTab :tab-id="tab.id" />
  </el-tab-pane>
</el-tabs>
```

##### 3. 文件树（Tree组件）
```vue
<el-tree
  :data="markdownStore.fileTree"
  :props="{ children: 'children', label: 'name' }"
  node-key="id"
  :default-expand-all="false"
  @node-click="handleFileClick"
>
  <template #default="{ node, data }">
    <span class="tree-node">
      <el-icon>
        <component :is="data.isFolder ? Folder : Document" />
      </el-icon>
      <span>{{ node.label }}</span>
    </span>
  </template>
</el-tree>
```

#### Vditor API

##### 1. 编辑器初始化
**文件**：`Client/GUI/components/ProjectPage.MainPanel/Markdown/MarkdownEditor.vue`

```typescript
import Vditor from 'vditor'
import 'vditor/dist/index.css'

let vditor: Vditor | null = null

onMounted(() => {
  vditor = new Vditor('vditor-editor', {
    mode: 'wysiwyg',  // 所见即所得模式
    height: '100%',
    placeholder: '开始编辑Markdown文档...',
    theme: 'classic',
    cache: { enable: false },
    after: () => {
      vditor?.setValue(content.value)
    },
    input: (value: string) => {
      emit('update', value)
    }
  })
})
```

##### 2. 预览渲染
**文件**：`Client/GUI/components/ProjectPage.MainPanel/Markdown/MarkdownViewer.vue`

```typescript
import Vditor from 'vditor'

const renderMarkdown = async () => {
  if (!contentRef.value) return
  
  await Vditor.preview(contentRef.value, props.content, {
    mode: 'light',
    markdown: {
      toc: true,
      mark: true,
      footnotes: true,
      autoSpace: true
    }
  })
}

watch(() => props.content, renderMarkdown, { immediate: true })
```

---

## 项目规范与架构

### 目录结构规范

#### 前端文件组织

```
Client/
├── GUI/                          # 视图层
│   ├── Index/                    # 系统入口组件
│   │   ├── HomeSystem.vue        # 主窗口系统入口
│   │   └── ProjectPageSystem.vue # 项目窗口系统入口 ⭐新增
│   │
│   ├── layouts/                  # 布局组件（负责结构与flex布局）
│   │   ├── MainLayout.vue        # 主窗口布局
│   │   ├── ProjectMainLayout.vue # 项目窗口布局 ⭐新增
│   │   └── ProjectMainLayout.scss # 布局样式 ⭐新增
│   │
│   ├── PagesLayout/              # 页面布局组件（负责视觉样式）
│   │   ├── HomeDashboardPage.vue
│   │   ├── ProjectPage.Shell.vue      ⭐新增
│   │   ├── ProjectPage.Shell.scss     ⭐新增
│   │   ├── ProjectPage.MainPanel.vue  ⭐新增
│   │   └── ProjectPage.MainPanel.scss ⭐新增
│   │
│   ├── components/               # 业务组件
│   │   ├── ProjectPage.Shell/        ⭐新增
│   │   │   ├── Navbar/
│   │   │   │   └── ProjectNavbar.vue
│   │   │   ├── FileTree/
│   │   │   │   ├── FileTreeToolbar.vue
│   │   │   │   └── FileTreeContent.vue
│   │   │   └── Outline/
│   │   │       └── OutlineContent.vue
│   │   │
│   │   └── ProjectPage.MainPanel/    ⭐新增
│   │       └── Markdown/
│   │           ├── MarkdownTab.vue
│   │           ├── MarkdownEditor.vue
│   │           └── MarkdownViewer.vue
│   │
│   └── router/
│       ├── index.ts
│       └── routes.ts             # 路由配置 ⭐修改
│
├── stores/                       # 状态管理
│   ├── projectPage/              ⭐新增模块
│   │   ├── index.ts
│   │   └── Markdown/
│   │       ├── index.ts
│   │       ├── markdown.store.ts
│   │       ├── markdown.mock.ts
│   │       └── types.ts
│   └── index.ts
│
├── boot/                         # 启动文件
│   ├── axios.ts
│   ├── framework-init.ts
│   └── element-plus.ts           ⭐新增
│
└── types/                        # 类型定义
    ├── project.ts
    └── window.d.ts
```

#### 后端文件组织

```
src-electron/
├── core/
│   ├── electron-main.ts          # Electron入口
│   └── app-manager.ts            # 应用管理器 ⭐修改
│
├── services/
│   └── window-service/
│       ├── window-manager.ts     # 窗口管理器 ⭐修改
│       └── process-manager.ts    # 进程管理器 ⭐修改
│
└── ipc/
    └── main-renderer/
        ├── channel-definitions.ts
        └── ipc-handlers.ts
```

### 命名规范

#### 1. 文件命名

| 文件类型 | 命名规则 | 示例 |
|---------|---------|------|
| Vue组件 | PascalCase | `ProjectMainLayout.vue` |
| TypeScript文件 | kebab-case | `markdown.store.ts` |
| SCSS文件 | kebab-case | `ProjectMainLayout.scss` |
| 目录 | PascalCase（组件目录）<br>kebab-case（功能目录） | `ProjectPage.Shell/`<br>`window-service/` |

#### 2. 组件命名模式

**模块化命名**：`{Module}.{ComponentType}.{ComponentName}.vue`

示例：
- `ProjectPage.Shell.vue` - 项目页的Shell组件
- `ProjectPage.MainPanel.vue` - 项目页的主面板
- `HomeDashboard.KeyMetrics.vue` - 首页仪表盘的关键指标组件

#### 3. Store命名

**命名空间模式**：`{module}-{subModule}`

```typescript
// ✅ 正确
defineStore('projectPage-markdown', () => {})
defineStore('home-dashboard', () => {})

// ❌ 错误
defineStore('markdown', () => {})  // 缺少命名空间
```

#### 4. 路径别名

**配置位置**：`quasar.config.ts`

```typescript
alias.push(
  { find: '@', replacement: path.resolve(__dirname, 'Client') },
  { find: '@types', replacement: path.resolve(__dirname, 'Client/types') },
  { find: '@components', replacement: path.resolve(__dirname, 'Client/GUI/components') },
  { find: '@layouts', replacement: path.resolve(__dirname, 'Client/GUI/layouts') },
  { find: '@pages', replacement: path.resolve(__dirname, 'Client/GUI/PagesLayout') },
  { find: '@stores', replacement: path.resolve(__dirname, 'Client/stores') },
  { find: '@index', replacement: path.resolve(__dirname, 'Client/GUI/Index') }
)
```

**使用原则**：
- ✅ 推荐：使用别名进行跨模块导入
- ❌ 禁止：使用 `../../` 跨父目录的相对路径

```typescript
// ✅ 正确
import { useMarkdownStore } from '@stores/projectPage'
import ProjectNavbar from '@components/ProjectPage.Shell/Navbar/ProjectNavbar.vue'

// ❌ 错误
import { useMarkdownStore } from '../../../stores/projectPage'
import ProjectNavbar from '../../components/ProjectPage.Shell/Navbar/ProjectNavbar.vue'
```

### 架构设计模式

#### 1. Shell设计模式

**核心理念**：通过单一可复用组件 + Props配置，实现不同视图的内容分发

**实现**：
```vue
<!-- ProjectPage.Shell.vue -->
<template>
  <div class="project-page-shell" :class="[`shell-${type}`]">
    <template v-if="type === 'left'">
      <ProjectNavbar />
      <FileTreeContent />
    </template>
    
    <template v-else-if="type === 'right'">
      <OutlineContent />
    </template>
  </div>
</template>

<script setup lang="ts">
defineProps<{ type: 'left' | 'right' }>()
</script>
```

**路由配置**：
```typescript
{
  components: {
    left: () => import('@pages/ProjectPage.Shell.vue'),
    right: () => import('@pages/ProjectPage.Shell.vue')
  },
  props: {
    left: { type: 'left' },
    right: { type: 'right' }
  }
}
```

**优势**：
- 减少代码重复
- 统一布局逻辑
- 便于维护和扩展

#### 2. 样式分层架构

**原则**：布局逻辑与视觉样式分离

| 层级 | 职责 | 文件位置 |
|-----|------|---------|
| **Layout层** | Flexbox布局、overflow控制、高度管理 | `layouts/*.scss` |
| **Page层** | 颜色、背景、边框、字体等视觉样式 | `PagesLayout/*.scss` |

**示例**：

```scss
/* layouts/ProjectMainLayout.scss - 布局逻辑 */
.project-main-layout {
  display: flex;
  flex-direction: column;
  overflow: hidden;  /* 🔑 控制滚动行为 */
  height: 100vh;
}

.project-content {
  flex: 1;
  min-height: 0;  /* 🔑 允许flex压缩 */
}

/* PagesLayout/ProjectPage.Shell.scss - 视觉样式 */
.project-page-shell {
  background: var(--obsidian-bg-primary);
  border-right: 1px solid var(--obsidian-border);
  color: var(--obsidian-text-primary);
}
```

#### 3. Flexbox滚动容器模式

**关键技巧**：正确处理flex容器中的滚动区域

```scss
/* ✅ 正确的滚动容器结构 */
.parent {
  display: flex;
  flex-direction: column;
  overflow: hidden;      /* 父容器禁止滚动 */
  height: 100%;
}

.header {
  flex-shrink: 0;        /* 头部固定 */
}

.scrollable-content {
  flex: 1;
  min-height: 0;         /* 🔑 关键！允许flex压缩 */
  overflow-y: auto;      /* 子容器可滚动 */
}
```

**常见错误**：
```scss
/* ❌ 错误：缺少 min-height: 0 */
.scrollable-content {
  flex: 1;
  overflow-y: auto;  /* 无效！因为flex默认 min-height: auto */
}
```

#### 4. CSS变量主题化

**Obsidian主题变量**：
```scss
.project-main-layout {
  /* 只在项目页作用域内生效 */
  --obsidian-bg-primary: #ffffff;
  --obsidian-bg-secondary: #f5f6f8;
  --obsidian-border: #e3e5e8;
  --obsidian-text-primary: #2e3338;
  --obsidian-text-secondary: #6a6d74;
  --obsidian-accent: #5b7fff;
  --obsidian-hover-bg: #e9e9e9;
}
```

**与Quasar主题共存策略**：
- Quasar全局主题不受影响
- Obsidian变量仅在 `.project-main-layout` 作用域内有效
- 子组件通过 `var(--obsidian-*)` 引用变量

---

## 遇到的问题与解决方案

### 问题1：新窗口白屏 ❌➡️✅

**现象**：
- 点击项目卡片后，弹出的新窗口完全空白
- 控制台无报错信息

**根本原因**：
窗口创建后未加载任何URL

**错误代码**：
```typescript
// app-manager.ts - 错误示范
else if (windowProcess.type === 'project') {
  // 什么都没做！窗口创建后未加载内容
}
```

**解决方案**：
```typescript
// app-manager.ts - 修复后
else if (windowProcess.type === 'project') {
  this.loadProjectWindow(windowProcess as ProjectWindowProcess)
}

private loadProjectWindow(windowProcess: ProjectWindowProcess) {
  if (isDevEnvironment) {
    // 开发环境：加载hash路由
    const baseUrl = process.env.APP_URL as string
    const projectUrl = `${baseUrl}#/project`
    void windowProcess.window.loadURL(projectUrl)
    windowProcess.window.webContents.openDevTools()
    return
  }
  
  // 生产环境：加载静态文件
  void windowProcess.window.loadFile(
    path.join(__dirname, '../../index.html'),
    { hash: '/project' }
  )
}
```

**关键点**：
- ✅ 使用hash路由（`#/project`）而非传统路由
- ✅ 开发/生产环境分别处理URL加载方式

---

### 问题2：CSS编译错误 ❌➡️✅

**错误信息**：
```
[postcss] Unknown word
D:/code/.../FileTreeContent.vue?vue&type=style&index=0&scoped=01806e68&lang.css:7:18
7 | min-height: 0; // 🔑 关键！
  |                ^
```

**根本原因**：
在CSS/Vue的 `<style scoped>` 中使用了 `//` 注释，PostCSS将其作为CSS解析时不认识该语法

**错误代码**：
```vue
<style scoped lang="scss">
.file-tree {
  overflow-x: hidden;
  padding: 8px;
  min-height: 0; // 🔑 关键！
}
</style>
```

**解决方案**：
将所有 `//` 注释替换为 `/* */` 注释

```vue
<style scoped lang="scss">
.file-tree {
  overflow-x: hidden;
  padding: 8px;
  min-height: 0; /* 🔑 关键！ */
}
</style>
```

**涉及文件**：
- `FileTreeContent.vue`
- `OutlineContent.vue`
- `ProjectPage.Shell.vue`
- `ProjectPage.MainPanel.vue`
- `MarkdownTab.vue`
- `MarkdownViewer.vue`

**经验教训**：
- ✅ `/* */` 注释兼容CSS和SCSS
- ❌ `//` 注释仅在纯SCSS文件中有效
- 💡 在Vue单文件组件中，即使声明了 `lang="scss"`，PostCSS仍可能先作为CSS处理

---

### 问题3：窗口控制按钮操作错误窗口 ❌➡️✅

**现象**：
- 项目窗口的最小化、最大化、关闭按钮
- 实际控制的是主窗口（HomePage）

**根本原因**：
IPC处理器无法正确识别调用来源窗口，默认使用了主窗口

**错误代码**：
```typescript
// app-manager.ts - 错误示范
ipcMain.handle('window:minimize', async (_, request: IPCRequest<'window:minimize'>) => {
  const windowProcess = this.resolveWindowProcess(request.data?.windowId)
  // 当windowId未提供时，默认返回主窗口
})

private resolveWindowProcess(windowId?: string): WindowProcess | null {
  if (!this.windowManager) return null
  
  if (windowId) {
    return this.windowManager.getProcess(windowId)
  }
  
  // ❌ 错误：直接返回主窗口进程
  return this.windowManager.getProcess(this.config.windows.main.name)
}
```

**解决方案**：
使用 `event.sender` 识别调用窗口

```typescript
// app-manager.ts - 修复后
ipcMain.handle('window:minimize', async (event, request: IPCRequest<'window:minimize'>) => {
  return this.handleWindowOperationFromEvent(event, 'minimize', request)
})

private handleWindowOperationFromEvent(
  event: Electron.IpcMainInvokeEvent,
  operation: 'minimize' | 'maximize' | 'unmaximize' | 'close' | 'focus',
  request: IPCRequest<any>
): IPCResponse<void> {
  try {
    // 🔑 关键：通过event.sender识别窗口
    const windowProcess = this.resolveWindowProcessFromEvent(event, request.data?.windowId)
    
    if (!windowProcess) {
      return createIPCResponse(false, undefined, 'Window not found')
    }
    
    // 执行窗口操作
    switch (operation) {
      case 'minimize':
        windowProcess.window.minimize()
        break
      case 'maximize':
        windowProcess.window.maximize()
        break
      // ... 其他操作
    }
    
    return createIPCResponse(true)
  } catch (error) {
    return createIPCResponse(false, undefined, String(error))
  }
}

private resolveWindowProcessFromEvent(
  event: Electron.IpcMainInvokeEvent,
  windowId?: string
): WindowProcess | null {
  if (!this.windowManager) return null
  
  // 优先使用提供的windowId
  if (windowId) {
    return this.windowManager.getProcess(windowId)
  }
  
  // 🔑 关键：从event.sender获取BrowserWindow实例
  const senderWindow = BrowserWindow.fromWebContents(event.sender)
  if (!senderWindow) {
    return null
  }
  
  // 通过BrowserWindow.id查找对应的WindowProcess
  return this.windowManager.getProcessByWindowId(senderWindow.id)
}
```

**新增方法**：
```typescript
// window-manager.ts
public getProcessByWindowId(windowId: number): WindowProcess | null {
  return this.processManager.getProcessByWindowId(windowId)
}

// process-manager.ts
public getProcessByWindowId(windowId: number): WindowProcess | null {
  for (const entry of this.processes.values()) {
    if (entry.process.window.id === windowId) {
      return entry.process
    }
  }
  return null
}
```

**关键改进**：
1. ✅ 所有IPC handlers接收 `event` 参数
2. ✅ 使用 `BrowserWindow.fromWebContents(event.sender)` 获取调用窗口
3. ✅ 通过 `window.id` 查找对应的 `WindowProcess`
4. ✅ 完全独立的窗口操作能力

---

### 问题4：TypeScript类型错误 ⚠️➡️🔧

**现象**：
```typescript
// ProjectMainLayout.vue
async function minimizeWindow() {
  await window.nimbria.window.minimize()  // ❌ 类型错误
}
```

**错误信息**：
```
Property 'nimbria' does not exist on type 'Window & typeof globalThis'
```

**根本原因**：
`window.nimbria` API在 `window.d.ts` 中定义的类型结构与实际使用不匹配

**临时解决方案**：
使用类型断言 `as any`

```typescript
async function minimizeWindow() {
  try {
    await (window as any).nimbria.window.minimize()
  } catch (error) {
    console.error('Failed to minimize window:', error)
  }
}
```

**正确的长期解决方案**（待实施）：
修正 `Client/types/window.d.ts` 中的类型定义

```typescript
// window.d.ts - 应该修正为
declare global {
  interface Window {
    nimbria: {
      window: {
        minimize: () => Promise<void>
        maximize: () => Promise<void>
        unmaximize: () => Promise<void>
        close: () => Promise<void>
        isMaximized: () => Promise<boolean>
      }
      // ... 其他API
    }
  }
}
```

**注意事项**：
- ⚠️ `as any` 是临时绕过方案，会失去类型安全
- 🔧 建议后续优先修正类型定义文件
- 📝 需要同步检查 `preload.ts` 中的API暴露结构

---

### 问题5：窗口控制栏样式调整 🎨➡️✅

**用户反馈**：
1. 控制栏颜色与主程序不一致
2. 最小化按钮垂直位置需要微调

**解决方案1：统一颜色风格**

```scss
/* ProjectMainLayout.scss - 修改前 */
.project-titlebar {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);  /* 紫色渐变 */
  color: white;
}

/* ProjectMainLayout.scss - 修改后 */
.project-titlebar {
  background: #ffffff;  /* 白色背景 */
  color: #2e3338;       /* 深色文字 */
  border-bottom: 1px solid #e3e5e8;  /* 底部边框 */
}

.project-titlebar__btn {
  color: #6a6d74;  /* 按钮默认颜色 */
  
  &:hover {
    background: rgba(0, 0, 0, 0.05);
    color: #2e3338;
  }
  
  &--close:hover {
    background: #e53935;  /* 关闭按钮红色悬停 */
    color: white;
  }
}
```

**解决方案2：按钮垂直偏移**

```scss
/* ProjectMainLayout.scss */
.project-titlebar__btn {
  &--minimize {
    position: relative;
    top: -5px;  /* 向上偏移5px */
  }
}
```

**Vue模板对应修改**：
```vue
<q-btn 
  icon="minimize"
  class="... project-titlebar__btn--minimize"
/>
```

**调整方法**：
- `top: -5px` - 向上移动5px
- `top: 5px` - 向下移动5px
- 也可使用 `transform: translateY(-5px)`

---

## 经验总结

### 1. Electron多窗口开发

#### ✅ 最佳实践

1. **窗口URL加载**
   - 开发环境使用hash路由（`#/route`）
   - 生产环境使用 `loadFile()` + hash参数
   - 区分处理避免路由失效

2. **IPC窗口识别**
   - 始终使用 `event.sender` 识别调用源
   - 不要依赖默认窗口或硬编码窗口ID
   - 通过 `BrowserWindow.id` 建立精确映射

3. **类型安全**
   - 维护完整的 `window.d.ts` 类型定义
   - preload脚本暴露的API要有对应类型
   - 避免滥用 `as any`

#### ❌ 常见陷阱

1. **忘记为新窗口加载URL**
   - 现象：窗口创建成功但显示空白
   - 检查：确保在窗口创建回调中调用 `loadURL()` 或 `loadFile()`

2. **IPC handler默认操作主窗口**
   - 现象：所有窗口的按钮都控制主窗口
   - 检查：IPC handler是否正确识别了调用源窗口

3. **开发/生产环境URL不一致**
   - 现象：开发正常，打包后路由失效
   - 检查：是否分别处理了devServer URL和静态文件路径

### 2. Vue Router多视图

#### ✅ 最佳实践

1. **命名视图 + Props模式**
   ```typescript
   {
     components: { left: Shell, right: Shell },
     props: { left: { type: 'left' }, right: { type: 'right' } }
   }
   ```
   - 实现组件复用
   - 通过props控制行为差异

2. **路由层级设计**
   ```
   /project (系统入口)
     └── '' (布局容器)
           └── '' (命名视图分发)
   ```
   - 清晰的层级关系
   - 便于后续扩展子路由

#### ❌ 常见陷阱

1. **忘记在layout中添加 `<router-view />`**
   - 现象：子路由无法渲染
   - 检查：每层layout都要有对应的router-view出口

2. **命名视图忘记传递props**
   - 现象：组件无法区分自己的角色
   - 检查：`props` 配置是否与 `components` 对应

### 3. Flexbox布局

#### ✅ 黄金法则

```scss
/* 滚动容器的父元素 */
.parent {
  display: flex;
  flex-direction: column;
  overflow: hidden;  /* ⭐ 父容器禁止滚动 */
}

/* 滚动容器本身 */
.scrollable {
  flex: 1;
  min-height: 0;     /* ⭐ 关键！允许flex压缩 */
  overflow-y: auto;  /* ⭐ 子容器可滚动 */
}
```

**记忆口诀**：
- 父级 `overflow: hidden`
- 子级 `min-height: 0`
- 滚动区 `overflow-y: auto`

#### ❌ 常见错误

```scss
/* ❌ 错误：缺少 min-height: 0 */
.scrollable {
  flex: 1;
  overflow-y: auto;  /* 不生效！ */
}

/* ❌ 错误：父级没有限制高度 */
.parent {
  display: flex;
  /* 没有 height 或 flex: 1 */
}
.scrollable {
  overflow-y: auto;  /* 不生效！ */
}
```

### 4. CSS注释语法

#### ✅ 推荐做法

```scss
/* ✅ 在所有场景都有效 */
.class {
  property: value; /* 注释 */
}
```

#### ❌ 避免的写法

```scss
/* ❌ 在Vue SFC中可能出错 */
.class {
  property: value; // 注释
}
```

**规则**：
- 纯 `.scss` 文件：两种注释都可以
- Vue `<style lang="scss">`：只用 `/* */`
- 原因：PostCSS可能在SCSS编译前处理，导致 `//` 被误识别

### 5. 原型迁移策略

#### ✅ 推荐流程

1. **保留原技术栈**
   - 不要盲目替换原型使用的库（如Vditor）
   - 直接将依赖添加到主项目

2. **调整目录结构**
   - 遵循主项目的目录规范
   - 使用路径别名避免相对路径混乱

3. **逐步迁移文件**
   - 先迁移数据层（stores、types）
   - 再迁移视图层（layouts、pages、components）
   - 最后配置路由和启动项

4. **测试验证**
   - 每迁移一个模块就测试一次
   - 避免一次性迁移导致难以定位问题

#### ❌ 避免的做法

1. **盲目重构**
   - 不要在迁移时大幅修改原型逻辑
   - 先迁移能跑通，再考虑优化

2. **忽略样式细节**
   - Flexbox、overflow等布局关键点要原样保留
   - CSS变量、主题系统要一并迁移

### 6. 依赖管理

#### ✅ 添加新库的流程

1. **修改 `package.json`**
   ```json
   {
     "dependencies": {
       "element-plus": "^2.9.1",
       "vditor": "^3.10.7"
     }
   }
   ```

2. **创建boot文件**
   ```typescript
   // Client/boot/element-plus.ts
   import { boot } from 'quasar/wrappers'
   import ElementPlus from 'element-plus'
   
   export default boot(({ app }) => {
     app.use(ElementPlus)
   })
   ```

3. **注册到quasar.config.ts**
   ```typescript
   boot: ['axios', 'element-plus']
   ```

4. **安装依赖**
   ```bash
   npm install
   ```

#### ⚠️ 注意事项

- Element Plus与Quasar共存时，优先使用Quasar组件
- 仅在Quasar不支持的场景使用Element Plus
- 避免样式冲突（通过作用域CSS控制）

---

## 标准工作流程

### 工作流1：添加新页面系统

#### 阶段1：规划与设计 📋

**输入**：需求描述、原型或参考设计

**步骤**：

1. **创建设计文档**
   ```
   Document/Design/{功能名称}/
     ├── 初始需求分析.md
     ├── 具体Design.md
     └── 文档参考.md
   ```

2. **确定目录结构**
   - 确定新系统在 `Client/GUI/` 下的位置
   - 规划 `Index`、`layouts`、`PagesLayout`、`components` 的文件
   - 规划 `stores` 的模块结构

3. **确定技术选型**
   - 列出需要的新依赖（如Element Plus、Vditor）
   - 确认与现有技术栈的兼容性

4. **设计路由结构**
   ```typescript
   /new-system (入口)
     └── '' (布局)
           └── '' (内容分发)
   ```

**输出**：详细的设计文档（如本次的 `Design.md`）

---

#### 阶段2：数据层搭建 💾

**步骤**：

1. **定义TypeScript类型**
   ```typescript
   // Client/stores/{module}/{subModule}/types.ts
   export interface DataType { /* ... */ }
   ```

2. **创建Mock数据**
   ```typescript
   // Client/stores/{module}/{subModule}/{name}.mock.ts
   export const mockData: DataType[] = [ /* ... */ ]
   ```

3. **编写Pinia Store**
   ```typescript
   // Client/stores/{module}/{subModule}/{name}.store.ts
   export const useXxxStore = defineStore('{module}-{subModule}', () => {
     const data = ref<DataType[]>([])
     
     function loadData() {
       data.value = mockData
     }
     
     return { data, loadData }
   })
   ```

4. **创建模块索引**
   ```typescript
   // Client/stores/{module}/{subModule}/index.ts
   export * from './types'
   export * from './{name}.store'
   export * from './{name}.mock'
   
   // Client/stores/{module}/index.ts
   export * from './{subModule}'
   ```

**验证**：在浏览器Console中测试Store能否正常导入和使用

---

#### 阶段3：布局层搭建 🏗️

**步骤**：

1. **创建系统入口组件**
   ```vue
   <!-- Client/GUI/Index/{SystemName}.vue -->
   <template>
     <router-view />
   </template>
   ```

2. **创建布局组件（Layout）**
   ```vue
   <!-- Client/GUI/layouts/{SystemName}Layout.vue -->
   <template>
     <div class="{system}-layout">
       <!-- Flexbox结构 -->
       <router-view name="left" />
       <router-view name="center" />
       <router-view name="right" />
     </div>
   </template>
   ```

3. **编写布局样式（SCSS）**
   ```scss
   // Client/GUI/layouts/{SystemName}Layout.scss
   .{system}-layout {
     display: flex;
     height: 100vh;
     overflow: hidden;  /* 关键 */
     
     .left-panel {
       flex: 0 0 250px;
       min-height: 0;   /* 关键 */
     }
     
     .center-panel {
       flex: 1;
       min-height: 0;   /* 关键 */
       overflow-y: auto;
     }
   }
   ```

**验证**：在浏览器中检查布局是否正确，滚动行为是否符合预期

---

#### 阶段4：页面层搭建 📄

**步骤**：

1. **创建页面组件**
   ```vue
   <!-- Client/GUI/PagesLayout/{SystemName}.{PageName}.vue -->
   <template>
     <div class="{system}-{page}">
       <ComponentA />
       <ComponentB />
     </div>
   </template>
   
   <script setup lang="ts">
   import ComponentA from '@components/{SystemName}.{PageName}/ComponentA.vue'
   </script>
   
   <style scoped lang="scss">
   @import './{SystemName}.{PageName}.scss';
   </style>
   ```

2. **编写视觉样式（SCSS）**
   ```scss
   // Client/GUI/PagesLayout/{SystemName}.{PageName}.scss
   .{system}-{page} {
     background: var(--custom-bg);
     color: var(--custom-text);
     padding: 16px;
   }
   ```

**验证**：在浏览器中检查样式是否正确应用

---

#### 阶段5：组件层搭建 🧩

**步骤**：

1. **创建组件目录**
   ```
   Client/GUI/components/{SystemName}.{PageName}/
     ├── {Category1}/
     │   ├── Component1.vue
     │   └── Component2.vue
     └── {Category2}/
         └── Component3.vue
   ```

2. **编写业务组件**
   ```vue
   <!-- Component示例 -->
   <template>
     <div class="component">
       <!-- 组件内容 -->
     </div>
   </template>
   
   <script setup lang="ts">
   import { useXxxStore } from '@stores/{module}'
   
   const store = useXxxStore()
   </script>
   
   <style scoped lang="scss">
   .component {
     /* 组件样式 */
   }
   </style>
   ```

**验证**：测试组件与Store的交互是否正常

---

#### 阶段6：路由配置 🛤️

**步骤**：

1. **添加路由规则**
   ```typescript
   // Client/GUI/router/routes.ts
   const routes: RouteRecordRaw[] = [
     // ... 现有路由
     {
       path: '/{system}',
       component: () => import('@index/{SystemName}.vue'),
       children: [
         {
           path: '',
           component: () => import('@layouts/{SystemName}Layout.vue'),
           children: [
             {
               path: '',
               name: '{system}-main',
               components: {
                 left: () => import('@pages/{SystemName}.LeftPanel.vue'),
                 center: () => import('@pages/{SystemName}.CenterPanel.vue'),
                 right: () => import('@pages/{SystemName}.RightPanel.vue')
               }
             }
           ]
         }
       ]
     }
   ]
   ```

2. **测试路由跳转**
   ```typescript
   // 在需要跳转的地方
   import { useRouter } from 'vue-router'
   
   const router = useRouter()
   router.push('/{system}')
   ```

**验证**：手动在浏览器地址栏输入路由，检查是否能正确渲染

---

#### 阶段7：Electron集成（多窗口场景） 🪟

**适用场景**：需要在独立窗口中打开新系统

**步骤**：

1. **修改窗口加载逻辑**
   ```typescript
   // src-electron/core/app-manager.ts
   private load{System}Window(windowProcess: {System}WindowProcess) {
     if (isDevEnvironment) {
       const baseUrl = process.env.APP_URL as string
       const url = `${baseUrl}#/{system}`
       void windowProcess.window.loadURL(url)
       windowProcess.window.webContents.openDevTools()
       return
     }
     
     void windowProcess.window.loadFile(
       path.join(__dirname, '../../index.html'),
       { hash: '/{system}' }
     )
   }
   ```

2. **在生命周期钩子中调用**
   ```typescript
   else if (windowProcess.type === '{system}') {
     this.load{System}Window(windowProcess as {System}WindowProcess)
   }
   ```

3. **配置IPC handlers（如需窗口控制）**
   ```typescript
   ipcMain.handle('window:operation', async (event, request) => {
     const windowProcess = this.resolveWindowProcessFromEvent(event)
     // 执行操作
   })
   ```

**验证**：
- 新窗口能否正常打开
- 路由是否正确加载
- 开发工具中无报错

---

#### 阶段8：依赖与样式集成 📦

**步骤**：

1. **添加新依赖**
   ```json
   // package.json
   {
     "dependencies": {
       "new-library": "^x.x.x"
     }
   }
   ```

2. **创建boot文件（如需全局注册）**
   ```typescript
   // Client/boot/new-library.ts
   import { boot } from 'quasar/wrappers'
   import NewLibrary from 'new-library'
   import 'new-library/dist/style.css'
   
   export default boot(({ app }) => {
     app.use(NewLibrary)
   })
   ```

3. **注册到quasar.config.ts**
   ```typescript
   boot: [
     // ... 现有boot
     'new-library'
   ],
   
   // 如需路径别名
   alias.push({
     find: '@{alias}',
     replacement: path.resolve(__dirname, 'Client/{path}')
   })
   ```

4. **安装依赖**
   ```bash
   npm install
   ```

**验证**：
- 开发服务器能否正常启动
- 新库的组件/API能否正常使用

---

#### 阶段9：测试与调试 🐛

**测试清单**：

- [ ] 路由跳转是否正常
- [ ] 数据加载是否正确
- [ ] 组件渲染是否符合预期
- [ ] 样式是否正确应用
- [ ] Flexbox布局是否响应正确
- [ ] 滚动区域是否正常工作
- [ ] （多窗口）窗口操作是否正确
- [ ] （多窗口）IPC通信是否正常
- [ ] 浏览器Console无错误
- [ ] Linter无警告

**常见调试工具**：
```bash
# 运行开发服务器
npm run dev

# 检查类型错误
npx vue-tsc --noEmit

# 检查Linter问题
npx eslint Client/
```

---

#### 阶段10：文档与总结 📝

**步骤**：

1. **更新设计文档**
   - 记录实际实现与计划的差异
   - 补充遇到的问题和解决方案

2. **创建总结报告**
   ```
   Document/总结/{功能名称}实现总结_{日期}.md
   ```
   - 参考本文档的结构
   - 记录关键技术点和经验教训

3. **更新工作流文档**
   ```
   Document/Workflow/{功能名称}添加流程.md
   ```
   - 提炼标准化流程
   - 为后续类似工作提供模板

---

### 工作流2：原型系统迁移

#### 输入
- 独立运行的原型项目
- 原型使用的技术栈列表

#### 标准步骤

1. **评估技术栈兼容性**
   - 检查原型依赖是否与主项目冲突
   - 决定是保留原技术还是替换

2. **规划目录映射**
   ```
   原型/src/components/       -> 主项目/Client/GUI/components/{Module}/
   原型/src/views/            -> 主项目/Client/GUI/PagesLayout/
   原型/src/stores/           -> 主项目/Client/stores/{module}/
   原型/src/types/            -> 主项目/Client/types/ 或 stores/{module}/types.ts
   ```

3. **调整导入路径**
   - 将相对路径改为别名路径
   - 更新所有 `import` 语句

4. **迁移顺序**
   ```
   类型定义 -> Mock数据 -> Store -> 布局 -> 页面 -> 组件 -> 路由
   ```

5. **逐步验证**
   - 每迁移一层就运行一次测试
   - 确保无TypeScript错误和Linter警告

#### 注意事项
- ⚠️ 保留原型的关键布局逻辑（如Flexbox、overflow处理）
- ⚠️ CSS变量、主题系统要完整迁移
- ⚠️ 不要在迁移时大幅重构逻辑

---

## 附录

### A. 关键文件清单

#### 新增文件

**前端（Client/）**

```
Client/
├── boot/
│   └── element-plus.ts                                          ⭐ 新增
│
├── GUI/
│   ├── Index/
│   │   └── ProjectPageSystem.vue                                ⭐ 新增
│   │
│   ├── layouts/
│   │   ├── ProjectMainLayout.vue                                ⭐ 新增
│   │   └── ProjectMainLayout.scss                               ⭐ 新增
│   │
│   ├── PagesLayout/
│   │   ├── ProjectPage.Shell.vue                                ⭐ 新增
│   │   ├── ProjectPage.Shell.scss                               ⭐ 新增
│   │   ├── ProjectPage.MainPanel.vue                            ⭐ 新增
│   │   └── ProjectPage.MainPanel.scss                           ⭐ 新增
│   │
│   └── components/
│       ├── ProjectPage.Shell/                                   ⭐ 新增目录
│       │   ├── Navbar/
│       │   │   └── ProjectNavbar.vue
│       │   ├── FileTree/
│       │   │   ├── FileTreeToolbar.vue
│       │   │   └── FileTreeContent.vue
│       │   └── Outline/
│       │       └── OutlineContent.vue
│       │
│       └── ProjectPage.MainPanel/                               ⭐ 新增目录
│           └── Markdown/
│               ├── MarkdownTab.vue
│               ├── MarkdownEditor.vue
│               └── MarkdownViewer.vue
│
└── stores/
    └── projectPage/                                             ⭐ 新增模块
        ├── index.ts
        └── Markdown/
            ├── index.ts
            ├── markdown.store.ts
            ├── markdown.mock.ts
            └── types.ts
```

**后端（src-electron/）**

无新增文件，仅修改现有文件

#### 修改文件

```
✏️ Nimbria/package.json
✏️ Nimbria/quasar.config.ts
✏️ Nimbria/Client/GUI/router/routes.ts
✏️ Nimbria/src-electron/core/app-manager.ts
✏️ Nimbria/src-electron/services/window-service/window-manager.ts
✏️ Nimbria/src-electron/services/window-service/process-manager.ts
```

---

### B. 依赖变更

**新增依赖**

```json
{
  "dependencies": {
    "element-plus": "^2.9.1",
    "@element-plus/icons-vue": "^2.3.1",
    "vditor": "^3.10.7"
  }
}
```

**依赖用途**

| 依赖 | 用途 | 使用场景 |
|-----|------|---------|
| `element-plus` | UI组件库 | 容器布局、标签页、文件树 |
| `@element-plus/icons-vue` | Element Plus图标库 | 文件树图标、工具栏图标 |
| `vditor` | Markdown编辑器 | 文档编辑和预览 |

---

### C. 路径别名配置

**quasar.config.ts**

```typescript
alias.push(
  { find: '@', replacement: path.resolve(__dirname, 'Client') },
  { find: '@types', replacement: path.resolve(__dirname, 'Client/types') },
  { find: '@components', replacement: path.resolve(__dirname, 'Client/GUI/components') },
  { find: '@layouts', replacement: path.resolve(__dirname, 'Client/GUI/layouts') },
  { find: '@pages', replacement: path.resolve(__dirname, 'Client/GUI/PagesLayout') },
  { find: '@stores', replacement: path.resolve(__dirname, 'Client/stores') },
  { find: '@index', replacement: path.resolve(__dirname, 'Client/GUI/Index') }
)
```

**使用示例**

```typescript
// ✅ 推荐
import { useMarkdownStore } from '@stores/projectPage'
import ProjectNavbar from '@components/ProjectPage.Shell/Navbar/ProjectNavbar.vue'
import type { MarkdownFile } from '@stores/projectPage/Markdown/types'

// ❌ 不推荐
import { useMarkdownStore } from '../../../stores/projectPage'
import ProjectNavbar from '../../components/ProjectPage.Shell/Navbar/ProjectNavbar.vue'
```

---

### D. CSS变量清单

**Obsidian主题变量**

```scss
.project-main-layout {
  --obsidian-bg-primary: #ffffff;       /* 主背景色 */
  --obsidian-bg-secondary: #f5f6f8;     /* 次级背景色 */
  --obsidian-border: #e3e5e8;           /* 边框颜色 */
  --obsidian-text-primary: #2e3338;     /* 主文字颜色 */
  --obsidian-text-secondary: #6a6d74;   /* 次级文字颜色 */
  --obsidian-accent: #5b7fff;           /* 强调色 */
  --obsidian-hover-bg: #e9e9e9;         /* 悬停背景色 */
  --obsidian-font-text: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --obsidian-font-mono: 'Menlo', 'Consolas', monospace;
}
```

**使用方式**

```scss
.component {
  background: var(--obsidian-bg-primary);
  color: var(--obsidian-text-primary);
  border: 1px solid var(--obsidian-border);
}
```

---

### E. IPC通道清单

**窗口操作通道**

| 通道名 | 方向 | 参数 | 返回值 | 用途 |
|-------|------|------|-------|------|
| `window:minimize` | Renderer → Main | `{ windowId?: string }` | `void` | 最小化窗口 |
| `window:maximize` | Renderer → Main | `{ windowId?: string }` | `void` | 最大化窗口 |
| `window:unmaximize` | Renderer → Main | `{ windowId?: string }` | `void` | 取消最大化 |
| `window:close` | Renderer → Main | `{ windowId?: string }` | `void` | 关闭窗口 |
| `window:is-maximized` | Renderer → Main | `{ windowId?: string }` | `boolean` | 查询最大化状态 |

**调用示例**

```typescript
// Renderer进程
await window.nimbria.window.minimize()
await window.nimbria.window.maximize()
await window.nimbria.window.close()
const isMax = await window.nimbria.window.isMaximized()
```

---

## 下一阶段工作建议

### 优先级1：修复类型定义 🔧

**问题**：当前使用 `as any` 绕过类型检查

**任务**：
1. 检查 `Client/types/window.d.ts` 中的类型定义
2. 确保与 `preload.ts` 暴露的API结构一致
3. 移除所有 `as any` 断言

**预期成果**：
- 完整的TypeScript类型安全
- IDE自动补全支持

---

### 优先级2：实现真实文件系统集成 💾

**当前状态**：使用Mock数据

**任务**：
1. 实现文件系统读取API（Electron Main进程）
2. 创建IPC通道用于文件操作
3. 替换Mock数据为真实文件树
4. 实现文件保存功能

**预期成果**：
- 真实项目文件管理
- 文件内容持久化

---

### 优先级3：扩展Markdown编辑功能 ✍️

**当前状态**：基础编辑和预览

**可选功能**：
1. 文件重命名、移动、删除
2. 新建文件/文件夹
3. 文件搜索
4. 实时协作（多窗口同步）
5. 历史版本管理

---

### 优先级4：性能优化 ⚡

**潜在优化点**：
1. 大文件树的虚拟滚动
2. Vditor懒加载
3. 标签页内容缓存策略
4. 文件变更监听优化

---

### 优先级5：测试覆盖 🧪

**任务**：
1. 单元测试：Store逻辑测试
2. 组件测试：关键组件的渲染测试
3. E2E测试：完整的用户流程测试
4. IPC通信测试

---

## 结语

本次集成工作成功将Obsidian风格的Markdown编辑器原型迁移到Nimbria主应用，实现了：

✅ **多窗口架构**：独立项目窗口，互不干扰  
✅ **模块化设计**：清晰的目录结构和职责划分  
✅ **可复用组件**：Shell设计模式减少代码重复  
✅ **类型安全**：完整的TypeScript类型定义（待完善）  
✅ **样式隔离**：Obsidian主题与Quasar主题共存

通过本次实践，我们总结出了标准化的工作流程，为后续类似功能的开发提供了可参考的模板。

**关键经验**：
1. 🔑 Electron多窗口需要通过 `event.sender` 精确识别调用源
2. 🔑 Flexbox滚动容器需要 `min-height: 0` 和正确的overflow控制
3. 🔑 Vue SFC中的CSS注释应使用 `/* */` 而非 `//`
4. 🔑 原型迁移应优先保留原技术栈和关键布局逻辑
5. 🔑 路径别名能显著提高代码可维护性

---

**文档生成时间**：2025年10月6日  
**下次更新时机**：完成优先级1-2任务后

---

*此文档由Nimbria开发团队生成，基于实际开发过程总结。*

