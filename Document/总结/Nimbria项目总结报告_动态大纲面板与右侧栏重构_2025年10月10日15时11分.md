# Nimbria 项目迭代总结报告：动态大纲面板与右侧栏重构 - 2025年10月10日15时11分

## 1. 本阶段已实现功能

### 1.1. **命令面板功能升级：动态大纲命令**
- **实现了动态命令生成**：命令面板不再只有一个静态的“查看大纲”命令，而是会根据当前所有打开的 Markdown 文件，为每一个文件动态生成一个专属的“查看大纲”命令。
- **提升了用户体验**：用户可以精确地选择任何一个已打开的文件来查看其大纲，解决了之前只能查看第一个文件大纲的限制。

### 1.2. **右侧栏系统重构：支持多实例和 Props**
- **面板多实例**：重构了右侧栏的面板管理系统，现在可以同时存在多个相同类型的面板实例（例如，多个不同文件的大纲面板）。
- **支持 Props 传递**：右侧栏 API (`rightSidebarApi`) 和底层 Vue 组件现在支持通过 `props` 向动态面板传递数据。这是实现面板独立性的关键。
- **面板与数据解耦**：通过 `props` 传递 `tabId`，`OutlinePanel.vue` 组件现在只负责渲染指定 ID 的内容，不再依赖全局的“焦点面板”状态，大大降低了耦合度。

### 1.3. **开发者体验优化：Electron 远程调试**
- **启用远程调试端口**：通过修改 `package.json` 中的启动脚本，为 Electron 的渲染进程成功启用了远程调试端口 (`--remote-debugging-port=9222`)。
- **项目信息标准化**：在 `package.json` 中新增了 `projectInfo` 字段，用于集中记录项目的调试端口、启动说明、技术架构等关键信息，方便团队成员快速上手。

## 2. 核心接口与方法变更

- **`rightSidebarApi`**:
  - `register(panel: RightSidebarPanel)`：`RightSidebarPanel` 类型定义已扩展，支持可选的 `props` 对象，允许在注册时注入数据。
- **`OutlinePanel.vue`**:
  - 组件现在通过 `defineProps<{ tabId: string }>()` 接收一个 `tabId`，并基于此 `prop` 来获取和显示对应的大纲。
- **`outline-panel.plugin.ts`**:
  - 引入核心函数 `ensureOutlinePanelForTab(tabId: string, fileName: string): string`，该函数负责按需创建或查找指定文件的大纲面板，并返回其唯一 ID。
- **`markdown-outline-commands.plugin.ts`**:
  - 插件现在会 `watch` Pinia store (`useMarkdownStore().openTabs`) 的变化，动态地批量注册和注销命令，确保命令列表与打开的文件实时同步。

## 3. 项目习惯与规范总结

- **文件存放目录**:
  - **插件化模块**: 功能插件（如命令、侧栏面板）集中存放在 `Nimbria/Client/Utils/Plugins/` 目录下，并按 `commands` 和 `panels` 细分。
  - **API 服务**: 封装后的高级 API（如 `commandApi`, `rightSidebarApi`）位于 `Nimbria/Client/Service/`，作为视图层和状态管理之间的桥梁。
  - **状态管理 (Pinia)**: Store 模块位于 `Nimbria/Client/stores/`，每个大的功能域（如 `projectPage`）拥有自己的子目录，类型定义通常与 store 文件放在一起（`types.ts`）。
- **核心架构**:
  - **数据驱动 UI**: 采用高度数据驱动的架构模式。UI 元素（如命令列表、侧栏面板）是程序状态（`openTabs` 数组）的直接反映，状态变更时自动更新 UI。
  - **插件注册与发现**: 系统通过插件文件（`*.plugin.ts`）来注册命令和面板，核心系统在启动时加载这些插件，实现了功能的模块化和可扩展性。
  - **依赖注入与解耦**: 通过 `props` 传递依赖（如 `tabId`），而不是让组件自身从全局状态中“猜测”它应该显示什么内容。这是本次重构的核心设计原则。
- **命名习惯**:
  - **面板 ID**: 为了支持多实例，面板 ID 采用 `面板类型-唯一标识符` 的格式，如 `outline-tab-123`。
  - **命令 ID**: 命令 ID 采用 `命名空间.动作.唯一标识符` 的格式，如 `markdown.showOutline.tab-123`，确保了唯一性且易于调试。

## 4. 踩坑与经验总结

- **踩坑记录**:
  1. **静态思维的局限性**: 最初的设计只考虑了“一个大纲面板”，导致后续扩展困难。这是一个典型的设计失误，低估了多文件、多面板场景的复杂性。
  2. **滥用全局状态**: `OutlinePanel.vue` 最初依赖“当前激活的面板”这一全局状态，导致在多面板场景下逻辑混乱。当一个组件的身份和数据依赖于一个可变的外部状态时，往往是潜在 bug 的温床。
  3. **Electron 启动参数的误解**: 曾错误地认为在 `quasar.config.ts` 中配置 `electronArgs` 对开发模式 (`quasar dev`) 生效。实践证明，开发模式下的参数需要直接添加到 `package.json` 的 `dev:electron` 脚本中，并使用 `--` 分隔符传递给 Electron 进程。
- **经验总结**:
  1. **面向数据而非面向UI编程**: 设计功能时，应首先思考需要什么样的数据结构来描述它（例如，一个 `panels` 数组），然后再去实现渲染这个数据结构的 UI。
  2. **Props 是最好的“依赖注入”**: 当组件需要特定数据时，通过 props 明确地传递给它。这让组件变得纯粹、可预测且易于测试。
  3. **封装带来清晰**: 将“为一个文件创建大纲面板”的复杂逻辑封装进 `ensureOutlinePanelForTab` 函数中，使得命令插件的逻辑变得非常简单：`调用函数 -> 切换面板`。良好的封装是控制复杂度的关键。

## 5. 标准化工作流程：为 Electron 配置开发环境

根据本次为 Electron 添加调试端口的经验，总结出以下标准流程：

1.  **需求分析**:
    - 明确需要添加的命令行标志是什么（例如 `--remote-debugging-port=9222`）。
    - 确定这个标志是用于主进程还是渲染进程。
2.  **修改启动脚本**:
    - 打开 `package.json` 文件。
    - 找到 `"dev:electron"` 脚本。
    - 在命令末尾的 `--` 之后添加所需的标志。例如：`... quasar dev -m electron -- --remote-debugging-port=9222`。
3.  **编写文档**:
    - 在 `package.json` 的自定义字段（如 `projectInfo.debugging`）中，添加关于此标志的说明。
    - 内容应包括：端口号、功能描述、以及如何使用它进行调试（例如，“在 Chrome 中打开 `chrome://inspect`”）。
4.  **验证**:
    - 运行 `npm run dev:electron`。
    - 通过应用程序日志或外部工具（如 Chrome 检查器）确认标志已生效且功能正常。

此流程确保了对开发环境的修改是**可追溯、有文档、且易于验证**的。

---
*报告生成时间: 2025年10月10日15时11分*
