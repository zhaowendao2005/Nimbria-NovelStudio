Bossï¼Œéå¸¸å¥½çš„è®¾è®¡æ€è·¯ï¼è®©æˆ‘å¸®æ‚¨æ•´ç†ä¸€ä¸ªå®Œæ•´çš„æ¶æ„æ–¹æ¡ˆã€‚

## ğŸŒŸ StarChart æ˜Ÿå›¾ç³»ç»Ÿ - æ¶æ„è®¾è®¡æ–¹æ¡ˆ

### ğŸ“ æ ¸å¿ƒè®¾è®¡ç†å¿µ

**StarChart ä¸æ˜¯ä¸€ä¸ªå…·ä½“çš„å›¾å¯è§†åŒ–å·¥å…·ï¼Œè€Œæ˜¯ä¸€ä¸ªé¢å‘æµ·é‡ç»“æ„åŒ–æ•°æ®çš„å¯è§†åŒ–æ¸²æŸ“å¼•æ“ï¼Œé€šè¿‡æ’ä»¶åŒ–æ¶æ„é€‚é…ä¸åŒåœºæ™¯ã€‚**

---

## ğŸ—ï¸ ç³»ç»Ÿåˆ†å±‚æ¶æ„

### **ç¬¬ä¸€å±‚ï¼šç³»ç»ŸåŸºå»ºï¼ˆStarChart Coreï¼‰**

è¿™æ˜¯é€šç”¨çš„ã€åœºæ™¯æ— å…³çš„æ ¸å¿ƒå¼•æ“ã€‚

```
StarChart Core/
â”œâ”€â”€ SigmaManager           # Sigma.js ç”Ÿå‘½å‘¨æœŸå°è£…
â”œâ”€â”€ LayerManager           # å¤šå±‚æ¸²æŸ“ç®¡ç†å™¨
â”œâ”€â”€ RenderScheduler        # æŒ‰éœ€æ¸²æŸ“è°ƒåº¦å™¨
â”œâ”€â”€ DataLoader             # å¼‚æ­¥æ•°æ®åŠ è½½å™¨
â”œâ”€â”€ ViewportManager        # è§†å£çŠ¶æ€ç®¡ç†
â”œâ”€â”€ EventBus               # äº‹ä»¶æ€»çº¿
â”œâ”€â”€ PluginRegistry         # æ’ä»¶æ³¨å†Œä¸­å¿ƒ
â””â”€â”€ StateStore             # å›¾çŠ¶æ€ç®¡ç†
```

#### **1.1 SigmaManagerï¼ˆSigma å°è£…å±‚ï¼‰**
**èŒè´£**ï¼š
- ç®¡ç† Sigma å®ä¾‹ç”Ÿå‘½å‘¨æœŸ
- ç»Ÿä¸€çš„åˆå§‹åŒ–/é”€æ¯æ¥å£
- é…ç½®æ ‡å‡†åŒ–
- æä¾› Renderer æŠ½è±¡
- **ä¸ºæ’ä»¶æä¾›æ·±åº¦å®šåˆ¶çš„æ‰©å±•ç‚¹**

**æ ¸å¿ƒæ€è€ƒ**ï¼š
- Sigma.js åªæ˜¯æ¸²æŸ“å¼•æ“ï¼Œä¸åº”è¯¥æš´éœ²ç»™æ’ä»¶
- æ’ä»¶åªéœ€è¦çŸ¥é“"å¦‚ä½•æè¿°æ¸²æŸ“å†…å®¹"ï¼Œä¸éœ€è¦çŸ¥é“"å¦‚ä½•æ¸²æŸ“"
- **Coreå¿…é¡»è¶³å¤Ÿçµæ´»ï¼Œæ”¯æŒæ’ä»¶çš„æ·±åº¦å®šåˆ¶éœ€æ±‚**

**ç±»å‹ç³»ç»Ÿè®¾è®¡**ï¼š
```typescript
// å¯¼å…¥å®˜æ–¹ç±»å‹ä½œä¸ºåŸºç¡€çº¦æŸ
import type { Sigma, Graph } from 'sigma'
import type { Attributes } from 'graphology-types'

// SigmaManager æ ¸å¿ƒæ¥å£
interface SigmaManagerConfig {
  container: HTMLElement
  renderers?: Record<string, NodeProgram | EdgeProgram>
  settings?: Partial<SigmaSettings>
}

// æ’ä»¶æ‰©å±•ç‚¹æ¥å£
interface PluginExtensionAPI {
  // å±‚ç®¡ç†æ‰©å±•ç‚¹
  registerCustomLayer(layerId: string, layer: CustomLayerDefinition): void
  // æ¸²æŸ“å™¨æ‰©å±•ç‚¹  
  registerCustomRenderer(type: 'node' | 'edge', renderer: CustomRenderer): void
  // äº‹ä»¶æ‰©å±•ç‚¹
  registerCustomEventHandler(event: string, handler: EventHandler): void
  // æ•°æ®å¤„ç†æ‰©å±•ç‚¹
  registerDataProcessor(processor: DataProcessor): void
}

// ä¸¥æ ¼çš„è‡ªå®šä¹‰å±‚å®šä¹‰
interface CustomLayerDefinition {
  readonly id: string
  readonly name: string
  readonly zIndex: number
  readonly type: 'webgl' | 'canvas' | 'svg' | 'html'
  render(context: RenderContext): void
  destroy(): void
}
```

**æ‰©å±•ç‚¹æ¶æ„**ï¼š
- **Zoomç³»ç»Ÿç­‰å¤æ‚æ’ä»¶**å¯é€šè¿‡æ‰©å±•ç‚¹æ·±åº¦å®šåˆ¶Coreè¡Œä¸º
- **é€šç”¨æ’ä»¶**åªéœ€ä½¿ç”¨æ ‡å‡†æ¥å£
- **æŒ‰éœ€æ¥å£åŸåˆ™**ï¼šå¤æ‚éœ€æ±‚çš„æ¥å£æŒ‰éœ€æ·»åŠ åˆ°Coreä¸­

---
#### **1.2 LayerManagerï¼ˆå±‚ç®¡ç†å™¨ï¼‰**
**èŒè´£**ï¼š
- ç»Ÿä¸€ç®¡ç† WebGL å±‚å’Œ Canvas å±‚
- æä¾›åˆ†å±‚æ¸²æŸ“æ¥å£
- æ”¯æŒè‡ªå®šä¹‰å±‚æ’å…¥ï¼ˆå…­è¾¹å½¢è¾¹ç•Œã€åˆ†åŒºæ ‡è¯†ï¼‰
- å±‚çº§ä¼˜å…ˆçº§ç®¡ç†

**å…³é”®æœºåˆ¶**ï¼š
```
Layer Stack:
â”œâ”€â”€ Interaction Layer (sigma-mouse)     # æœ€é¡¶å±‚ï¼šäº¤äº’
â”œâ”€â”€ Custom HTML Layer                   # å¯æ’å…¥ï¼šè‡ªå®šä¹‰æ ‡ç­¾ã€æŒ‰é’®
â”œâ”€â”€ Hover Layer (WebGL + Canvas)        # æ‚¬åœé«˜äº®
â”œâ”€â”€ Label Layer (Canvas)                # èŠ‚ç‚¹æ ‡ç­¾
â”œâ”€â”€ Node Layer (WebGL)                  # èŠ‚ç‚¹
â”œâ”€â”€ Edge Layer (WebGL)                  # è¾¹
â””â”€â”€ Background Layer (Canvas/SVG)       # æœ€åº•å±‚ï¼šå…­è¾¹å½¢è¾¹ç•Œã€åˆ†åŒº
```

**æ ¸å¿ƒæ€è€ƒ**ï¼š
- **å…­è¾¹å½¢åˆ†åŒºï¼ˆZoomï¼‰æ¸²æŸ“åœ¨ Background Layer**ï¼Œä½¿ç”¨ Canvas æˆ– SVG
- **èŠ‚ç‚¹/è¾¹çš„æ˜¾éšä¸å½±å“å±‚ç»“æ„**ï¼Œåªå½±å“æ•°æ®ä¼ é€’
- **LOD æ§åˆ¶é€šè¿‡ LayerManager å†³å®šå“ªäº›å±‚å‚ä¸æ¸²æŸ“**

---

#### **1.3 RenderSchedulerï¼ˆæŒ‰éœ€æ¸²æŸ“è°ƒåº¦å™¨ï¼‰**
**èŒè´£**ï¼š
- ç®¡ç†æ¸²æŸ“é˜Ÿåˆ—
- æŒ‰ä¼˜å…ˆçº§è°ƒåº¦æ¸²æŸ“ä»»åŠ¡
- é˜²æ­¢æ¸²æŸ“è¿‡è½½ï¼ˆå¸§ç‡æ§åˆ¶ï¼‰
- æ”¯æŒå¢é‡æ¸²æŸ“
- **ä¸¥æ ¼æ§åˆ¶æ•°æ®è¿›å…¥ï¼Œé¿å…å¤§é‡èŠ‚ç‚¹åŒæ—¶æ¸²æŸ“**

**æ ¸å¿ƒç­–ç•¥**ï¼š
1. **è§†å£è£å‰ª**ï¼šåªæ¸²æŸ“è§†å£å†… + å‘¨è¾¹ç¼“å†²åŒºçš„èŠ‚ç‚¹
2. **æ‰‹åŠ¨LODæ§åˆ¶**ï¼š
   - **å…­è¾¹å½¢è¾¹ç•Œæ¨¡å¼**ï¼šåªæ¸²æŸ“å…­è¾¹å½¢è¾¹ç•Œï¼Œå†…éƒ¨ä¸æ¸²æŸ“ä»»ä½•èŠ‚ç‚¹
   - **å…­è¾¹å½¢å†…éƒ¨æ¨¡å¼**ï¼šæ¸²æŸ“è¾¹ç•Œ + å†…éƒ¨æ‰€æœ‰èŠ‚ç‚¹ï¼ˆæ ¹æ®å±•å¼€çŠ¶æ€ï¼‰
   - **åˆ‡æ¢æ–¹å¼**ï¼šé€šè¿‡å…­è¾¹å½¢è¾¹ç•Œä¸Šçš„æ‰‹åŠ¨æŒ‰é’®æ§åˆ¶
3. **å»¶è¿Ÿæ¸²æŸ“**ï¼šéå…³é”®å†…å®¹ï¼ˆå¦‚æ ‡ç­¾ï¼‰å»¶åæ¸²æŸ“
4. **æ‰¹é‡æ›´æ–°**ï¼šåˆå¹¶å¤šä¸ªæ•°æ®å˜æ›´ä¸ºä¸€æ¬¡æ¸²æŸ“ï¼ˆé˜²æŠ– 16msï¼‰

**å…³é”®æ¦‚å¿µé‡æ–°å®šä¹‰**ï¼š
- **å…­è¾¹å½¢æ¿€æ´»çŠ¶æ€**ï¼šå†³å®šæ˜¯å¦æ¸²æŸ“å†…éƒ¨èŠ‚ç‚¹ï¼ˆæ‰‹åŠ¨æ§åˆ¶ï¼‰
- **èŠ‚ç‚¹å±•å¼€çŠ¶æ€**ï¼šå†³å®šå­èŠ‚ç‚¹çš„æ˜¾ç¤ºï¼ˆç‹¬ç«‹äºå…­è¾¹å½¢æ¿€æ´»ï¼‰
- **æ•°æ®åŠ è½½çŠ¶æ€**ï¼šæ•°æ®æ˜¯å¦åœ¨å†…å­˜ä¸­ï¼ˆä¸¥æ ¼æŒ‰éœ€ï¼‰

**ç±»å‹ç³»ç»Ÿè®¾è®¡**ï¼š
```typescript
// å¯¼å…¥å®˜æ–¹ç±»å‹
import type { Settings } from 'sigma/settings'

// æ¸²æŸ“çŠ¶æ€ä¸¥æ ¼ç±»å‹å®šä¹‰
interface RenderState {
  // å…­è¾¹å½¢æ¿€æ´»çŠ¶æ€ï¼ˆæ‰‹åŠ¨æ§åˆ¶ï¼‰
  readonly zoomActivatedRegions: Set<string>  // æ¿€æ´»çš„å…­è¾¹å½¢IDé›†åˆ
  // èŠ‚ç‚¹å±•å¼€çŠ¶æ€ï¼ˆç‹¬ç«‹æ§åˆ¶ï¼‰
  readonly expandedNodes: Set<string>         // å±•å¼€çš„èŠ‚ç‚¹IDé›†åˆ
  // è§†å£çŠ¶æ€
  readonly viewport: {
    readonly center: { readonly x: number; readonly y: number }
    readonly zoom: number
    readonly visibleBounds: BoundingBox
  }
}

// æ¸²æŸ“è°ƒåº¦é…ç½®
interface RenderSchedulerConfig {
  readonly maxNodesPerFrame: number          // æ¯å¸§æœ€å¤§èŠ‚ç‚¹æ•°ï¼ˆä¸¥æ ¼é™åˆ¶ï¼‰
  readonly renderBatchSize: number           // æ‰¹é‡æ¸²æŸ“å¤§å°
  readonly frameRateLimit: number            // å¸§ç‡é™åˆ¶
  readonly enableViewportCulling: boolean    // è§†å£è£å‰ªå¼€å…³
}

// è¾¹ç•Œæ¡†ç±»å‹
interface BoundingBox {
  readonly minX: number
  readonly maxX: number  
  readonly minY: number
  readonly maxY: number
}

// æ‰¹é‡æ›´æ–°ç®¡ç†
class BatchUpdateManager {
  private pendingUpdates: Map<string, NodeDisplayData> = new Map()
  private updateScheduled = false
  private readonly batchDelay = 16  // ä¸€å¸§çš„æ—¶é—´ï¼ˆ60fpsï¼‰
  
  queueNodeUpdate(nodeId: string, update: Partial<NodeDisplayData>): void {
    const existing = this.pendingUpdates.get(nodeId)
    this.pendingUpdates.set(nodeId, {
      ...existing,
      ...update
    })
    this.scheduleBatchUpdate()
  }
  
  private scheduleBatchUpdate(): void {
    if (this.updateScheduled) return
    this.updateScheduled = true
    
    requestAnimationFrame(() => {
      this.flushUpdates()
      this.updateScheduled = false
    })
  }
}
```

**æ¸²æŸ“å†³ç­–é€»è¾‘**ï¼š
1. **å…­è¾¹å½¢æœªæ¿€æ´»**ï¼šåªæ¸²æŸ“è¾¹ç•Œï¼Œå†…éƒ¨èŠ‚ç‚¹å®Œå…¨ä¸ä¼ ç»™Sigma
2. **å…­è¾¹å½¢å·²æ¿€æ´»**ï¼šæ¸²æŸ“è¾¹ç•Œ + å†…éƒ¨èŠ‚ç‚¹ï¼ˆæŒ‰å±•å¼€çŠ¶æ€ï¼‰
3. **èŠ‚ç‚¹å±•å¼€ç‹¬ç«‹**ï¼šåœ¨æ¿€æ´»çš„å…­è¾¹å½¢å†…ï¼Œå±•å¼€çš„èŠ‚ç‚¹æ˜¾ç¤ºå­èŠ‚ç‚¹ï¼Œæœªå±•å¼€çš„ä¸æ˜¾ç¤º
4. **å¢é‡æ¸²æŸ“**ï¼šä»…æ›´æ–°å˜æ›´èŠ‚ç‚¹ï¼Œä½¿ç”¨æ‰¹é‡æ›´æ–°é˜²æŠ–æœºåˆ¶

---

#### **1.4 DataLoaderï¼ˆå¼‚æ­¥æ•°æ®åŠ è½½å™¨ï¼‰**
**èŒè´£**ï¼š
- æŒ‰éœ€åŠ è½½å›¾æ•°æ®
- æ”¯æŒåˆ†å—åŠ è½½ï¼ˆChunk-basedï¼‰
- æ•°æ®é¢„å–ç­–ç•¥
- æ”¯æŒå¤šç§æ•°æ®æºï¼ˆJSONã€Gunã€SQLiteï¼‰

**åŠ è½½ç­–ç•¥**ï¼š
```
æ•°æ®åŠ è½½ä¸‰çº§ç»“æ„ï¼š
â”œâ”€â”€ Hot Data (å†…å­˜)      # å½“å‰è§†å£ + å·²å±•å¼€èŠ‚ç‚¹
â”œâ”€â”€ Warm Data (ç¼“å­˜)     # ç›¸é‚»èŠ‚ç‚¹ã€é¢„åŠ è½½æ•°æ®
â””â”€â”€ Cold Data (å­˜å‚¨)     # æ•°æ®åº“/æ–‡ä»¶ç³»ç»Ÿ
```

**å…³é”®æ€è€ƒ**ï¼š
- **å¼‚æ­¥åŠ è½½ä¸é˜»å¡ UI**ï¼šä½¿ç”¨ Web Worker å¤„ç†æ•°æ®è½¬æ¢
- **æ•°æ®åˆ†å—ç­–ç•¥**ï¼š
  - æŒ‰ Zoom åˆ†å—ï¼ˆæ¨¡ç»„ç»´åº¦ï¼‰
  - æŒ‰å±‚çº§åˆ†å—ï¼ˆçˆ¶å­å…³ç³»ï¼‰
  - æŒ‰è§†å£åˆ†å—ï¼ˆç©ºé—´ç»´åº¦ï¼‰
- **é¢„åŠ è½½ç­–ç•¥**ï¼š
  - å±•å¼€èŠ‚ç‚¹æ—¶ï¼Œé¢„åŠ è½½å…¶å­èŠ‚ç‚¹çš„å…„å¼ŸèŠ‚ç‚¹
  - ç§»åŠ¨è§†å£æ—¶ï¼Œé¢„åŠ è½½æ–¹å‘å‰æ–¹çš„æ•°æ®

---

#### **1.5 ViewportManagerï¼ˆè§†å£ç®¡ç†å™¨ï¼‰**
**èŒè´£**ï¼š
- ç®¡ç†ç¼©æ”¾ã€å¹³ç§»çŠ¶æ€
- è®¡ç®—å¯è§åŒºåŸŸ
- **æä¾›è§†å£ä¿¡æ¯ç»™æ‰‹åŠ¨LODæ§åˆ¶ç³»ç»Ÿ**
- æ€§èƒ½ç›‘æ§ï¼ˆFPSï¼‰
- è§†å£è£å‰ªè®¡ç®—

**æ‰‹åŠ¨LODæ”¯æŒæœºåˆ¶**ï¼š
```typescript
// ViewportManager ä¸è§¦å‘è‡ªåŠ¨LODï¼Œåªæä¾›ä¿¡æ¯
interface ViewportInfo {
  readonly currentZoom: number
  readonly center: { readonly x: number; readonly y: number }
  readonly visibleBounds: BoundingBox
  readonly visibleRegions: string[]  // å½“å‰è§†å£å†…çš„å…­è¾¹å½¢IDåˆ—è¡¨
}
```

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
1. **è§†å£çŠ¶æ€ç®¡ç†**ï¼šè·Ÿè¸ªç”¨æˆ·çš„ç¼©æ”¾ã€å¹³ç§»æ“ä½œ
2. **å¯è§åŒºåŸŸè®¡ç®—**ï¼šè®¡ç®—å½“å‰è§†å£è¦†ç›–å“ªäº›å…­è¾¹å½¢åŒºåŸŸ
3. **æ€§èƒ½ç›‘æ§**ï¼šç›‘æ§FPSï¼Œä¸ºæ¸²æŸ“è°ƒåº¦æä¾›æ€§èƒ½æ•°æ®
4. **è§†å£è£å‰ªæ”¯æŒ**ï¼šä¸ºRenderScheduleræä¾›è£å‰ªè¾¹ç•Œ

**ç±»å‹ç³»ç»Ÿè®¾è®¡**ï¼š
```typescript
// å¯¼å…¥å®˜æ–¹ç±»å‹
import type { Camera } from 'sigma/types'

// è§†å£ç®¡ç†å™¨é…ç½®
interface ViewportManagerConfig {
  readonly minZoom: number
  readonly maxZoom: number
  readonly enableInertia: boolean
  readonly cullingMargin: number  // è§†å£è£å‰ªè¾¹è·
}

// è§†å£å˜åŒ–äº‹ä»¶
interface ViewportChangeEvent {
  readonly type: 'zoom' | 'pan' | 'resize'
  readonly viewport: ViewportInfo
  readonly visibleRegions: ReadonlySet<string>
}
```

**ä¸LODç³»ç»Ÿçš„å…³ç³»**ï¼š
- ViewportManager **ä¸ä¼š**è‡ªåŠ¨è§¦å‘LODåˆ‡æ¢
- ViewportManager **åªæä¾›**è§†å£ä¿¡æ¯ç»™æ’ä»¶ä½¿ç”¨
- LODåˆ‡æ¢å®Œå…¨ç”±**ç”¨æˆ·æ‰‹åŠ¨æ“ä½œ**ï¼ˆå…­è¾¹å½¢æŒ‰é’®ï¼‰å†³å®š
---

#### **1.6 EventBusï¼ˆäº‹ä»¶æ€»çº¿ï¼‰**
**èŒè´£**ï¼š
- æ’ä»¶é—´é€šä¿¡
- ç³»ç»Ÿäº‹ä»¶åˆ†å‘
- æ”¯æŒäº‹ä»¶ä¼˜å…ˆçº§
- **ä¸¥æ ¼æ§åˆ¶æ•°æ®æµï¼Œç¡®ä¿æŒ‰éœ€åŠ è½½**

**æ ¸å¿ƒäº‹ä»¶ï¼ˆä¸¥æ ¼ç±»å‹å®šä¹‰ï¼‰**ï¼š
```typescript
// å¯¼å…¥å®˜æ–¹äº‹ä»¶ç±»å‹
import type { SigmaEventPayload } from 'sigma/types'

// æ¸²æŸ“äº‹ä»¶
interface RenderEvents {
  'render:beforeRender': { nodeCount: number; regionId?: string }
  'render:afterRender': { renderTime: number; nodeCount: number }
  'render:nodeCountExceeded': { attemptedCount: number; maxAllowed: number }
}

// äº¤äº’äº‹ä»¶ï¼ˆåŒºåˆ†å…­è¾¹å½¢æ¿€æ´»å’ŒèŠ‚ç‚¹å±•å¼€ï¼‰
interface InteractionEvents {
  'node:click': { nodeId: string; position: { x: number; y: number } }
  'node:doubleClick': { nodeId: string }
  'node:expand': { nodeId: string; childrenIds: string[] }      // å±•å¼€å­èŠ‚ç‚¹ï¼ˆæ•°æ®å·²å‡†å¤‡ï¼‰
  'node:collapse': { nodeId: string; childrenIds: string[] }   // æ”¶èµ·å­èŠ‚ç‚¹ï¼ˆç«‹å³ç§»é™¤æ•°æ®ï¼‰
  'region:activate': { regionId: string; nodeIds: string[] }   // æ¿€æ´»å…­è¾¹å½¢ï¼ˆæ•°æ®å·²å‡†å¤‡ï¼‰
  'region:deactivate': { regionId: string; nodeIds: string[] } // å…³é—­å…­è¾¹å½¢ï¼ˆç«‹å³ç§»é™¤æ•°æ®ï¼‰
}

// ä¸¥æ ¼çš„æ•°æ®äº‹ä»¶ï¼ˆæ€§èƒ½ä¿è¯ï¼‰
interface DataEvents {
  'data:childrenPrepared': { parentId: string; children: NodeData[] }      // å­èŠ‚ç‚¹æ•°æ®å·²å‡†å¤‡å¥½
  'data:regionPrepared': { regionId: string; nodes: NodeData[] }           // åŒºåŸŸæ•°æ®å·²å‡†å¤‡å¥½
  'data:nodeRemoved': { nodeIds: string[] }                                // èŠ‚ç‚¹å·²ä»å†…å­˜ç§»é™¤
  'data:loadingStarted': { type: 'children' | 'region'; targetId: string } // å¼€å§‹åŠ è½½ï¼ˆç¦æ­¢é‡å¤è§¦å‘ï¼‰
  'data:loadingCompleted': { type: 'children' | 'region'; targetId: string }
}
```

**ä¸¥æ ¼çš„æ€§èƒ½ä¿è¯æœºåˆ¶**ï¼š

**1. æ•°æ®é¢„å‡†å¤‡åŸåˆ™**ï¼š
- **å±•å¼€èŠ‚ç‚¹å‰**ï¼šå­èŠ‚ç‚¹æ•°æ®å¿…é¡»å·²åœ¨å†…å­˜ä¸­ï¼ˆ`data:childrenPrepared`ï¼‰
- **æ¿€æ´»å…­è¾¹å½¢å‰**ï¼šåŒºåŸŸæ•°æ®å¿…é¡»å·²åœ¨å†…å­˜ä¸­ï¼ˆ`data:regionPrepared`ï¼‰
- **ç”¨æˆ·ç‚¹å‡»æ—¶**ï¼šç»å¯¹ä¸å…è®¸ç­‰å¾…æ•°æ®åŠ è½½æˆ–è½¬æ¢

**2. æ•°æ®é‡ä¸¥æ ¼é™åˆ¶**ï¼š
```typescript
interface DataConstraints {
  readonly MAX_NODES_PER_INTERACTION: 500    // å•æ¬¡äº¤äº’æœ€å¤§èŠ‚ç‚¹æ•°
  readonly MAX_CHILDREN_PER_NODE: 50         // å•ä¸ªèŠ‚ç‚¹æœ€å¤§å­èŠ‚ç‚¹æ•°
  readonly MAX_NODES_PER_REGION: 2000        // å•ä¸ªå…­è¾¹å½¢æœ€å¤§èŠ‚ç‚¹æ•°
  readonly PRELOAD_BATCH_SIZE: 100           // é¢„åŠ è½½æ‰¹æ¬¡å¤§å°
}
```

**3. ç«‹å³å“åº”ä¿è¯**ï¼š
- ç”¨æˆ·äº¤äº’ â†’ æ•°æ®å·²å‡†å¤‡ â†’ ç«‹å³æ¸²æŸ“ï¼ˆ< 16msï¼‰
- ä¸¥ç¦ï¼šç”¨æˆ·äº¤äº’ â†’ æ•°æ®åŠ è½½ â†’ æ•°æ®è½¬æ¢ â†’ æ¸²æŸ“
- æ‰€æœ‰æ•°æ®åŠ è½½éƒ½åœ¨**åå°é¢„è¿›è¡Œ**ï¼Œä¸é˜»å¡ç”¨æˆ·æ“ä½œ

**4. å†…å­˜ç®¡ç†**ï¼š
- èŠ‚ç‚¹æ”¶èµ·æ—¶ï¼Œå­èŠ‚ç‚¹æ•°æ®**ç«‹å³ä»å†…å­˜ç§»é™¤**
- å…­è¾¹å½¢å…³é—­æ—¶ï¼Œå†…éƒ¨èŠ‚ç‚¹æ•°æ®**ç«‹å³ä»å†…å­˜ç§»é™¤**
- ä¿æŒå†…å­˜ä¸­èŠ‚ç‚¹æ•°é‡åœ¨åˆç†èŒƒå›´å†…ï¼ˆ< 5000ä¸ªæ´»è·ƒèŠ‚ç‚¹ï¼‰

---

#### **1.7 PluginRegistryï¼ˆæ’ä»¶æ³¨å†Œä¸­å¿ƒï¼‰**
**èŒè´£**ï¼š
- æ’ä»¶ç”Ÿå‘½å‘¨æœŸç®¡ç†
- æ’ä»¶ä¾èµ–è§£æ
- æ’ä»¶éš”ç¦»

**æ’ä»¶æ¥å£ï¼ˆä¸¥æ ¼ç±»å‹å®šä¹‰ï¼‰**ï¼š
```typescript
// å¯¼å…¥å®˜æ–¹ç±»å‹ä½œä¸ºåŸºç¡€çº¦æŸ
import type { Settings } from 'sigma/settings'
import type { NodeDisplayData, EdgeDisplayData } from 'sigma/types'

// æ’ä»¶åŸºç¡€æ¥å£
interface StarChartPlugin {
  readonly id: string
  readonly name: string
  readonly version: string
  readonly description?: string
  
  // ç”Ÿå‘½å‘¨æœŸé’©å­ï¼ˆä¸¥æ ¼ç±»å‹ï¼‰
  install(core: StarChartCore): Promise<void> | void
  uninstall(): Promise<void> | void
  
  // å¯é€‰ï¼šæ’ä»¶ä¾èµ–ï¼ˆä¸¥æ ¼ç‰ˆæœ¬æ§åˆ¶ï¼‰
  readonly dependencies?: ReadonlyArray<{
    readonly pluginId: string
    readonly minVersion: string
    readonly maxVersion?: string
  }>
  
  // æ’ä»¶é…ç½®ï¼ˆä¸¥ç¦anyï¼‰
  readonly config?: Readonly<Record<string, string | number | boolean>>
}

// æ‰©å±•çš„æ’ä»¶ç±»å‹
interface LayoutPlugin extends StarChartPlugin {
  readonly type: 'layout'
  computeLayout(
    nodes: ReadonlyArray<NodeDisplayData>, 
    edges: ReadonlyArray<EdgeDisplayData>
  ): Promise<LayoutResult>
  updateLayout(changedNodes: ReadonlyArray<string>): Promise<void>
  readonly layoutConfig: Readonly<LayoutConfig>
}

interface RenderPlugin extends StarChartPlugin {
  readonly type: 'renderer'
  readonly renderLayers: ReadonlyArray<'webgl' | 'canvas' | 'svg' | 'html'>
  render(context: RenderContext): Promise<void>
  readonly renderConfig: Readonly<RenderConfig>
}

interface InteractionPlugin extends StarChartPlugin {
  readonly type: 'interaction'
  readonly handledEvents: ReadonlyArray<string>
  handleEvent(event: StarChartEvent): Promise<boolean>  // è¿”å›æ˜¯å¦é˜»æ­¢äº‹ä»¶å†’æ³¡
  readonly interactionConfig: Readonly<InteractionConfig>
}

// é…ç½®ç±»å‹ä¸¥æ ¼å®šä¹‰
interface LayoutConfig {
  readonly algorithm: 'force' | 'hierarchy' | 'grid' | 'custom'
  readonly nodeSpacing: number
  readonly edgeLength: number
  readonly iterations: number
  readonly enableClustering: boolean
}

interface RenderConfig {
  readonly maxNodesPerLayer: number
  readonly enableWebGL: boolean
  readonly enableCanvas: boolean
  readonly antiAliasing: boolean
}

interface InteractionConfig {
  readonly enableNodeDrag: boolean
  readonly enableZoom: boolean
  readonly enablePan: boolean
  readonly doubleClickDelay: number
}
```

---

### **ç¬¬äºŒå±‚ï¼šæ’ä»¶å±‚ï¼ˆPluginsï¼‰**

è¿™æ˜¯åœºæ™¯ç›¸å…³çš„ã€å¯æ’æ‹”çš„åŠŸèƒ½æ¨¡å—ã€‚

```
StarChart Plugins/
â”œâ”€â”€ Layout Plugins/            # å¸ƒå±€æ’ä»¶
â”‚   â”œâ”€â”€ HierarchyLayout        # å±‚çº§æ ‘å¸ƒå±€ï¼ˆçˆ¶å­å…³ç³»ï¼‰
â”‚   â”œâ”€â”€ ForceDirectedLayout    # åŠ›å¯¼å‘å¸ƒå±€
â”‚   â””â”€â”€ RecipeGraphLayout      # é…æ–¹å›¾ä¸“ç”¨å¸ƒå±€
â”‚
â”œâ”€â”€ Interaction Plugins/       # äº¤äº’æ’ä»¶
â”‚   â”œâ”€â”€ ExpandCollapsePlugin   # å±•å¼€/æ”¶èµ·
â”‚   â”œâ”€â”€ ZoomControlPlugin      # å…­è¾¹å½¢æ¿€æ´»æ§åˆ¶
â”‚   â””â”€â”€ DragNavigationPlugin   # æ‹–æ‹½å¯¼èˆª
â”‚
â”œâ”€â”€ Renderer Plugins/          # æ¸²æŸ“æ’ä»¶
â”‚   â”œâ”€â”€ NodeStylePlugin        # èŠ‚ç‚¹æ ·å¼ï¼ˆè¾¹æ¡†ã€é¢œè‰²ï¼‰
â”‚   â”œâ”€â”€ EdgeStylePlugin        # è¾¹æ ·å¼ï¼ˆå¹³å°æ ‡è¯†ï¼‰
â”‚   â””â”€â”€ LabelPlugin            # æ ‡ç­¾æ¸²æŸ“
â”‚
â”œâ”€â”€ LOD Plugins/               # LODæ’ä»¶
â”‚   â”œâ”€â”€ ZoomBoundaryPlugin     # å…­è¾¹å½¢è¾¹ç•Œæ¸²æŸ“
â”‚   â”œâ”€â”€ LayeredRenderPlugin    # åˆ†å±‚æ¸²æŸ“æ§åˆ¶
â”‚   â””â”€â”€ DynamicVisibilityPlugin # åŠ¨æ€æ˜¾éš
â”‚
â””â”€â”€ Data Adapter Plugins/      # æ•°æ®é€‚é…å™¨
    â”œâ”€â”€ RecipeDataAdapter      # é…æ–¹æ•°æ®é€‚é…
    â”œâ”€â”€ NovelDataAdapter       # å°è¯´è®¾å®šé€‚é…
    â””â”€â”€ GenericGraphAdapter    # é€šç”¨å›¾æ•°æ®é€‚é…
```

---

## ğŸ¯ é’ˆå¯¹æ‚¨åœºæ™¯çš„å…·ä½“æ–¹æ¡ˆ

### **åœºæ™¯ä¸€ï¼šMC é…æ–¹å›¾ï¼ˆ30000+ èŠ‚ç‚¹ï¼‰**

#### **æ’ä»¶ç»„åˆ**ï¼š
```
RecipeGraphLayout           # å¸ƒå±€ç®—æ³•
+ ExpandCollapsePlugin      # å±•å¼€/æ”¶èµ·äº¤äº’
+ ZoomBoundaryPlugin        # ä¹åå¤šä¸ªæ¨¡ç»„çš„å…­è¾¹å½¢è¾¹ç•Œ
+ RecipeDataAdapter         # é…æ–¹æ•°æ®é€‚é…
+ EdgeStylePlugin           # è¾¹ä¸Šæ˜¾ç¤ºåˆæˆå¹³å°
```

#### **æ•°æ®ç»“æ„è®¾è®¡**ï¼š

```typescript
// æ•°æ®åˆ†å—ç­–ç•¥
interface RecipeGraphData {
  // æ¨¡ç»„çº§åˆ«ï¼ˆZoom åˆ†åŒºï¼‰
  mods: ModData[]
  
  // å…¨å±€æ‹“æ‰‘ä¿¡æ¯ï¼ˆç”¨äºå¿«é€ŸæŸ¥è¯¢ï¼‰
  topology: {
    topLevel: string[]      // é¡¶å±‚ç‰©å“ID
    bottomLevel: string[]   // åº•å±‚ç‰©å“ID
    loops: string[][]       // å¾ªç¯é…æ–¹ç»„
  }
}

interface ModData {
  id: string              // æ¨¡ç»„ID
  name: string
  boundary: HexagonShape  // å…­è¾¹å½¢è¾¹ç•Œä¿¡æ¯
  
  // åˆ†å±‚æ•°æ®ï¼ˆæŒ‰éœ€åŠ è½½ï¼‰
  nodes: {
    internal: RecipeNode[]     // æ¨¡ç»„å†…éƒ¨èŠ‚ç‚¹
    boundary: RecipeNode[]     // è¾¹ç•ŒèŠ‚ç‚¹
  }
  edges: RecipeEdge[]
  
  // æ˜¯å¦å·²æ¿€æ´»æ¸²æŸ“
  activated: boolean
}

// ä¸¥æ ¼ç±»å‹å®šä¹‰ï¼Œå¯¼å…¥å®˜æ–¹çº¦æŸ
interface RecipeNode {
  readonly id: string
  readonly name: string
  readonly type: 'top' | 'bottom' | 'loop' | 'regular'  // æ”¹ä¸º regularï¼ˆå¸¸è§„/ä¸­é—´èŠ‚ç‚¹ï¼‰
  readonly hasChildren: boolean      // æ˜¯å¦æœ‰å­èŠ‚ç‚¹ï¼ˆå†³å®šæ˜¯å¦æ˜¾ç¤ºè¾¹æ¡†æ ·å¼ï¼‰
  readonly expanded: boolean         // å½“å‰å±•å¼€çŠ¶æ€ï¼ˆç‹¬ç«‹äºhasChildrenï¼‰
  readonly children?: ReadonlyArray<string>  // å­èŠ‚ç‚¹IDï¼ˆæ‡’åŠ è½½ï¼‰
  readonly position?: { readonly x: number; readonly y: number }  // èŠ‚ç‚¹ä½ç½®
  readonly metadata?: Readonly<Record<string, unknown>>          // é¢å¤–å…ƒæ•°æ®ï¼ˆä¸¥ç¦anyï¼‰
}

/**
 * èŠ‚ç‚¹ç±»å‹è¯´æ˜ï¼š
 * - **topï¼ˆé¡¶å±‚ï¼‰**ï¼šæ²¡æœ‰çˆ¶èŠ‚ç‚¹çš„é…æ–¹ï¼Œæ˜¯åˆæˆæ ‘çš„èµ·ç‚¹
 * - **bottomï¼ˆåº•å±‚ï¼‰**ï¼šæ²¡æœ‰å­èŠ‚ç‚¹çš„é…æ–¹ï¼Œé€šå¸¸æ˜¯åŸææ–™
 * - **loopï¼ˆå¾ªç¯ï¼‰**ï¼šå‚ä¸å¾ªç¯é…æ–¹çš„èŠ‚ç‚¹ï¼Œ**ä¸éœ€è¦å±•å¼€åŠŸèƒ½**ï¼Œåˆå§‹å°±å…¨éƒ¨æ˜¾ç¤ºåœ¨æ¤­åœ†ä¸Š
 *   - å¾ªç¯èŠ‚ç‚¹ä¸æ”¯æŒå±•å¼€/æ”¶èµ·
 *   - åˆå§‹å¸ƒå±€æ—¶æ”¾åœ¨éšæœºæ¤­åœ†ä¸Šï¼ˆæ¤­åœ†å‚æ•°éšæœºï¼šradiusX 100-180, radiusY 80-140ï¼‰
 *   - æ”¾åœ¨ç©ºæ—·åŒºåŸŸï¼Œä¸é¡¶å±‚/å¸¸è§„èŠ‚ç‚¹ä¿æŒç¨€ç–è·ç¦»
 * - **regularï¼ˆå¸¸è§„ï¼‰**ï¼šæ—¢æœ‰çˆ¶ä¹Ÿæœ‰å­çš„ä¸­é—´é…æ–¹èŠ‚ç‚¹ï¼Œæ”¯æŒå±•å¼€/æ”¶èµ·
 *
 * expanded å­—æ®µè¯´æ˜ï¼š
 * - ç‹¬ç«‹äº hasChildrenï¼Œæ˜ç¡®è¡¨è¾¾å½“å‰å±•å¼€çŠ¶æ€
 * - hasChildren=true ä½† expanded=falseï¼šæœ‰èƒ½åŠ›å±•å¼€ä½†æœªå±•å¼€
 * - expanded=trueï¼šå½“å‰å·²å±•å¼€ï¼Œå­èŠ‚ç‚¹åœ¨å†…å­˜ä¸­å¹¶å¯è§
 */

// è¾¹æ•°æ®ä¸¥æ ¼ç±»å‹å®šä¹‰
interface RecipeEdge {
  readonly id: string
  readonly source: string
  readonly target: string
  readonly platform: string           // åˆæˆå¹³å°IDï¼ˆæ•°æ®å­˜å‚¨ï¼‰
  readonly weight: number
  readonly platformLabel?: string     // å¹³å°æ˜¾ç¤ºåç§°ï¼ˆæŒ‰éœ€æ¸²æŸ“ï¼Œæ‚¬æµ®æ—¶è·å–ï¼‰
  readonly labelVisible: boolean      // æ ‡ç­¾æ˜¯å¦å¯è§ï¼ˆæ‰‹åŠ¨æ§åˆ¶ï¼‰
  readonly metadata?: Readonly<Record<string, unknown>>  // é¢å¤–å…ƒæ•°æ®ï¼ˆä¸¥ç¦anyï¼‰
}

// è¾¹æ ‡ç­¾æŒ‰éœ€æ¸²æŸ“é…ç½®
interface EdgeLabelConfig {
  readonly enableHoverLabels: boolean    // æ‚¬æµ®æ˜¾ç¤ºæ ‡ç­¾
  readonly enableClickLabels: boolean    // ç‚¹å‡»æ˜¾ç¤ºæ ‡ç­¾
  readonly labelFetchDelay: number       // æ ‡ç­¾è·å–å»¶è¿Ÿï¼ˆmsï¼‰
  readonly maxVisibleLabels: number      // æœ€å¤§å¯è§æ ‡ç­¾æ•°
}
```

#### **æ¸²æŸ“ç­–ç•¥**ï¼š

**Level 0ï¼ˆzoom < 0.5ï¼‰**ï¼š
- åªæ¸²æŸ“ 90 ä¸ªå…­è¾¹å½¢è¾¹ç•Œ
- æ¯ä¸ªå…­è¾¹å½¢ä¸­å¿ƒæ˜¾ç¤ºæ¨¡ç»„åç§°
- æ¸²æŸ“è·¨æ¨¡ç»„çš„è¿çº¿ï¼ˆé«˜å±‚æŠ½è±¡ï¼‰

**Level 1ï¼ˆ0.5 â‰¤ zoom < 1ï¼‰**ï¼š
- æ¸²æŸ“å…­è¾¹å½¢è¾¹ç•Œ
- æ¸²æŸ“é¡¶å±‚ç‰©å“èŠ‚ç‚¹ï¼ˆæ— çˆ¶èŠ‚ç‚¹ï¼‰
- æ¸²æŸ“å¾ªç¯é…æ–¹ç»„ï¼ˆé—­ç¯ï¼‰
- **åº•å±‚ç‰©å“ä¸æ¸²æŸ“**
- æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹æ˜¾ç¤ºç‰¹æ®Šè¾¹æ¡†æ ·å¼

**Level 2ï¼ˆzoom â‰¥ 1ï¼Œå…­è¾¹å½¢æœªæ¿€æ´»ï¼‰**ï¼š
- ä¿æŒ Level 1 çš„æ¸²æŸ“
- æ”¯æŒåŒå‡»èŠ‚ç‚¹å±•å¼€å­èŠ‚ç‚¹
- å±•å¼€çš„å­èŠ‚ç‚¹ä½¿ç”¨åŠ›å¯¼å‘å¸ƒå±€é¿å…å åŠ 

**Level 3ï¼ˆå…­è¾¹å½¢å·²æ¿€æ´»ï¼‰**ï¼š
- æ¿€æ´»åï¼Œæ¸²æŸ“å…­è¾¹å½¢å†…éƒ¨çš„æ‰€æœ‰èŠ‚ç‚¹
- ä½¿ç”¨ç‹¬ç«‹çš„å¸ƒå±€ç®—æ³•ï¼ˆå†…éƒ¨å¸ƒå±€ï¼‰
- è¾¹ä¸Šæ˜¾ç¤ºåˆæˆå¹³å°å›¾æ ‡

---


### **å±•å¼€/æ”¶èµ·äº¤äº’**ï¼š

**æ–¹æ¡ˆ Aï¼šåŒå‡»èŠ‚ç‚¹**
- ä¼˜ç‚¹ï¼šç®€å•ç›´è§‚
- ç¼ºç‚¹ï¼šå¯èƒ½ä¸å…¶ä»–äº¤äº’å†²çª

**æ–¹æ¡ˆ Bï¼šèŠ‚ç‚¹æ—è¾¹çš„æŒ‰é’®**
- ä¼˜ç‚¹ï¼šæ˜ç¡®å¯è§
- ç¼ºç‚¹ï¼šå¢åŠ æ¸²æŸ“è´Ÿæ‹…

**æ¨èæ··åˆæ–¹æ¡ˆ**ï¼š
- **é»˜è®¤**ï¼šåŒå‡»å±•å¼€/æ”¶èµ·
- **Hover æ—¶**ï¼šæ˜¾ç¤º `[+]` / `[-]` æŒ‰é’®ï¼ˆCanvas Layerï¼‰
- **æ€§èƒ½æ¨¡å¼**ï¼šä»…åŒå‡»ï¼ˆä¸æ˜¾ç¤ºæŒ‰é’®ï¼‰

---

### **å…­è¾¹å½¢æ¿€æ´»äº¤äº’**ï¼š

**æ–¹æ¡ˆ Aï¼šå›ºå®šæŒ‰é’®ï¼ˆå¼€å‘è°ƒè¯•ï¼‰**
- é¡¶éƒ¨å·¥å…·æ ï¼š"æ¿€æ´»æ‰€æœ‰æ¨¡ç»„"æŒ‰é’®

**æ–¹æ¡ˆ Bï¼šå…‰åœˆåŠ¨ç”»ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰**
- é¼ æ ‡ç§»å…¥å…­è¾¹å½¢ï¼šå‘å¤–æ‰©æ•£çš„å…‰åœˆ
- é¼ æ ‡ç§»å‡ºï¼šå‘å†…æ”¶ç¼©çš„å…‰åœˆ
- ç‚¹å‡»ï¼šåˆ‡æ¢æ¿€æ´»çŠ¶æ€

---

## ğŸ“Š æ€»ç»“ï¼šç³»ç»Ÿä¸æ’ä»¶çš„è¾¹ç•Œ

### **ç³»ç»ŸåŸºå»ºï¼ˆStarChart Coreï¼‰è´Ÿè´£**ï¼š
âœ… **Sigma.js å°è£…** - æä¾›ç»Ÿä¸€çš„æ¸²æŸ“å¼•æ“æ¥å£
âœ… **å±‚ç®¡ç†** - WebGL/Canvas/SVG/HTML å±‚çš„ç»Ÿä¸€ç®¡ç†
âœ… **æŒ‰éœ€æ¸²æŸ“è°ƒåº¦** - ä¸¥æ ¼çš„æ€§èƒ½æ§åˆ¶å’Œæ¸²æŸ“é˜Ÿåˆ—ç®¡ç†
âœ… **å¼‚æ­¥æ•°æ®åŠ è½½** - æ•°æ®é¢„å‡†å¤‡å’Œå†…å­˜ç®¡ç†
âœ… **äº‹ä»¶æ€»çº¿** - ä¸¥æ ¼ç±»å‹çš„æ’ä»¶é—´é€šä¿¡
âœ… **æ’ä»¶æ³¨å†Œ** - æ’ä»¶ç”Ÿå‘½å‘¨æœŸå’Œä¾èµ–ç®¡ç†
âœ… **çŠ¶æ€ç®¡ç†** - å…¨å±€çŠ¶æ€å’Œè§†å£çŠ¶æ€ç®¡ç†
âœ… **æ‰©å±•ç‚¹API** - ä¸ºå¤æ‚æ’ä»¶æä¾›æ·±åº¦å®šåˆ¶æ¥å£
âœ… **ç±»å‹çº¦æŸ** - å¯¼å…¥å®˜æ–¹ç±»å‹ï¼Œä¸¥ç¦anyç±»å‹

### **æ’ä»¶è´Ÿè´£**ï¼š
âœ… **å¸ƒå±€ç®—æ³•** - å…·ä½“çš„èŠ‚ç‚¹ä½ç½®è®¡ç®—é€»è¾‘
âœ… **äº¤äº’é€»è¾‘** - èŠ‚ç‚¹å±•å¼€/æ”¶èµ·ã€å…­è¾¹å½¢æ¿€æ´»ç­‰ç”¨æˆ·äº¤äº’
âœ… **æ ·å¼å®šä¹‰** - èŠ‚ç‚¹/è¾¹çš„è§†è§‰æ ·å¼å’Œä¸»é¢˜
âœ… **æ•°æ®é€‚é…** - ä¸åŒæ•°æ®æºåˆ°æ ‡å‡†æ ¼å¼çš„è½¬æ¢
âœ… **åœºæ™¯ç‰¹å®šç­–ç•¥** - å¦‚MCé…æ–¹å›¾çš„åˆ†å±‚é€»è¾‘ã€å°è¯´å…³ç³»å›¾çš„èšç±»é€»è¾‘
âœ… **è‡ªå®šä¹‰æ¸²æŸ“** - é€šè¿‡æ‰©å±•ç‚¹æ·»åŠ å…­è¾¹å½¢è¾¹ç•Œã€ç‰¹æ®Šæ ‡ç­¾ç­‰
âœ… **æ‰‹åŠ¨LODæ§åˆ¶** - å†³å®šä½•æ—¶æ¿€æ´»/å…³é—­ç‰¹å®šåŒºåŸŸçš„æ¸²æŸ“

### **å…³é”®è®¾è®¡åŸåˆ™**ï¼š
1. **Coreä¿æŒé€šç”¨æ€§** - ä¸åŒ…å«åœºæ™¯ç‰¹å®šé€»è¾‘
2. **æ’ä»¶äº«æœ‰è¶³å¤Ÿçµæ´»æ€§** - é€šè¿‡æ‰©å±•ç‚¹æ·±åº¦å®šåˆ¶Coreè¡Œä¸º  
3. **ä¸¥æ ¼ç±»å‹çº¦æŸ** - æ‰€æœ‰æ¥å£éƒ½æœ‰æ˜ç¡®ç±»å‹ï¼Œåˆ©ç”¨å®˜æ–¹ç±»å‹ä½œä¸ºåŸºç¡€
4. **æ€§èƒ½ä¼˜å…ˆ** - æ•°æ®å¿…é¡»é¢„å‡†å¤‡ï¼Œç”¨æˆ·äº¤äº’å¿…é¡»ç«‹å³å“åº”
5. **æŒ‰éœ€åŸåˆ™** - æ•°æ®æŒ‰éœ€åŠ è½½ï¼ŒèŠ‚ç‚¹æŒ‰éœ€æ¸²æŸ“ï¼ŒåŠŸèƒ½æŒ‰éœ€æ¿€æ´»

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æ¶æ„ï¼ˆ10000+ èŠ‚ç‚¹æ”¯æŒï¼‰

### **æ ¸å¿ƒç“¶é¢ˆåˆ†æ**ï¼š
1. **ç©ºé—´æŸ¥è¯¢** - O(n)ï¼šæ‰¾æœ€ç©ºæ—·åŒºåŸŸéœ€è¦éå†æ‰€æœ‰èŠ‚ç‚¹
2. **æ–¹å‘é€‰æ‹©** - O(n)ï¼šæ¯æ¬¡å±•å¼€è¦è®¡ç®—æ‰€æœ‰é™„è¿‘èŠ‚ç‚¹çš„æ‰‡åŒºå¯†åº¦
3. **è§†å£è£å‰ª** - O(n+m)ï¼šç¡®å®šå¯è§èŠ‚ç‚¹/è¾¹
4. **è¾¹æ‚¬æµ®æ£€æµ‹** - O(m)ï¼šé¼ æ ‡ç§»åŠ¨æ—¶æ£€æµ‹ç‚¹å‡»çš„è¾¹
5. **å¸ƒå±€è®¡ç®—** - é˜»å¡ä¸»çº¿ç¨‹ï¼šè€—æ—¶çš„ä½ç½®è®¡ç®—é”å®šUI

### **ä¼˜åŒ–æ–¹æ¡ˆ 1ï¼šç©ºé—´ç´¢å¼• - å››å‰æ ‘ï¼ˆQuadtreeï¼‰**

```typescript
// å››å‰æ ‘èŠ‚ç‚¹
class QuadTreeNode {
  private readonly bounds: BoundingBox
  private readonly capacity = 10
  private points: Array<{ node: RecipeNode; position: Position }> = []
  private divided = false
  private children?: QuadTreeNode[]
  
  // æ’å…¥èŠ‚ç‚¹ O(log n)
  insert(node: RecipeNode, position: Position): boolean {
    if (!this.contains(position)) return false
    
    if (this.points.length < this.capacity) {
      this.points.push({ node, position })
      return true
    }
    
    if (!this.divided) this.subdivide()
    return this.children!.some(child => child.insert(node, position))
  }
  
  // æŸ¥è¯¢èŒƒå›´å†…çš„èŠ‚ç‚¹ O(log n) å¹³å‡
  queryRange(range: BoundingBox): RecipeNode[] {
    const found: RecipeNode[] = []
    if (!this.intersects(range)) return found
    
    for (const { node, position } of this.points) {
      if (this.pointInRange(position, range)) found.push(node)
    }
    
    if (this.divided) {
      for (const child of this.children!) {
        found.push(...child.queryRange(range))
      }
    }
    return found
  }
  
  // æŸ¥è¯¢åœ†å½¢èŒƒå›´å†…çš„èŠ‚ç‚¹
  queryCircle(center: Position, radius: number): RecipeNode[] {
    const range: BoundingBox = {
      minX: center.x - radius,
      maxX: center.x + radius,
      minY: center.y - radius,
      maxY: center.y + radius
    }
    
    const candidates = this.queryRange(range)
    return candidates.filter(node => {
      if (!node.position) return false
      const dx = node.position.x - center.x
      const dy = node.position.y - center.y
      return dx * dx + dy * dy <= radius * radius
    })
  }
}

// ç©ºé—´ç´¢å¼•ç®¡ç†å™¨
class SpatialIndex {
  private quadTree: QuadTreeNode
  
  findSparsestRegion(searchRadius: number = 500): Position {
    // é‡‡æ ·ç­–ç•¥ï¼šåªé‡‡æ ·æœ‰é™ç‚¹ï¼Œä¸éå†å…¨éƒ¨
    const sampleCount = 20
    let minDensity = Infinity
    let bestPosition: Position = { x: 0, y: 0 }
    
    for (let i = 0; i < sampleCount; i++) {
      const angle = (Math.PI * 2 * i) / sampleCount
      const distance = 300 * (1 + Math.floor(i / 8))
      
      const candidate = {
        x: Math.cos(angle) * distance,
        y: Math.sin(angle) * distance
      }
      
      // ä½¿ç”¨å››å‰æ ‘å¿«é€ŸæŸ¥è¯¢ O(log n)
      const nearbyNodes = this.quadTree.queryCircle(candidate, searchRadius)
      const density = nearbyNodes.length
      
      if (density < minDensity) {
        minDensity = density
        bestPosition = candidate
      }
    }
    
    return bestPosition
  }
  
  findSparsestDirection(parentPos: Position, checkRadius: number): number {
    const sectorCount = 12
    const sectorDensity = new Array(sectorCount).fill(0)
    
    // åªæŸ¥è¯¢é™„è¿‘çš„èŠ‚ç‚¹ï¼Œä¸æ˜¯å…¨éƒ¨ï¼ˆO(log n) vs O(n)ï¼‰
    const nearbyNodes = this.quadTree.queryCircle(parentPos, checkRadius * 2)
    
    nearbyNodes.forEach(node => {
      if (!node.position) return
      
      const dx = node.position.x - parentPos.x
      const dy = node.position.y - parentPos.y
      const distance = Math.sqrt(dx * dx + dy * dy)
      
      if (distance < 10) return
      
      const angle = Math.atan2(dy, dx)
      const sectorIndex = Math.floor(
        ((angle + Math.PI) / (Math.PI * 2)) * sectorCount
      ) % sectorCount
      
      const weight = 1 / (distance / checkRadius)
      sectorDensity[sectorIndex] += weight
    })
    
    let minDensity = Infinity
    let sparsestSector = 0
    
    sectorDensity.forEach((density, i) => {
      if (density < minDensity) {
        minDensity = density
        sparsestSector = i
      }
    })
    
    return (sparsestSector / sectorCount) * Math.PI * 2 - Math.PI
  }
}
```

**æ€§èƒ½æå‡**ï¼šæŸ¥æ‰¾ç©ºæ—·åŒºåŸŸä» O(n) é™åˆ° O(log n Ã— é‡‡æ ·æ•°) â‰ˆ O(1)

### **ä¼˜åŒ–æ–¹æ¡ˆ 2ï¼šè§†å£è£å‰ª + å¢é‡æ¸²æŸ“**

```typescript
// è§†å£è£å‰ªç®¡ç†å™¨
class ViewportCullingManager {
  private visibleNodes = new Set<string>()
  private lastViewport: ViewportInfo | null = null
  
  updateVisibleNodes(viewport: ViewportInfo): void {
    // æ£€æŸ¥è§†å£æ˜¯å¦æ˜¾è‘—å˜åŒ–ï¼ˆé¿å…é¢‘ç¹æ›´æ–°ï¼‰
    if (this.lastViewport && !this.viewportChangedSignificantly(viewport)) {
      return
    }

    // æ‰©å±•è§†å£è¾¹ç•Œï¼ˆç¼“å†²åŒºï¼‰
    const buffer = 200
    const expandedBounds: BoundingBox = {
      minX: viewport.visibleBounds.minX - buffer,
      maxX: viewport.visibleBounds.maxX + buffer,
      minY: viewport.visibleBounds.minY - buffer,
      maxY: viewport.visibleBounds.maxY + buffer
    }
    
    // ä½¿ç”¨å››å‰æ ‘å¿«é€ŸæŸ¥è¯¢å¯è§èŠ‚ç‚¹
    const visibleNodes = this.spatialIndex.queryRange(expandedBounds)
    
    this.visibleNodes.clear()
    visibleNodes.forEach(node => this.visibleNodes.add(node.id))
    
    this.applyVisibilityFilter()
  }
  
  private viewportChangedSignificantly(newViewport: ViewportInfo): boolean {
    if (!this.lastViewport) return true
    
    const zoomChange = Math.abs(newViewport.zoom - this.lastViewport.zoom)
    const panChangeX = Math.abs(newViewport.center.x - this.lastViewport.center.x)
    const panChangeY = Math.abs(newViewport.center.y - this.lastViewport.center.y)
    
    // ç¼©æ”¾å˜åŒ–è¶…è¿‡10%ï¼Œæˆ–å¹³ç§»è¶…è¿‡100px
    return zoomChange > 0.1 || panChangeX > 100 || panChangeY > 100
  }
}
```

### **ä¼˜åŒ–æ–¹æ¡ˆ 3ï¼šWeb Worker å¸ƒå±€è®¡ç®—**

```typescript
// å¸ƒå±€Workeræ± 
class LayoutWorkerPool {
  private workers: Worker[] = []
  
  async computeLayoutAsync(
    nodes: RecipeNode[],
    edges: RecipeEdge[]
  ): Promise<Map<string, Position>> {
    return new Promise((resolve, reject) => {
      const worker = this.getAvailableWorker()
      
      worker.postMessage({
        type: 'compute-layout',
        nodes: nodes.map(n => ({ id: n.id, position: n.position })),
        edges: edges.map(e => ({ source: e.source, target: e.target }))
      })
      
      worker.onmessage = (event) => {
        if (event.data.type === 'layout-result') {
          resolve(new Map(Object.entries(event.data.positions)))
        }
      }
    })
  }
}

// Workerä»£ç  - åå°è®¡ç®—ï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹
self.onmessage = (event) => {
  if (event.data.type === 'compute-layout') {
    const { nodes, edges } = event.data
    
    // åœ¨Workerä¸­æ‰§è¡Œè€—æ—¶çš„å¸ƒå±€è®¡ç®—
    const positions = computeHierarchyLayout(nodes, edges)
    
    self.postMessage({
      type: 'layout-result',
      positions: Object.fromEntries(positions)
    })
  }
}
```

---

## ğŸ¯ çº¿ç¨‹è·Ÿè¸ªç³»ç»Ÿï¼ˆå¸ƒå±€è®¡ç®—è¿›åº¦ç›‘æ§ï¼‰

### **ä»»åŠ¡è·Ÿè¸ªæ ¸å¿ƒ**

```typescript
// ä»»åŠ¡ç±»å‹æšä¸¾
enum LayoutTaskType {
  NODE_EXPAND = 'node-expand',           // èŠ‚ç‚¹å±•å¼€å¸ƒå±€
  LOOP_LAYOUT = 'loop-layout',           // å¾ªç¯ç»„å¸ƒå±€
  REGION_ACTIVATE = 'region-activate',   // å…­è¾¹å½¢æ¿€æ´»å¸ƒå±€
  FORCE_ADJUST = 'force-adjust'          // åŠ›å¯¼å‘å¾®è°ƒ
}

// ä»»åŠ¡å®šä¹‰
interface LayoutTask {
  readonly id: string
  readonly type: LayoutTaskType
  readonly name: string
  readonly workerId?: number
  
  status: 'queued' | 'running' | 'completed' | 'failed' | 'cancelled'
  progress: number                     // 0-100
  
  readonly totalSteps: number
  currentStep: number
  
  readonly createdAt: number
  startedAt?: number
  completedAt?: number
  
  readonly metadata: {
    readonly nodeCount?: number
    readonly targetNodeId?: string
    [key: string]: unknown
  }
}

// ä»»åŠ¡è·Ÿè¸ªå™¨
class LayoutTaskTracker {
  private tasks = new Map<string, LayoutTask>()
  private listeners = new Set<(event: string, task: LayoutTask) => void>()
  
  createTask(
    type: LayoutTaskType,
    name: string,
    totalSteps: number,
    metadata: Record<string, unknown> = {}
  ): string {
    const taskId = `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
    
    const task: LayoutTask = {
      id: taskId,
      type,
      name,
      status: 'queued',
      progress: 0,
      totalSteps,
      currentStep: 0,
      createdAt: Date.now(),
      metadata
    }
    
    this.tasks.set(taskId, task)
    this.notify('task-created', task)
    return taskId
  }
  
  startTask(taskId: string, workerId?: number): void {
    const task = this.tasks.get(taskId)
    if (!task) return
    
    task.status = 'running'
    task.startedAt = Date.now()
    if (workerId !== undefined) (task as any).workerId = workerId
    
    this.notify('task-started', task)
  }
  
  updateProgress(taskId: string, currentStep: number, message?: string): void {
    const task = this.tasks.get(taskId)
    if (!task) return
    
    task.currentStep = currentStep
    task.progress = Math.round((currentStep / task.totalSteps) * 100)
    if (message) (task.metadata as any).currentMessage = message
    
    this.notify('task-progress', task)
  }
  
  completeTask(taskId: string): void {
    const task = this.tasks.get(taskId)
    if (!task) return
    
    task.status = 'completed'
    task.progress = 100
    task.currentStep = task.totalSteps
    task.completedAt = Date.now()
    
    this.notify('task-completed', task)
    
    // å»¶è¿Ÿæ¸…ç†å·²å®Œæˆä»»åŠ¡
    setTimeout(() => this.cleanupOldTasks(), 3000)
  }
  
  getActiveTasks(): LayoutTask[] {
    return Array.from(this.tasks.values()).filter(
      task => task.status === 'queued' || task.status === 'running'
    )
  }
  
  subscribe(listener: (event: string, task: LayoutTask) => void): () => void {
    this.listeners.add(listener)
    return () => this.listeners.delete(listener)
  }
  
  private notify(event: string, task: LayoutTask): void {
    this.listeners.forEach(listener => {
      try {
        listener(event, task)
  } catch (error) {
        console.error('Task listener error:', error)
      }
    })
  }
}

// å…¨å±€å•ä¾‹
export const taskTracker = new LayoutTaskTracker()
```

### **ä¸Workeræ± é›†æˆ**

```typescript
// å¢å¼ºçš„Workeræ± ï¼Œæ”¯æŒè¿›åº¦æŠ¥å‘Š
class ProgressAwareLayoutWorkerPool {
  constructor(
    private taskTracker: LayoutTaskTracker,
    workerCount = navigator.hardwareConcurrency || 4
  ) {
    this.initializeWorkers(workerCount)
  }
  
  async submitTask(
    type: LayoutTaskType,
    data: LayoutTaskData
  ): Promise<LayoutResult> {
    // 1. åˆ›å»ºä»»åŠ¡è·Ÿè¸ª
    const taskId = this.taskTracker.createTask(
      type,
      this.getTaskName(type, data),
      this.estimateSteps(type, data),
      {
        nodeCount: data.nodes?.length,
        targetNodeId: data.targetNodeId
      }
    )
    
    // 2. ç­‰å¾…å¯ç”¨Worker
    const workerId = await this.waitForAvailableWorker()
    const worker = this.workers[workerId]
    
    this.taskTracker.startTask(taskId, workerId)
    
    // 3. æäº¤åˆ°Worker
    return new Promise((resolve, reject) => {
      const messageHandler = (event: MessageEvent) => {
        const { type: msgType, data: msgData } = event.data
        
        switch (msgType) {
          case 'progress':
            this.taskTracker.updateProgress(
              taskId,
              msgData.step,
              msgData.message
            )
            break
          case 'complete':
            this.taskTracker.completeTask(taskId)
            worker.removeEventListener('message', messageHandler)
            resolve(msgData.result)
            break
          case 'error':
            this.taskTracker.failTask(taskId, new Error(msgData.error))
            worker.removeEventListener('message', messageHandler)
            reject(new Error(msgData.error))
            break
        }
      }
      
      worker.addEventListener('message', messageHandler)
      worker.postMessage({ taskId, type, data })
    })
  }
  
  private estimateSteps(type: LayoutTaskType, data: LayoutTaskData): number {
    const nodeCount = data.nodes?.length || 0
    switch (type) {
      case LayoutTaskType.NODE_EXPAND:
        return Math.max(5, Math.ceil(nodeCount / 10))
      case LayoutTaskType.LOOP_LAYOUT:
        return Math.max(3, Math.ceil(nodeCount / 20))
      case LayoutTaskType.REGION_ACTIVATE:
        return Math.max(10, Math.ceil(nodeCount / 50))
      default:
        return 5
    }
  }
}
```

---

## ğŸ”’ ä¸¥æ ¼ç±»å‹ç³»ç»Ÿè®¾è®¡

### **ç±»å‹å¯¼å…¥ç­–ç•¥**ï¼š

**1. å®˜æ–¹ç±»å‹ä½œä¸ºåŸºç¡€çº¦æŸ**ï¼š
```typescript
// Sigma.js å®˜æ–¹ç±»å‹
import type { 
  Sigma, Graph, Settings, Camera,
  NodeDisplayData, EdgeDisplayData,
  NodeProgram, EdgeProgram,
  SigmaEventPayload 
} from 'sigma/types'

// Graphology å®˜æ–¹ç±»å‹
import type { 
  Attributes, GraphType, MultiGraph,
  NodeKey, EdgeKey, GraphOptions 
} from 'graphology-types'

// WebGL ç›¸å…³å®˜æ–¹ç±»å‹
import type { 
  WebGLRenderingContext, 
  WebGL2RenderingContext 
} from '@types/webgl2'
```

**2. è‡ªå®šä¹‰ç±»å‹ä¸¥æ ¼è§„èŒƒ**ï¼š
```typescript
// âœ… æ­£ç¡®ï¼šä½¿ç”¨ readonly å’Œæ˜ç¡®ç±»å‹
interface StarChartNode {
  readonly id: string
  readonly name: string
  readonly position: { readonly x: number; readonly y: number }
  readonly metadata: Readonly<Record<string, string | number | boolean>>
}

// âŒ é”™è¯¯ï¼šä½¿ç”¨ any æˆ–å¯å˜ç±»å‹
interface BadNode {
  id: string
  data: any                    // ä¸¥ç¦ï¼
  position: { x: number; y: number }  // å¯å˜ï¼Œä¸æ¨è
}
```

**3. ç±»å‹å®‰å…¨ä¿è¯æœºåˆ¶**ï¼š
- **ç¼–è¯‘æ—¶æ£€æŸ¥**ï¼šä½¿ç”¨ TypeScript strict æ¨¡å¼
- **è¿è¡Œæ—¶éªŒè¯**ï¼šå…³é”®æ¥å£ä½¿ç”¨ Zod ç­‰åº“è¿›è¡Œè¿è¡Œæ—¶éªŒè¯
- **æ¥å£ç»§æ‰¿**ï¼šåŸºäºå®˜æ–¹ç±»å‹æ‰©å±•ï¼Œç¡®ä¿å…¼å®¹æ€§
- **æ³›å‹çº¦æŸ**ï¼šä½¿ç”¨æ³›å‹ç¡®ä¿ç±»å‹å‚æ•°çš„æ­£ç¡®æ€§

**4. é”™è¯¯å¤„ç†ç±»å‹åŒ–**ï¼š
```typescript
// ä¸¥æ ¼çš„é”™è¯¯ç±»å‹å®šä¹‰
type StarChartError = 
  | { type: 'PLUGIN_LOAD_FAILED'; pluginId: string; reason: string }
  | { type: 'DATA_LOAD_FAILED'; source: string; error: Error }
  | { type: 'RENDER_FAILED'; nodeCount: number; error: Error }
  | { type: 'MEMORY_EXCEEDED'; current: number; limit: number }

// ä¸¥æ ¼çš„ç»“æœç±»å‹
type LoadResult<T> = 
  | { success: true; data: T }
  | { success: false; error: StarChartError }
```

### **ç±»å‹æ£€æŸ¥é…ç½®**ï¼š
```json
// tsconfig.json ä¸¥æ ¼é…ç½®
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

---

### **2.3 èŠ‚ç‚¹å±•å¼€ä¸å¤æ‚çˆ¶å­å…³ç³»å¤„ç†**

**å±•å¼€å¸ƒå±€ç®—æ³•**ï¼š

```typescript
// èŠ‚ç‚¹å±•å¼€ç®¡ç†å™¨
class NodeExpansionManager {
  // è·Ÿè¸ªæ¯ä¸ªèŠ‚ç‚¹è¢«å“ªäº›çˆ¶èŠ‚ç‚¹å±•å¼€äº†
  private expansionHistory = new Map<string, Set<string>>()
  
  async expandNode(parentId: string): Promise<void> {
    const parent = this.getNode(parentId)
    if (!parent.childrenIds) return
    
    // 1. åŠ è½½å­èŠ‚ç‚¹æ•°æ®ï¼ˆå·²é¢„å‡†å¤‡ï¼‰
    const children = await this.loadChildren(parent.childrenIds)
    
    // åˆ†ç±»å­èŠ‚ç‚¹ï¼šæ–°èŠ‚ç‚¹ vs å·²å­˜åœ¨èŠ‚ç‚¹
    const { newChildren, existingChildren } = this.categorizeChildren(children)
    
    // 2. å¤„ç†æ–°å­èŠ‚ç‚¹ï¼šè®¡ç®—ä½ç½®å¹¶æ·»åŠ 
    if (newChildren.length > 0) {
      const newPositions = layoutExpandedChildren(
        parent,
        newChildren,
        this.nodesMap
      )
      
      newChildren.forEach(child => {
        const pos = newPositions.get(child.id)!
        this.addNode({ ...child, position: pos, visible: true })
      })
    }
    
    // 3. å¤„ç†å·²å­˜åœ¨å­èŠ‚ç‚¹ï¼šåªæ·»åŠ è¾¹ï¼Œä¸ç§»åŠ¨èŠ‚ç‚¹
    // âš ï¸ å…³é”®ç‰¹æ€§ï¼šå¦‚æœå­èŠ‚ç‚¹å·²è¢«å…¶ä»–çˆ¶èŠ‚ç‚¹å±•å¼€ï¼Œåªæ·»åŠ æ–°è¾¹ï¼Œä¸ç§»åŠ¨
    existingChildren.forEach(child => {
      this.addEdge({
        id: `${parentId}-${child.id}`,
        source: parentId,
        target: child.id,
        type: 'crafting',
        // é•¿è·ç¦»è¾¹ä½¿ç”¨æ›´å¤§æ›²ç‡ï¼Œè®©é•¿è¾¹æ›´æ˜æ˜¾
        curveConfig: this.computeLongDistanceCurve(
          parent.position!,
          child.position!
        )
      })
    })
    
    // 4. è®°å½•å±•å¼€å†å²
    children.forEach(child => {
      if (!this.expansionHistory.has(child.id)) {
        this.expansionHistory.set(child.id, new Set())
      }
      this.expansionHistory.get(child.id)!.add(parentId)
    })
    
    // 5. è§¦å‘æ¸²æŸ“æ›´æ–°
    this.scheduleRender()
  }
  
  // æ”¶èµ·èŠ‚ç‚¹
  async collapseNode(parentId: string): Promise<void> {
    const parent = this.getNode(parentId)
    if (!parent.childrenIds) return
    
    parent.childrenIds.forEach(childId => {
      const expandedBy = this.expansionHistory.get(childId)
      if (!expandedBy) return
      
      // ç§»é™¤å½“å‰çˆ¶èŠ‚ç‚¹çš„å±•å¼€è®°å½•
      expandedBy.delete(parentId)
      
      // å¦‚æœå­èŠ‚ç‚¹ä¸å†è¢«ä»»ä½•çˆ¶èŠ‚ç‚¹å±•å¼€ï¼Œéšè—å®ƒ
      if (expandedBy.size === 0) {
        this.hideNode(childId)
        this.recursiveHide(childId)  // é€’å½’éšè—å…¶å­èŠ‚ç‚¹
      } else {
        // å­èŠ‚ç‚¹è¿˜è¢«å…¶ä»–çˆ¶èŠ‚ç‚¹å±•å¼€ï¼Œåªåˆ é™¤è¿™æ¡è¾¹
        this.removeEdge(`${parentId}-${childId}`)
      }
    })
    
    this.scheduleRender()
  }
}

// å¼§å½¢åˆ†å¸ƒç®—æ³•ï¼ˆè‡ªåŠ¨æ‰¾æœ€ç©ºæ—·æ–¹å‘ï¼‰
function layoutExpandedChildren(
  parent: RecipeNode,
  children: ReadonlyArray<RecipeNode>,
  existingNodes: Map<string, RecipeNode>
): Map<string, Position> {
  const positions = new Map<string, Position>()
  const childCount = children.length
  
  // å±•å¼€åŠå¾„ï¼šæ ¹æ®å­èŠ‚ç‚¹æ•°é‡è‡ªé€‚åº”
  const radius = 120 + Math.min(childCount * 8, 80)
  
  // å¼§çš„è§’åº¦èŒƒå›´ï¼š120åº¦åˆ°180åº¦ä¹‹é—´ï¼Œæ ¹æ®å­èŠ‚ç‚¹æ•°é‡è°ƒæ•´
  const arcAngle = Math.PI * (0.66 + childCount * 0.03)  // 120Â° - 180Â°
  
  // æ‰¾åˆ°æœ€ç©ºæ—·çš„æ–¹å‘ä½œä¸ºå¼§çš„ä¸­å¿ƒæ–¹å‘
  const preferredDirection = findSparsestDirection(
    parent.position!,
    existingNodes,
    radius
  )
  
  // åœ¨å¼§ä¸Šå‡åŒ€åˆ†å¸ƒå­èŠ‚ç‚¹
  children.forEach((child, i) => {
    const existingChild = existingNodes.get(child.id)
    
    if (existingChild && existingChild.position) {
      // å­èŠ‚ç‚¹å·²å­˜åœ¨ï¼Œä¸ç§»åŠ¨ä½ç½®
      positions.set(child.id, existingChild.position)
    } else {
      // æ–°å­èŠ‚ç‚¹ï¼Œåœ¨å¼§ä¸Šåˆ†å¸ƒ
      const angleOffset = (arcAngle / (childCount - 1 || 1)) * i - arcAngle / 2
      const angle = preferredDirection + angleOffset
      
      positions.set(child.id, {
        x: parent.position!.x + Math.cos(angle) * radius,
        y: parent.position!.y + Math.sin(angle) * radius
      })
    }
  })
  
  return positions
}

// æ‰¾åˆ°æœ€ç©ºæ—·çš„æ–¹å‘ï¼ˆæ‰‡åŒºå¯†åº¦åˆ†æï¼‰
function findSparsestDirection(
  parentPos: Position,
  existingNodes: Map<string, RecipeNode>,
  radius: number
): number {
  const sectorCount = 12  // å°†360åº¦åˆ†ä¸º12ä¸ªæ‰‡åŒº
  const sectorDensity = new Array(sectorCount).fill(0)
  
  // è®¡ç®—æ¯ä¸ªæ‰‡åŒºçš„èŠ‚ç‚¹å¯†åº¦
  existingNodes.forEach(node => {
    if (!node.position) return
    
    const dx = node.position.x - parentPos.x
    const dy = node.position.y - parentPos.y
    const distance = Math.sqrt(dx * dx + dy * dy)
    
    // åªè€ƒè™‘é™„è¿‘çš„èŠ‚ç‚¹ï¼ˆ2å€åŠå¾„å†…ï¼‰
    if (distance < radius * 2 && distance > 10) {
      const angle = Math.atan2(dy, dx)
      const sectorIndex = Math.floor(
        ((angle + Math.PI) / (Math.PI * 2)) * sectorCount
      ) % sectorCount
      
      // è·ç¦»è¶Šè¿‘ï¼Œå¯†åº¦æƒé‡è¶Šé«˜
      const weight = 1 / (distance / radius)
      sectorDensity[sectorIndex] += weight
    }
  })
  
  // æ‰¾åˆ°å¯†åº¦æœ€ä½çš„æ‰‡åŒº
  let minDensity = Infinity
  let sparsestSector = 0
  
  sectorDensity.forEach((density, i) => {
    if (density < minDensity) {
      minDensity = density
      sparsestSector = i
    }
  })
  
  // è¿”å›è¯¥æ‰‡åŒºçš„ä¸­å¿ƒè§’åº¦
  return (sparsestSector / sectorCount) * Math.PI * 2 - Math.PI
}
```

---

### **2.4 è¾¹çš„æ–¹å‘å’Œæ‚¬æµ®æ ‡ç­¾å®ç°**

**è¾¹æ–¹å‘æ˜¾ç¤º**ï¼ˆä½¿ç”¨å¸¦ç®­å¤´çš„æ›²çº¿ï¼‰ï¼š

```typescript
// è¾¹é…ç½®ï¼šä½¿ç”¨ç®­å¤´æ˜¾ç¤ºæ–¹å‘
const edgeConfig = {
  defaultEdgeType: 'curvedArrow',  // å¸¦ç®­å¤´çš„æ›²çº¿
  
  edgeProgramClasses: {
    curvedArrow: createEdgeCurveProgram({
      // ç®­å¤´é…ç½®
      arrowSize: 3,              // ç®­å¤´å¤§å°
      arrowPosition: 0.95,       // ç®­å¤´ä½ç½®ï¼ˆ95%å¤„ï¼Œæ¥è¿‘ç›®æ ‡èŠ‚ç‚¹ï¼‰
      
      // æ›²çº¿é…ç½®
      curvature: (edge) => {
        const distance = calculateDistance(
          edge.sourcePosition,
          edge.targetPosition
        )
        // çŸ­è¾¹æ›²ç‡å°ï¼Œé•¿è¾¹æ›²ç‡å¤§
        return 0.15 + Math.min(distance / 1000, 0.4)
      }
    })
  }
}
```

**è¾¹æ ‡ç­¾æ‚¬æµ®æ¸²æŸ“**ï¼ˆè‡ªå®šä¹‰Canvaså±‚ï¼‰ï¼š

```typescript
// è‡ªå®šä¹‰Canvaså±‚ï¼šæ‚¬æµ®æ ‡ç­¾
class HoverLabelLayer implements CustomLayerDefinition {
  readonly id = 'hover-labels'
  readonly type = 'canvas'
  readonly zIndex = 1000  // æœ€é¡¶å±‚
  
  private hoveredEdge: RecipeEdge | null = null
  private mousePosition: { x: number; y: number } | null = null
  
  constructor(
    private sigma: Sigma,
    private eventBus: EventBus
  ) {
    // ç›‘å¬è¾¹æ‚¬æµ®äº‹ä»¶
    this.eventBus.on('edge:hover', this.handleEdgeHover.bind(this))
    this.eventBus.on('edge:leave', this.handleEdgeLeave.bind(this))
    this.eventBus.on('mouse:move', this.handleMouseMove.bind(this))
  }
  
  render(context: CanvasRenderingContext2D): void {
    if (!this.hoveredEdge || !this.mousePosition) return
    
    const platform = this.hoveredEdge.platform
    
    // åœ¨å…‰æ ‡æ—è¾¹ç»˜åˆ¶å¹³å°åç§°ï¼ˆä¸å›ºå®šä½ç½®ï¼Œè·Ÿéšå…‰æ ‡ï¼‰
    const labelX = this.mousePosition.x + 15  // å…‰æ ‡å³ä¾§15px
    const labelY = this.mousePosition.y - 10  // å…‰æ ‡ä¸Šæ–¹10px
    
    // ç»˜åˆ¶èƒŒæ™¯
    context.fillStyle = 'rgba(0, 0, 0, 0.8)'
    context.strokeStyle = '#4A90E2'
    context.lineWidth = 2
    
    const padding = 8
    const text = platform.name
    const metrics = context.measureText(text)
    const width = metrics.width + padding * 2
    const height = 24
    
    // åœ†è§’çŸ©å½¢èƒŒæ™¯
    this.drawRoundedRect(context, labelX, labelY, width, height, 4)
    
    // ç»˜åˆ¶æ–‡å­—
    context.fillStyle = '#FFFFFF'
    context.font = '12px "Segoe UI", sans-serif'
    context.textBaseline = 'middle'
    context.fillText(text, labelX + padding, labelY + height / 2)
  }
  
  destroy(): void {
    this.eventBus.off('edge:hover', this.handleEdgeHover)
    this.eventBus.off('edge:leave', this.handleEdgeLeave)
    this.eventBus.off('mouse:move', this.handleMouseMove)
  }
}

// è¾¹çš„ç©ºé—´å“ˆå¸Œç´¢å¼•ï¼ˆåŠ é€Ÿæ‚¬æµ®æ£€æµ‹ï¼‰
class EdgeSpatialHash {
  private cellSize = 50  // ç½‘æ ¼å¤§å°50px
  private hash = new Map<string, Set<string>>()  // ç½‘æ ¼ -> è¾¹IDé›†åˆ
  
  // æ·»åŠ è¾¹åˆ°ç©ºé—´å“ˆå¸Œ
  addEdge(edge: RecipeEdge, sourcePos: Position, targetPos: Position): void {
    const cells = this.getEdgeCells(sourcePos, targetPos)
    cells.forEach(cellKey => {
      if (!this.hash.has(cellKey)) {
        this.hash.set(cellKey, new Set())
      }
      this.hash.get(cellKey)!.add(edge.id)
    })
  }
  
  // å¿«é€ŸæŸ¥è¯¢é¼ æ ‡ä½ç½®é™„è¿‘çš„è¾¹ O(1) å¹³å‡
  queryEdgesNearPoint(point: Position, threshold: number = 10): string[] {
    const cellKey = this.getCellKey(point)
    const candidates = this.hash.get(cellKey) || new Set()
    
    // ä¹Ÿæ£€æŸ¥ç›¸é‚»ç½‘æ ¼
    const neighborKeys = this.getNeighborCells(cellKey)
    neighborKeys.forEach(key => {
      const neighbors = this.hash.get(key)
      if (neighbors) {
        neighbors.forEach(edgeId => candidates.add(edgeId))
      }
    })
    
    return Array.from(candidates)
  }
}
```

---

## ğŸ“‹ å®Œæ•´ç³»ç»Ÿæ€»ç»“ä¸æ•´åˆ

### **æ¶æ„ä¸‰å±‚æ¦‚è§ˆ**

**ç¬¬ä¸€å±‚ï¼šCoreï¼ˆç³»ç»ŸåŸºå»ºï¼‰**
- **ä¸å˜æ€§åŸåˆ™**ï¼šé€šç”¨ã€æ— åœºæ™¯ç‰¹å®šé€»è¾‘
- **èŒè´£é“¾**ï¼šSigmaManager â†’ LayerManager â†’ RenderScheduler â†’ DataLoader
- **æ€§èƒ½ä¿éšœ**ï¼šæ‰¹é‡æ›´æ–°é˜²æŠ–ã€è§†å£è£å‰ªã€å¢é‡æ¸²æŸ“

**ç¬¬äºŒå±‚ï¼šPluginsï¼ˆåœºæ™¯æ’ä»¶ï¼‰**
- **å¸ƒå±€æ’ä»¶**ï¼šæ”¯æŒå¼§å½¢åˆ†å¸ƒã€å¾ªç¯æ¤­åœ†ã€ç©ºé—´ç´¢å¼•åŠ é€Ÿ
- **äº¤äº’æ’ä»¶**ï¼šåŒå‡»å±•å¼€ã€å…­è¾¹å½¢æ¿€æ´»ã€é•¿è·ç¦»è¾¹å¤„ç†
- **æ¸²æŸ“æ’ä»¶**ï¼šç®­å¤´æ–¹å‘ã€æ‚¬æµ®æ ‡ç­¾ã€è¾¹çš„ç©ºé—´å“ˆå¸Œæ£€æµ‹

**ç¬¬ä¸‰å±‚ï¼šMonitoringï¼ˆè¿›åº¦ç›‘æ§ï¼‰**
- **ä»»åŠ¡è·Ÿè¸ª**ï¼šLayoutTaskTracker åŠ¨æ€åˆ›å»º/ç®¡ç†ä»»åŠ¡
- **Workeræ± é›†æˆ**ï¼šè¿›åº¦æŠ¥å‘Šã€è€—æ—¶ç»Ÿè®¡ã€å¹¶å‘ç®¡ç†
- **UIå±•ç¤º**ï¼šæ´»è·ƒä»»åŠ¡/å®Œæˆå†å²ã€å®æ—¶è¿›åº¦æ¡

### **æ ¸å¿ƒç®—æ³•æ•´åˆ**

| é—®é¢˜ | åŸå¤æ‚åº¦ | ä¼˜åŒ–å | æ ¸å¿ƒæ”¹è¿› |
|------|--------|--------|----------|
| æ‰¾æœ€ç©ºæ—·åŒºåŸŸ | O(n) | O(1) | å››å‰æ ‘é‡‡æ · |
| æ‰¾å±•å¼€æ–¹å‘ | O(n) | O(log n) | å››å‰æ ‘èŒƒå›´æŸ¥è¯¢ |
| è§†å£è£å‰ª | O(n+m) | O(log n) | æ˜¾è‘—å˜åŒ–åˆ¤å®š + å››å‰æ ‘ |
| è¾¹æ‚¬æµ®æ£€æµ‹ | O(m) | O(1) | ç©ºé—´å“ˆå¸Œç½‘æ ¼ |
| å¸ƒå±€è®¡ç®— | é˜»å¡ä¸»çº¿ç¨‹ | éé˜»å¡ | Web Workeråå° |
| æ‰¹é‡æ›´æ–° | æ¯æ¬¡æ“ä½œæ¸²æŸ“ | 16msé˜²æŠ– | requestAnimationFrame |

**ç»¼åˆæ€§èƒ½æå‡**ï¼šä¸‡çº§èŠ‚ç‚¹ä»å¯èƒ½çš„æ•°ç§’å¡é¡¿ â†’ < 100ms å“åº”æ—¶é—´

### **å…³é”®ç‰¹æ€§æ•´åˆ**

**1. èŠ‚ç‚¹ç±»å‹çš„å®Œæ•´å¤„ç†**
```
topï¼ˆé¡¶å±‚ï¼‰      å¾ªç¯ï¼ˆåˆå§‹æ¤­åœ†ï¼‰  regularï¼ˆå±•å¼€å¼§ï¼‰
    â†“                  â†“                    â†“
æ— çˆ¶èŠ‚ç‚¹        ä¸å¯å±•å¼€         è‡ªé€‚åº”å¼§ + ç©ºæ—·æ–¹å‘
```

**2. å¤æ‚çˆ¶å­å…³ç³»**
- å·²å±•å¼€èŠ‚ç‚¹ï¼šä¸ç§»åŠ¨ä½ç½®ï¼Œåªæ·»åŠ æ–°è¾¹
- æ–°å­èŠ‚ç‚¹ï¼šè®¡ç®—å¼§å½¢ä½ç½®ï¼Œé˜²æ­¢å åŠ 
- å¤šçˆ¶åœºæ™¯ï¼šè¿½è¸ªå±•å¼€å†å²ï¼Œæ™ºèƒ½éšè—

**3. è§†è§‰åé¦ˆ**
- è¾¹æ–¹å‘ï¼šç®­å¤´æŒ‡å‘ç›®æ ‡èŠ‚ç‚¹ï¼ˆ95%ä½ç½®ï¼‰
- è¾¹æ ‡ç­¾ï¼šè·Ÿéšå…‰æ ‡æ‚¬æµ®æ˜¾ç¤ºï¼Œä¸å›ºå®šä½ç½®
- é•¿è·ç¦»è¾¹ï¼šè‡ªé€‚åº”æ›²ç‡ï¼Œæ›´æ˜æ˜¾çš„å¼§çº¿

**4. æ€§èƒ½ä¿éšœ**
- æ•°æ®é¢„å‡†å¤‡ï¼šäº¤äº’å‰æ•°æ®å·²å°±ç»ª 
- ç«‹å³å“åº”ï¼š< 16ms è§¦å‘æ¸²æŸ“
- å†…å­˜ç®¡ç†ï¼šæ´»è·ƒèŠ‚ç‚¹ < 5000ï¼Œè¶…å‡ºç«‹å³é‡Šæ”¾
- å®æ—¶ç›‘æ§ï¼šè¿›åº¦è·Ÿè¸ªã€ä»»åŠ¡é˜Ÿåˆ—ã€Workerè´Ÿè½½

---

**Bossï¼Œå…¨é¢æ•´åˆå®Œæˆï¼Œæ¶µç›–ï¼š**

âœ… **æ ¸å¿ƒæ¶æ„** - ä¸‰å±‚åˆ†æ˜çš„ç³»ç»Ÿè®¾è®¡
âœ… **å¸ƒå±€ç®—æ³•** - å¾ªç¯èŠ‚ç‚¹ã€å¼§å½¢å±•å¼€ã€ç©ºé—´ç´¢å¼•
âœ… **å¤æ‚å…³ç³»** - å¤šçˆ¶å¤šå­ã€å·²å­˜èŠ‚ç‚¹ã€å±•å¼€å†å²
âœ… **è§†è§‰è®¾è®¡** - ç®­å¤´æ–¹å‘ã€æ‚¬æµ®æ ‡ç­¾ã€è‡ªé€‚åº”æ›²ç‡
âœ… **æ€§èƒ½ä¼˜åŒ–** - å››å‰æ ‘ã€è§†å£è£å‰ªã€Web Workerã€ç©ºé—´å“ˆå¸Œ
âœ… **è¿›åº¦ç›‘æ§** - åŠ¨æ€ä»»åŠ¡è·Ÿè¸ªã€å®æ—¶è¿›åº¦æ¡ã€Workeré›†æˆ
âœ… **ä¸¥æ ¼ç±»å‹** - å®˜æ–¹ç±»å‹å¯¼å…¥ã€readonlyçº¦æŸã€ç±»å‹å®‰å…¨

---
