Boss，非常好的设计思路！让我帮您整理一个完整的架构方案。

## 🌟 StarChart 星图系统 - 架构设计方案

### 📐 核心设计理念

**StarChart 不是一个具体的图可视化工具，而是一个面向海量结构化数据的可视化渲染引擎，通过插件化架构适配不同场景。**

---

## 🏗️ 系统分层架构

### **第一层：系统基建（StarChart Core）**

这是通用的、场景无关的核心引擎。

```
StarChart Core/
├── SigmaManager           # Sigma.js 生命周期封装
├── LayerManager           # 多层渲染管理器
├── RenderScheduler        # 按需渲染调度器
├── DataLoader             # 异步数据加载器
├── ViewportManager        # 视口状态管理
├── EventBus               # 事件总线
├── PluginRegistry         # 插件注册中心
└── StateStore             # 图状态管理
```

#### **1.1 SigmaManager（Sigma 封装层）**
**职责**：
- 管理 Sigma 实例生命周期
- 统一的初始化/销毁接口
- 配置标准化
- 提供 Renderer 抽象
- **为插件提供深度定制的扩展点**

**核心思考**：
- Sigma.js 只是渲染引擎，不应该暴露给插件
- 插件只需要知道"如何描述渲染内容"，不需要知道"如何渲染"
- **Core必须足够灵活，支持插件的深度定制需求**

**类型系统设计**：
```typescript
// 导入官方类型作为基础约束
import type { Sigma, Graph } from 'sigma'
import type { Attributes } from 'graphology-types'

// SigmaManager 核心接口
interface SigmaManagerConfig {
  container: HTMLElement
  renderers?: Record<string, NodeProgram | EdgeProgram>
  settings?: Partial<SigmaSettings>
}

// 插件扩展点接口
interface PluginExtensionAPI {
  // 层管理扩展点
  registerCustomLayer(layerId: string, layer: CustomLayerDefinition): void
  // 渲染器扩展点  
  registerCustomRenderer(type: 'node' | 'edge', renderer: CustomRenderer): void
  // 事件扩展点
  registerCustomEventHandler(event: string, handler: EventHandler): void
  // 数据处理扩展点
  registerDataProcessor(processor: DataProcessor): void
}

// 严格的自定义层定义
interface CustomLayerDefinition {
  readonly id: string
  readonly name: string
  readonly zIndex: number
  readonly type: 'webgl' | 'canvas' | 'svg' | 'html'
  render(context: RenderContext): void
  destroy(): void
}
```

**扩展点架构**：
- **Zoom系统等复杂插件**可通过扩展点深度定制Core行为
- **通用插件**只需使用标准接口
- **按需接口原则**：复杂需求的接口按需添加到Core中

---
#### **1.2 LayerManager（层管理器）**
**职责**：
- 统一管理 WebGL 层和 Canvas 层
- 提供分层渲染接口
- 支持自定义层插入（六边形边界、分区标识）
- 层级优先级管理

**关键机制**：
```
Layer Stack:
├── Interaction Layer (sigma-mouse)     # 最顶层：交互
├── Custom HTML Layer                   # 可插入：自定义标签、按钮
├── Hover Layer (WebGL + Canvas)        # 悬停高亮
├── Label Layer (Canvas)                # 节点标签
├── Node Layer (WebGL)                  # 节点
├── Edge Layer (WebGL)                  # 边
└── Background Layer (Canvas/SVG)       # 最底层：六边形边界、分区
```

**核心思考**：
- **六边形分区（Zoom）渲染在 Background Layer**，使用 Canvas 或 SVG
- **节点/边的显隐不影响层结构**，只影响数据传递
- **LOD 控制通过 LayerManager 决定哪些层参与渲染**

---

#### **1.3 RenderScheduler（按需渲染调度器）**
**职责**：
- 管理渲染队列
- 按优先级调度渲染任务
- 防止渲染过载（帧率控制）
- 支持增量渲染
- **严格控制数据进入，避免大量节点同时渲染**

**核心策略**：
1. **视口裁剪**：只渲染视口内 + 周边缓冲区的节点
2. **手动LOD控制**：
   - **六边形边界模式**：只渲染六边形边界，内部不渲染任何节点
   - **六边形内部模式**：渲染边界 + 内部所有节点（根据展开状态）
   - **切换方式**：通过六边形边界上的手动按钮控制
3. **延迟渲染**：非关键内容（如标签）延后渲染
4. **批量更新**：合并多个数据变更为一次渲染（防抖 16ms）

**关键概念重新定义**：
- **六边形激活状态**：决定是否渲染内部节点（手动控制）
- **节点展开状态**：决定子节点的显示（独立于六边形激活）
- **数据加载状态**：数据是否在内存中（严格按需）

**类型系统设计**：
```typescript
// 导入官方类型
import type { Settings } from 'sigma/settings'

// 渲染状态严格类型定义
interface RenderState {
  // 六边形激活状态（手动控制）
  readonly zoomActivatedRegions: Set<string>  // 激活的六边形ID集合
  // 节点展开状态（独立控制）
  readonly expandedNodes: Set<string>         // 展开的节点ID集合
  // 视口状态
  readonly viewport: {
    readonly center: { readonly x: number; readonly y: number }
    readonly zoom: number
    readonly visibleBounds: BoundingBox
  }
}

// 渲染调度配置
interface RenderSchedulerConfig {
  readonly maxNodesPerFrame: number          // 每帧最大节点数（严格限制）
  readonly renderBatchSize: number           // 批量渲染大小
  readonly frameRateLimit: number            // 帧率限制
  readonly enableViewportCulling: boolean    // 视口裁剪开关
}

// 边界框类型
interface BoundingBox {
  readonly minX: number
  readonly maxX: number  
  readonly minY: number
  readonly maxY: number
}

// 批量更新管理
class BatchUpdateManager {
  private pendingUpdates: Map<string, NodeDisplayData> = new Map()
  private updateScheduled = false
  private readonly batchDelay = 16  // 一帧的时间（60fps）
  
  queueNodeUpdate(nodeId: string, update: Partial<NodeDisplayData>): void {
    const existing = this.pendingUpdates.get(nodeId)
    this.pendingUpdates.set(nodeId, {
      ...existing,
      ...update
    })
    this.scheduleBatchUpdate()
  }
  
  private scheduleBatchUpdate(): void {
    if (this.updateScheduled) return
    this.updateScheduled = true
    
    requestAnimationFrame(() => {
      this.flushUpdates()
      this.updateScheduled = false
    })
  }
}
```

**渲染决策逻辑**：
1. **六边形未激活**：只渲染边界，内部节点完全不传给Sigma
2. **六边形已激活**：渲染边界 + 内部节点（按展开状态）
3. **节点展开独立**：在激活的六边形内，展开的节点显示子节点，未展开的不显示
4. **增量渲染**：仅更新变更节点，使用批量更新防抖机制

---

#### **1.4 DataLoader（异步数据加载器）**
**职责**：
- 按需加载图数据
- 支持分块加载（Chunk-based）
- 数据预取策略
- 支持多种数据源（JSON、Gun、SQLite）

**加载策略**：
```
数据加载三级结构：
├── Hot Data (内存)      # 当前视口 + 已展开节点
├── Warm Data (缓存)     # 相邻节点、预加载数据
└── Cold Data (存储)     # 数据库/文件系统
```

**关键思考**：
- **异步加载不阻塞 UI**：使用 Web Worker 处理数据转换
- **数据分块策略**：
  - 按 Zoom 分块（模组维度）
  - 按层级分块（父子关系）
  - 按视口分块（空间维度）
- **预加载策略**：
  - 展开节点时，预加载其子节点的兄弟节点
  - 移动视口时，预加载方向前方的数据

---

#### **1.5 ViewportManager（视口管理器）**
**职责**：
- 管理缩放、平移状态
- 计算可见区域
- **提供视口信息给手动LOD控制系统**
- 性能监控（FPS）
- 视口裁剪计算

**手动LOD支持机制**：
```typescript
// ViewportManager 不触发自动LOD，只提供信息
interface ViewportInfo {
  readonly currentZoom: number
  readonly center: { readonly x: number; readonly y: number }
  readonly visibleBounds: BoundingBox
  readonly visibleRegions: string[]  // 当前视口内的六边形ID列表
}
```

**核心功能**：
1. **视口状态管理**：跟踪用户的缩放、平移操作
2. **可见区域计算**：计算当前视口覆盖哪些六边形区域
3. **性能监控**：监控FPS，为渲染调度提供性能数据
4. **视口裁剪支持**：为RenderScheduler提供裁剪边界

**类型系统设计**：
```typescript
// 导入官方类型
import type { Camera } from 'sigma/types'

// 视口管理器配置
interface ViewportManagerConfig {
  readonly minZoom: number
  readonly maxZoom: number
  readonly enableInertia: boolean
  readonly cullingMargin: number  // 视口裁剪边距
}

// 视口变化事件
interface ViewportChangeEvent {
  readonly type: 'zoom' | 'pan' | 'resize'
  readonly viewport: ViewportInfo
  readonly visibleRegions: ReadonlySet<string>
}
```

**与LOD系统的关系**：
- ViewportManager **不会**自动触发LOD切换
- ViewportManager **只提供**视口信息给插件使用
- LOD切换完全由**用户手动操作**（六边形按钮）决定
---

#### **1.6 EventBus（事件总线）**
**职责**：
- 插件间通信
- 系统事件分发
- 支持事件优先级
- **严格控制数据流，确保按需加载**

**核心事件（严格类型定义）**：
```typescript
// 导入官方事件类型
import type { SigmaEventPayload } from 'sigma/types'

// 渲染事件
interface RenderEvents {
  'render:beforeRender': { nodeCount: number; regionId?: string }
  'render:afterRender': { renderTime: number; nodeCount: number }
  'render:nodeCountExceeded': { attemptedCount: number; maxAllowed: number }
}

// 交互事件（区分六边形激活和节点展开）
interface InteractionEvents {
  'node:click': { nodeId: string; position: { x: number; y: number } }
  'node:doubleClick': { nodeId: string }
  'node:expand': { nodeId: string; childrenIds: string[] }      // 展开子节点（数据已准备）
  'node:collapse': { nodeId: string; childrenIds: string[] }   // 收起子节点（立即移除数据）
  'region:activate': { regionId: string; nodeIds: string[] }   // 激活六边形（数据已准备）
  'region:deactivate': { regionId: string; nodeIds: string[] } // 关闭六边形（立即移除数据）
}

// 严格的数据事件（性能保证）
interface DataEvents {
  'data:childrenPrepared': { parentId: string; children: NodeData[] }      // 子节点数据已准备好
  'data:regionPrepared': { regionId: string; nodes: NodeData[] }           // 区域数据已准备好
  'data:nodeRemoved': { nodeIds: string[] }                                // 节点已从内存移除
  'data:loadingStarted': { type: 'children' | 'region'; targetId: string } // 开始加载（禁止重复触发）
  'data:loadingCompleted': { type: 'children' | 'region'; targetId: string }
}
```

**严格的性能保证机制**：

**1. 数据预准备原则**：
- **展开节点前**：子节点数据必须已在内存中（`data:childrenPrepared`）
- **激活六边形前**：区域数据必须已在内存中（`data:regionPrepared`）
- **用户点击时**：绝对不允许等待数据加载或转换

**2. 数据量严格限制**：
```typescript
interface DataConstraints {
  readonly MAX_NODES_PER_INTERACTION: 500    // 单次交互最大节点数
  readonly MAX_CHILDREN_PER_NODE: 50         // 单个节点最大子节点数
  readonly MAX_NODES_PER_REGION: 2000        // 单个六边形最大节点数
  readonly PRELOAD_BATCH_SIZE: 100           // 预加载批次大小
}
```

**3. 立即响应保证**：
- 用户交互 → 数据已准备 → 立即渲染（< 16ms）
- 严禁：用户交互 → 数据加载 → 数据转换 → 渲染
- 所有数据加载都在**后台预进行**，不阻塞用户操作

**4. 内存管理**：
- 节点收起时，子节点数据**立即从内存移除**
- 六边形关闭时，内部节点数据**立即从内存移除**
- 保持内存中节点数量在合理范围内（< 5000个活跃节点）

---

#### **1.7 PluginRegistry（插件注册中心）**
**职责**：
- 插件生命周期管理
- 插件依赖解析
- 插件隔离

**插件接口（严格类型定义）**：
```typescript
// 导入官方类型作为基础约束
import type { Settings } from 'sigma/settings'
import type { NodeDisplayData, EdgeDisplayData } from 'sigma/types'

// 插件基础接口
interface StarChartPlugin {
  readonly id: string
  readonly name: string
  readonly version: string
  readonly description?: string
  
  // 生命周期钩子（严格类型）
  install(core: StarChartCore): Promise<void> | void
  uninstall(): Promise<void> | void
  
  // 可选：插件依赖（严格版本控制）
  readonly dependencies?: ReadonlyArray<{
    readonly pluginId: string
    readonly minVersion: string
    readonly maxVersion?: string
  }>
  
  // 插件配置（严禁any）
  readonly config?: Readonly<Record<string, string | number | boolean>>
}

// 扩展的插件类型
interface LayoutPlugin extends StarChartPlugin {
  readonly type: 'layout'
  computeLayout(
    nodes: ReadonlyArray<NodeDisplayData>, 
    edges: ReadonlyArray<EdgeDisplayData>
  ): Promise<LayoutResult>
  updateLayout(changedNodes: ReadonlyArray<string>): Promise<void>
  readonly layoutConfig: Readonly<LayoutConfig>
}

interface RenderPlugin extends StarChartPlugin {
  readonly type: 'renderer'
  readonly renderLayers: ReadonlyArray<'webgl' | 'canvas' | 'svg' | 'html'>
  render(context: RenderContext): Promise<void>
  readonly renderConfig: Readonly<RenderConfig>
}

interface InteractionPlugin extends StarChartPlugin {
  readonly type: 'interaction'
  readonly handledEvents: ReadonlyArray<string>
  handleEvent(event: StarChartEvent): Promise<boolean>  // 返回是否阻止事件冒泡
  readonly interactionConfig: Readonly<InteractionConfig>
}

// 配置类型严格定义
interface LayoutConfig {
  readonly algorithm: 'force' | 'hierarchy' | 'grid' | 'custom'
  readonly nodeSpacing: number
  readonly edgeLength: number
  readonly iterations: number
  readonly enableClustering: boolean
}

interface RenderConfig {
  readonly maxNodesPerLayer: number
  readonly enableWebGL: boolean
  readonly enableCanvas: boolean
  readonly antiAliasing: boolean
}

interface InteractionConfig {
  readonly enableNodeDrag: boolean
  readonly enableZoom: boolean
  readonly enablePan: boolean
  readonly doubleClickDelay: number
}
```

---

### **第二层：插件层（Plugins）**

这是场景相关的、可插拔的功能模块。

```
StarChart Plugins/
├── Layout Plugins/            # 布局插件
│   ├── HierarchyLayout        # 层级树布局（父子关系）
│   ├── ForceDirectedLayout    # 力导向布局
│   └── RecipeGraphLayout      # 配方图专用布局
│
├── Interaction Plugins/       # 交互插件
│   ├── ExpandCollapsePlugin   # 展开/收起
│   ├── ZoomControlPlugin      # 六边形激活控制
│   └── DragNavigationPlugin   # 拖拽导航
│
├── Renderer Plugins/          # 渲染插件
│   ├── NodeStylePlugin        # 节点样式（边框、颜色）
│   ├── EdgeStylePlugin        # 边样式（平台标识）
│   └── LabelPlugin            # 标签渲染
│
├── LOD Plugins/               # LOD插件
│   ├── ZoomBoundaryPlugin     # 六边形边界渲染
│   ├── LayeredRenderPlugin    # 分层渲染控制
│   └── DynamicVisibilityPlugin # 动态显隐
│
└── Data Adapter Plugins/      # 数据适配器
    ├── RecipeDataAdapter      # 配方数据适配
    ├── NovelDataAdapter       # 小说设定适配
    └── GenericGraphAdapter    # 通用图数据适配
```

---

## 🎯 针对您场景的具体方案

### **场景一：MC 配方图（30000+ 节点）**

#### **插件组合**：
```
RecipeGraphLayout           # 布局算法
+ ExpandCollapsePlugin      # 展开/收起交互
+ ZoomBoundaryPlugin        # 九十多个模组的六边形边界
+ RecipeDataAdapter         # 配方数据适配
+ EdgeStylePlugin           # 边上显示合成平台
```

#### **数据结构设计**：

```typescript
// 数据分块策略
interface RecipeGraphData {
  // 模组级别（Zoom 分区）
  mods: ModData[]
  
  // 全局拓扑信息（用于快速查询）
  topology: {
    topLevel: string[]      // 顶层物品ID
    bottomLevel: string[]   // 底层物品ID
    loops: string[][]       // 循环配方组
  }
}

interface ModData {
  id: string              // 模组ID
  name: string
  boundary: HexagonShape  // 六边形边界信息
  
  // 分层数据（按需加载）
  nodes: {
    internal: RecipeNode[]     // 模组内部节点
    boundary: RecipeNode[]     // 边界节点
  }
  edges: RecipeEdge[]
  
  // 是否已激活渲染
  activated: boolean
}

// 严格类型定义，导入官方约束
interface RecipeNode {
  readonly id: string
  readonly name: string
  readonly type: 'top' | 'bottom' | 'loop' | 'regular'  // 改为 regular（常规/中间节点）
  readonly hasChildren: boolean      // 是否有子节点（决定是否显示边框样式）
  readonly expanded: boolean         // 当前展开状态（独立于hasChildren）
  readonly children?: ReadonlyArray<string>  // 子节点ID（懒加载）
  readonly position?: { readonly x: number; readonly y: number }  // 节点位置
  readonly metadata?: Readonly<Record<string, unknown>>          // 额外元数据（严禁any）
}

/**
 * 节点类型说明：
 * - **top（顶层）**：没有父节点的配方，是合成树的起点
 * - **bottom（底层）**：没有子节点的配方，通常是原材料
 * - **loop（循环）**：参与循环配方的节点，**不需要展开功能**，初始就全部显示在椭圆上
 *   - 循环节点不支持展开/收起
 *   - 初始布局时放在随机椭圆上（椭圆参数随机：radiusX 100-180, radiusY 80-140）
 *   - 放在空旷区域，与顶层/常规节点保持稀疏距离
 * - **regular（常规）**：既有父也有子的中间配方节点，支持展开/收起
 *
 * expanded 字段说明：
 * - 独立于 hasChildren，明确表达当前展开状态
 * - hasChildren=true 但 expanded=false：有能力展开但未展开
 * - expanded=true：当前已展开，子节点在内存中并可见
 */

// 边数据严格类型定义
interface RecipeEdge {
  readonly id: string
  readonly source: string
  readonly target: string
  readonly platform: string           // 合成平台ID（数据存储）
  readonly weight: number
  readonly platformLabel?: string     // 平台显示名称（按需渲染，悬浮时获取）
  readonly labelVisible: boolean      // 标签是否可见（手动控制）
  readonly metadata?: Readonly<Record<string, unknown>>  // 额外元数据（严禁any）
}

// 边标签按需渲染配置
interface EdgeLabelConfig {
  readonly enableHoverLabels: boolean    // 悬浮显示标签
  readonly enableClickLabels: boolean    // 点击显示标签
  readonly labelFetchDelay: number       // 标签获取延迟（ms）
  readonly maxVisibleLabels: number      // 最大可见标签数
}
```

#### **渲染策略**：

**Level 0（zoom < 0.5）**：
- 只渲染 90 个六边形边界
- 每个六边形中心显示模组名称
- 渲染跨模组的连线（高层抽象）

**Level 1（0.5 ≤ zoom < 1）**：
- 渲染六边形边界
- 渲染顶层物品节点（无父节点）
- 渲染循环配方组（闭环）
- **底层物品不渲染**
- 有子节点的节点显示特殊边框样式

**Level 2（zoom ≥ 1，六边形未激活）**：
- 保持 Level 1 的渲染
- 支持双击节点展开子节点
- 展开的子节点使用力导向布局避免叠加

**Level 3（六边形已激活）**：
- 激活后，渲染六边形内部的所有节点
- 使用独立的布局算法（内部布局）
- 边上显示合成平台图标

---


### **展开/收起交互**：

**方案 A：双击节点**
- 优点：简单直观
- 缺点：可能与其他交互冲突

**方案 B：节点旁边的按钮**
- 优点：明确可见
- 缺点：增加渲染负担

**推荐混合方案**：
- **默认**：双击展开/收起
- **Hover 时**：显示 `[+]` / `[-]` 按钮（Canvas Layer）
- **性能模式**：仅双击（不显示按钮）

---

### **六边形激活交互**：

**方案 A：固定按钮（开发调试）**
- 顶部工具栏："激活所有模组"按钮

**方案 B：光圈动画（生产环境）**
- 鼠标移入六边形：向外扩散的光圈
- 鼠标移出：向内收缩的光圈
- 点击：切换激活状态

---

## 📊 总结：系统与插件的边界

### **系统基建（StarChart Core）负责**：
✅ **Sigma.js 封装** - 提供统一的渲染引擎接口
✅ **层管理** - WebGL/Canvas/SVG/HTML 层的统一管理
✅ **按需渲染调度** - 严格的性能控制和渲染队列管理
✅ **异步数据加载** - 数据预准备和内存管理
✅ **事件总线** - 严格类型的插件间通信
✅ **插件注册** - 插件生命周期和依赖管理
✅ **状态管理** - 全局状态和视口状态管理
✅ **扩展点API** - 为复杂插件提供深度定制接口
✅ **类型约束** - 导入官方类型，严禁any类型

### **插件负责**：
✅ **布局算法** - 具体的节点位置计算逻辑
✅ **交互逻辑** - 节点展开/收起、六边形激活等用户交互
✅ **样式定义** - 节点/边的视觉样式和主题
✅ **数据适配** - 不同数据源到标准格式的转换
✅ **场景特定策略** - 如MC配方图的分层逻辑、小说关系图的聚类逻辑
✅ **自定义渲染** - 通过扩展点添加六边形边界、特殊标签等
✅ **手动LOD控制** - 决定何时激活/关闭特定区域的渲染

### **关键设计原则**：
1. **Core保持通用性** - 不包含场景特定逻辑
2. **插件享有足够灵活性** - 通过扩展点深度定制Core行为  
3. **严格类型约束** - 所有接口都有明确类型，利用官方类型作为基础
4. **性能优先** - 数据必须预准备，用户交互必须立即响应
5. **按需原则** - 数据按需加载，节点按需渲染，功能按需激活

---

## 🚀 性能优化架构（10000+ 节点支持）

### **核心瓶颈分析**：
1. **空间查询** - O(n)：找最空旷区域需要遍历所有节点
2. **方向选择** - O(n)：每次展开要计算所有附近节点的扇区密度
3. **视口裁剪** - O(n+m)：确定可见节点/边
4. **边悬浮检测** - O(m)：鼠标移动时检测点击的边
5. **布局计算** - 阻塞主线程：耗时的位置计算锁定UI

### **优化方案 1：空间索引 - 四叉树（Quadtree）**

```typescript
// 四叉树节点
class QuadTreeNode {
  private readonly bounds: BoundingBox
  private readonly capacity = 10
  private points: Array<{ node: RecipeNode; position: Position }> = []
  private divided = false
  private children?: QuadTreeNode[]
  
  // 插入节点 O(log n)
  insert(node: RecipeNode, position: Position): boolean {
    if (!this.contains(position)) return false
    
    if (this.points.length < this.capacity) {
      this.points.push({ node, position })
      return true
    }
    
    if (!this.divided) this.subdivide()
    return this.children!.some(child => child.insert(node, position))
  }
  
  // 查询范围内的节点 O(log n) 平均
  queryRange(range: BoundingBox): RecipeNode[] {
    const found: RecipeNode[] = []
    if (!this.intersects(range)) return found
    
    for (const { node, position } of this.points) {
      if (this.pointInRange(position, range)) found.push(node)
    }
    
    if (this.divided) {
      for (const child of this.children!) {
        found.push(...child.queryRange(range))
      }
    }
    return found
  }
  
  // 查询圆形范围内的节点
  queryCircle(center: Position, radius: number): RecipeNode[] {
    const range: BoundingBox = {
      minX: center.x - radius,
      maxX: center.x + radius,
      minY: center.y - radius,
      maxY: center.y + radius
    }
    
    const candidates = this.queryRange(range)
    return candidates.filter(node => {
      if (!node.position) return false
      const dx = node.position.x - center.x
      const dy = node.position.y - center.y
      return dx * dx + dy * dy <= radius * radius
    })
  }
}

// 空间索引管理器
class SpatialIndex {
  private quadTree: QuadTreeNode
  
  findSparsestRegion(searchRadius: number = 500): Position {
    // 采样策略：只采样有限点，不遍历全部
    const sampleCount = 20
    let minDensity = Infinity
    let bestPosition: Position = { x: 0, y: 0 }
    
    for (let i = 0; i < sampleCount; i++) {
      const angle = (Math.PI * 2 * i) / sampleCount
      const distance = 300 * (1 + Math.floor(i / 8))
      
      const candidate = {
        x: Math.cos(angle) * distance,
        y: Math.sin(angle) * distance
      }
      
      // 使用四叉树快速查询 O(log n)
      const nearbyNodes = this.quadTree.queryCircle(candidate, searchRadius)
      const density = nearbyNodes.length
      
      if (density < minDensity) {
        minDensity = density
        bestPosition = candidate
      }
    }
    
    return bestPosition
  }
  
  findSparsestDirection(parentPos: Position, checkRadius: number): number {
    const sectorCount = 12
    const sectorDensity = new Array(sectorCount).fill(0)
    
    // 只查询附近的节点，不是全部（O(log n) vs O(n)）
    const nearbyNodes = this.quadTree.queryCircle(parentPos, checkRadius * 2)
    
    nearbyNodes.forEach(node => {
      if (!node.position) return
      
      const dx = node.position.x - parentPos.x
      const dy = node.position.y - parentPos.y
      const distance = Math.sqrt(dx * dx + dy * dy)
      
      if (distance < 10) return
      
      const angle = Math.atan2(dy, dx)
      const sectorIndex = Math.floor(
        ((angle + Math.PI) / (Math.PI * 2)) * sectorCount
      ) % sectorCount
      
      const weight = 1 / (distance / checkRadius)
      sectorDensity[sectorIndex] += weight
    })
    
    let minDensity = Infinity
    let sparsestSector = 0
    
    sectorDensity.forEach((density, i) => {
      if (density < minDensity) {
        minDensity = density
        sparsestSector = i
      }
    })
    
    return (sparsestSector / sectorCount) * Math.PI * 2 - Math.PI
  }
}
```

**性能提升**：查找空旷区域从 O(n) 降到 O(log n × 采样数) ≈ O(1)

### **优化方案 2：视口裁剪 + 增量渲染**

```typescript
// 视口裁剪管理器
class ViewportCullingManager {
  private visibleNodes = new Set<string>()
  private lastViewport: ViewportInfo | null = null
  
  updateVisibleNodes(viewport: ViewportInfo): void {
    // 检查视口是否显著变化（避免频繁更新）
    if (this.lastViewport && !this.viewportChangedSignificantly(viewport)) {
      return
    }

    // 扩展视口边界（缓冲区）
    const buffer = 200
    const expandedBounds: BoundingBox = {
      minX: viewport.visibleBounds.minX - buffer,
      maxX: viewport.visibleBounds.maxX + buffer,
      minY: viewport.visibleBounds.minY - buffer,
      maxY: viewport.visibleBounds.maxY + buffer
    }
    
    // 使用四叉树快速查询可见节点
    const visibleNodes = this.spatialIndex.queryRange(expandedBounds)
    
    this.visibleNodes.clear()
    visibleNodes.forEach(node => this.visibleNodes.add(node.id))
    
    this.applyVisibilityFilter()
  }
  
  private viewportChangedSignificantly(newViewport: ViewportInfo): boolean {
    if (!this.lastViewport) return true
    
    const zoomChange = Math.abs(newViewport.zoom - this.lastViewport.zoom)
    const panChangeX = Math.abs(newViewport.center.x - this.lastViewport.center.x)
    const panChangeY = Math.abs(newViewport.center.y - this.lastViewport.center.y)
    
    // 缩放变化超过10%，或平移超过100px
    return zoomChange > 0.1 || panChangeX > 100 || panChangeY > 100
  }
}
```

### **优化方案 3：Web Worker 布局计算**

```typescript
// 布局Worker池
class LayoutWorkerPool {
  private workers: Worker[] = []
  
  async computeLayoutAsync(
    nodes: RecipeNode[],
    edges: RecipeEdge[]
  ): Promise<Map<string, Position>> {
    return new Promise((resolve, reject) => {
      const worker = this.getAvailableWorker()
      
      worker.postMessage({
        type: 'compute-layout',
        nodes: nodes.map(n => ({ id: n.id, position: n.position })),
        edges: edges.map(e => ({ source: e.source, target: e.target }))
      })
      
      worker.onmessage = (event) => {
        if (event.data.type === 'layout-result') {
          resolve(new Map(Object.entries(event.data.positions)))
        }
      }
    })
  }
}

// Worker代码 - 后台计算，不阻塞主线程
self.onmessage = (event) => {
  if (event.data.type === 'compute-layout') {
    const { nodes, edges } = event.data
    
    // 在Worker中执行耗时的布局计算
    const positions = computeHierarchyLayout(nodes, edges)
    
    self.postMessage({
      type: 'layout-result',
      positions: Object.fromEntries(positions)
    })
  }
}
```

---

## 🎯 线程跟踪系统（布局计算进度监控）

### **任务跟踪核心**

```typescript
// 任务类型枚举
enum LayoutTaskType {
  NODE_EXPAND = 'node-expand',           // 节点展开布局
  LOOP_LAYOUT = 'loop-layout',           // 循环组布局
  REGION_ACTIVATE = 'region-activate',   // 六边形激活布局
  FORCE_ADJUST = 'force-adjust'          // 力导向微调
}

// 任务定义
interface LayoutTask {
  readonly id: string
  readonly type: LayoutTaskType
  readonly name: string
  readonly workerId?: number
  
  status: 'queued' | 'running' | 'completed' | 'failed' | 'cancelled'
  progress: number                     // 0-100
  
  readonly totalSteps: number
  currentStep: number
  
  readonly createdAt: number
  startedAt?: number
  completedAt?: number
  
  readonly metadata: {
    readonly nodeCount?: number
    readonly targetNodeId?: string
    [key: string]: unknown
  }
}

// 任务跟踪器
class LayoutTaskTracker {
  private tasks = new Map<string, LayoutTask>()
  private listeners = new Set<(event: string, task: LayoutTask) => void>()
  
  createTask(
    type: LayoutTaskType,
    name: string,
    totalSteps: number,
    metadata: Record<string, unknown> = {}
  ): string {
    const taskId = `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
    
    const task: LayoutTask = {
      id: taskId,
      type,
      name,
      status: 'queued',
      progress: 0,
      totalSteps,
      currentStep: 0,
      createdAt: Date.now(),
      metadata
    }
    
    this.tasks.set(taskId, task)
    this.notify('task-created', task)
    return taskId
  }
  
  startTask(taskId: string, workerId?: number): void {
    const task = this.tasks.get(taskId)
    if (!task) return
    
    task.status = 'running'
    task.startedAt = Date.now()
    if (workerId !== undefined) (task as any).workerId = workerId
    
    this.notify('task-started', task)
  }
  
  updateProgress(taskId: string, currentStep: number, message?: string): void {
    const task = this.tasks.get(taskId)
    if (!task) return
    
    task.currentStep = currentStep
    task.progress = Math.round((currentStep / task.totalSteps) * 100)
    if (message) (task.metadata as any).currentMessage = message
    
    this.notify('task-progress', task)
  }
  
  completeTask(taskId: string): void {
    const task = this.tasks.get(taskId)
    if (!task) return
    
    task.status = 'completed'
    task.progress = 100
    task.currentStep = task.totalSteps
    task.completedAt = Date.now()
    
    this.notify('task-completed', task)
    
    // 延迟清理已完成任务
    setTimeout(() => this.cleanupOldTasks(), 3000)
  }
  
  getActiveTasks(): LayoutTask[] {
    return Array.from(this.tasks.values()).filter(
      task => task.status === 'queued' || task.status === 'running'
    )
  }
  
  subscribe(listener: (event: string, task: LayoutTask) => void): () => void {
    this.listeners.add(listener)
    return () => this.listeners.delete(listener)
  }
  
  private notify(event: string, task: LayoutTask): void {
    this.listeners.forEach(listener => {
      try {
        listener(event, task)
  } catch (error) {
        console.error('Task listener error:', error)
      }
    })
  }
}

// 全局单例
export const taskTracker = new LayoutTaskTracker()
```

### **与Worker池集成**

```typescript
// 增强的Worker池，支持进度报告
class ProgressAwareLayoutWorkerPool {
  constructor(
    private taskTracker: LayoutTaskTracker,
    workerCount = navigator.hardwareConcurrency || 4
  ) {
    this.initializeWorkers(workerCount)
  }
  
  async submitTask(
    type: LayoutTaskType,
    data: LayoutTaskData
  ): Promise<LayoutResult> {
    // 1. 创建任务跟踪
    const taskId = this.taskTracker.createTask(
      type,
      this.getTaskName(type, data),
      this.estimateSteps(type, data),
      {
        nodeCount: data.nodes?.length,
        targetNodeId: data.targetNodeId
      }
    )
    
    // 2. 等待可用Worker
    const workerId = await this.waitForAvailableWorker()
    const worker = this.workers[workerId]
    
    this.taskTracker.startTask(taskId, workerId)
    
    // 3. 提交到Worker
    return new Promise((resolve, reject) => {
      const messageHandler = (event: MessageEvent) => {
        const { type: msgType, data: msgData } = event.data
        
        switch (msgType) {
          case 'progress':
            this.taskTracker.updateProgress(
              taskId,
              msgData.step,
              msgData.message
            )
            break
          case 'complete':
            this.taskTracker.completeTask(taskId)
            worker.removeEventListener('message', messageHandler)
            resolve(msgData.result)
            break
          case 'error':
            this.taskTracker.failTask(taskId, new Error(msgData.error))
            worker.removeEventListener('message', messageHandler)
            reject(new Error(msgData.error))
            break
        }
      }
      
      worker.addEventListener('message', messageHandler)
      worker.postMessage({ taskId, type, data })
    })
  }
  
  private estimateSteps(type: LayoutTaskType, data: LayoutTaskData): number {
    const nodeCount = data.nodes?.length || 0
    switch (type) {
      case LayoutTaskType.NODE_EXPAND:
        return Math.max(5, Math.ceil(nodeCount / 10))
      case LayoutTaskType.LOOP_LAYOUT:
        return Math.max(3, Math.ceil(nodeCount / 20))
      case LayoutTaskType.REGION_ACTIVATE:
        return Math.max(10, Math.ceil(nodeCount / 50))
      default:
        return 5
    }
  }
}
```

---

## 🔒 严格类型系统设计

### **类型导入策略**：

**1. 官方类型作为基础约束**：
```typescript
// Sigma.js 官方类型
import type { 
  Sigma, Graph, Settings, Camera,
  NodeDisplayData, EdgeDisplayData,
  NodeProgram, EdgeProgram,
  SigmaEventPayload 
} from 'sigma/types'

// Graphology 官方类型
import type { 
  Attributes, GraphType, MultiGraph,
  NodeKey, EdgeKey, GraphOptions 
} from 'graphology-types'

// WebGL 相关官方类型
import type { 
  WebGLRenderingContext, 
  WebGL2RenderingContext 
} from '@types/webgl2'
```

**2. 自定义类型严格规范**：
```typescript
// ✅ 正确：使用 readonly 和明确类型
interface StarChartNode {
  readonly id: string
  readonly name: string
  readonly position: { readonly x: number; readonly y: number }
  readonly metadata: Readonly<Record<string, string | number | boolean>>
}

// ❌ 错误：使用 any 或可变类型
interface BadNode {
  id: string
  data: any                    // 严禁！
  position: { x: number; y: number }  // 可变，不推荐
}
```

**3. 类型安全保证机制**：
- **编译时检查**：使用 TypeScript strict 模式
- **运行时验证**：关键接口使用 Zod 等库进行运行时验证
- **接口继承**：基于官方类型扩展，确保兼容性
- **泛型约束**：使用泛型确保类型参数的正确性

**4. 错误处理类型化**：
```typescript
// 严格的错误类型定义
type StarChartError = 
  | { type: 'PLUGIN_LOAD_FAILED'; pluginId: string; reason: string }
  | { type: 'DATA_LOAD_FAILED'; source: string; error: Error }
  | { type: 'RENDER_FAILED'; nodeCount: number; error: Error }
  | { type: 'MEMORY_EXCEEDED'; current: number; limit: number }

// 严格的结果类型
type LoadResult<T> = 
  | { success: true; data: T }
  | { success: false; error: StarChartError }
```

### **类型检查配置**：
```json
// tsconfig.json 严格配置
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true
  }
}
```

---

### **2.3 节点展开与复杂父子关系处理**

**展开布局算法**：

```typescript
// 节点展开管理器
class NodeExpansionManager {
  // 跟踪每个节点被哪些父节点展开了
  private expansionHistory = new Map<string, Set<string>>()
  
  async expandNode(parentId: string): Promise<void> {
    const parent = this.getNode(parentId)
    if (!parent.childrenIds) return
    
    // 1. 加载子节点数据（已预准备）
    const children = await this.loadChildren(parent.childrenIds)
    
    // 分类子节点：新节点 vs 已存在节点
    const { newChildren, existingChildren } = this.categorizeChildren(children)
    
    // 2. 处理新子节点：计算位置并添加
    if (newChildren.length > 0) {
      const newPositions = layoutExpandedChildren(
        parent,
        newChildren,
        this.nodesMap
      )
      
      newChildren.forEach(child => {
        const pos = newPositions.get(child.id)!
        this.addNode({ ...child, position: pos, visible: true })
      })
    }
    
    // 3. 处理已存在子节点：只添加边，不移动节点
    // ⚠️ 关键特性：如果子节点已被其他父节点展开，只添加新边，不移动
    existingChildren.forEach(child => {
      this.addEdge({
        id: `${parentId}-${child.id}`,
        source: parentId,
        target: child.id,
        type: 'crafting',
        // 长距离边使用更大曲率，让长边更明显
        curveConfig: this.computeLongDistanceCurve(
          parent.position!,
          child.position!
        )
      })
    })
    
    // 4. 记录展开历史
    children.forEach(child => {
      if (!this.expansionHistory.has(child.id)) {
        this.expansionHistory.set(child.id, new Set())
      }
      this.expansionHistory.get(child.id)!.add(parentId)
    })
    
    // 5. 触发渲染更新
    this.scheduleRender()
  }
  
  // 收起节点
  async collapseNode(parentId: string): Promise<void> {
    const parent = this.getNode(parentId)
    if (!parent.childrenIds) return
    
    parent.childrenIds.forEach(childId => {
      const expandedBy = this.expansionHistory.get(childId)
      if (!expandedBy) return
      
      // 移除当前父节点的展开记录
      expandedBy.delete(parentId)
      
      // 如果子节点不再被任何父节点展开，隐藏它
      if (expandedBy.size === 0) {
        this.hideNode(childId)
        this.recursiveHide(childId)  // 递归隐藏其子节点
      } else {
        // 子节点还被其他父节点展开，只删除这条边
        this.removeEdge(`${parentId}-${childId}`)
      }
    })
    
    this.scheduleRender()
  }
}

// 弧形分布算法（自动找最空旷方向）
function layoutExpandedChildren(
  parent: RecipeNode,
  children: ReadonlyArray<RecipeNode>,
  existingNodes: Map<string, RecipeNode>
): Map<string, Position> {
  const positions = new Map<string, Position>()
  const childCount = children.length
  
  // 展开半径：根据子节点数量自适应
  const radius = 120 + Math.min(childCount * 8, 80)
  
  // 弧的角度范围：120度到180度之间，根据子节点数量调整
  const arcAngle = Math.PI * (0.66 + childCount * 0.03)  // 120° - 180°
  
  // 找到最空旷的方向作为弧的中心方向
  const preferredDirection = findSparsestDirection(
    parent.position!,
    existingNodes,
    radius
  )
  
  // 在弧上均匀分布子节点
  children.forEach((child, i) => {
    const existingChild = existingNodes.get(child.id)
    
    if (existingChild && existingChild.position) {
      // 子节点已存在，不移动位置
      positions.set(child.id, existingChild.position)
    } else {
      // 新子节点，在弧上分布
      const angleOffset = (arcAngle / (childCount - 1 || 1)) * i - arcAngle / 2
      const angle = preferredDirection + angleOffset
      
      positions.set(child.id, {
        x: parent.position!.x + Math.cos(angle) * radius,
        y: parent.position!.y + Math.sin(angle) * radius
      })
    }
  })
  
  return positions
}

// 找到最空旷的方向（扇区密度分析）
function findSparsestDirection(
  parentPos: Position,
  existingNodes: Map<string, RecipeNode>,
  radius: number
): number {
  const sectorCount = 12  // 将360度分为12个扇区
  const sectorDensity = new Array(sectorCount).fill(0)
  
  // 计算每个扇区的节点密度
  existingNodes.forEach(node => {
    if (!node.position) return
    
    const dx = node.position.x - parentPos.x
    const dy = node.position.y - parentPos.y
    const distance = Math.sqrt(dx * dx + dy * dy)
    
    // 只考虑附近的节点（2倍半径内）
    if (distance < radius * 2 && distance > 10) {
      const angle = Math.atan2(dy, dx)
      const sectorIndex = Math.floor(
        ((angle + Math.PI) / (Math.PI * 2)) * sectorCount
      ) % sectorCount
      
      // 距离越近，密度权重越高
      const weight = 1 / (distance / radius)
      sectorDensity[sectorIndex] += weight
    }
  })
  
  // 找到密度最低的扇区
  let minDensity = Infinity
  let sparsestSector = 0
  
  sectorDensity.forEach((density, i) => {
    if (density < minDensity) {
      minDensity = density
      sparsestSector = i
    }
  })
  
  // 返回该扇区的中心角度
  return (sparsestSector / sectorCount) * Math.PI * 2 - Math.PI
}
```

---

### **2.4 边的方向和悬浮标签实现**

**边方向显示**（使用带箭头的曲线）：

```typescript
// 边配置：使用箭头显示方向
const edgeConfig = {
  defaultEdgeType: 'curvedArrow',  // 带箭头的曲线
  
  edgeProgramClasses: {
    curvedArrow: createEdgeCurveProgram({
      // 箭头配置
      arrowSize: 3,              // 箭头大小
      arrowPosition: 0.95,       // 箭头位置（95%处，接近目标节点）
      
      // 曲线配置
      curvature: (edge) => {
        const distance = calculateDistance(
          edge.sourcePosition,
          edge.targetPosition
        )
        // 短边曲率小，长边曲率大
        return 0.15 + Math.min(distance / 1000, 0.4)
      }
    })
  }
}
```

**边标签悬浮渲染**（自定义Canvas层）：

```typescript
// 自定义Canvas层：悬浮标签
class HoverLabelLayer implements CustomLayerDefinition {
  readonly id = 'hover-labels'
  readonly type = 'canvas'
  readonly zIndex = 1000  // 最顶层
  
  private hoveredEdge: RecipeEdge | null = null
  private mousePosition: { x: number; y: number } | null = null
  
  constructor(
    private sigma: Sigma,
    private eventBus: EventBus
  ) {
    // 监听边悬浮事件
    this.eventBus.on('edge:hover', this.handleEdgeHover.bind(this))
    this.eventBus.on('edge:leave', this.handleEdgeLeave.bind(this))
    this.eventBus.on('mouse:move', this.handleMouseMove.bind(this))
  }
  
  render(context: CanvasRenderingContext2D): void {
    if (!this.hoveredEdge || !this.mousePosition) return
    
    const platform = this.hoveredEdge.platform
    
    // 在光标旁边绘制平台名称（不固定位置，跟随光标）
    const labelX = this.mousePosition.x + 15  // 光标右侧15px
    const labelY = this.mousePosition.y - 10  // 光标上方10px
    
    // 绘制背景
    context.fillStyle = 'rgba(0, 0, 0, 0.8)'
    context.strokeStyle = '#4A90E2'
    context.lineWidth = 2
    
    const padding = 8
    const text = platform.name
    const metrics = context.measureText(text)
    const width = metrics.width + padding * 2
    const height = 24
    
    // 圆角矩形背景
    this.drawRoundedRect(context, labelX, labelY, width, height, 4)
    
    // 绘制文字
    context.fillStyle = '#FFFFFF'
    context.font = '12px "Segoe UI", sans-serif'
    context.textBaseline = 'middle'
    context.fillText(text, labelX + padding, labelY + height / 2)
  }
  
  destroy(): void {
    this.eventBus.off('edge:hover', this.handleEdgeHover)
    this.eventBus.off('edge:leave', this.handleEdgeLeave)
    this.eventBus.off('mouse:move', this.handleMouseMove)
  }
}

// 边的空间哈希索引（加速悬浮检测）
class EdgeSpatialHash {
  private cellSize = 50  // 网格大小50px
  private hash = new Map<string, Set<string>>()  // 网格 -> 边ID集合
  
  // 添加边到空间哈希
  addEdge(edge: RecipeEdge, sourcePos: Position, targetPos: Position): void {
    const cells = this.getEdgeCells(sourcePos, targetPos)
    cells.forEach(cellKey => {
      if (!this.hash.has(cellKey)) {
        this.hash.set(cellKey, new Set())
      }
      this.hash.get(cellKey)!.add(edge.id)
    })
  }
  
  // 快速查询鼠标位置附近的边 O(1) 平均
  queryEdgesNearPoint(point: Position, threshold: number = 10): string[] {
    const cellKey = this.getCellKey(point)
    const candidates = this.hash.get(cellKey) || new Set()
    
    // 也检查相邻网格
    const neighborKeys = this.getNeighborCells(cellKey)
    neighborKeys.forEach(key => {
      const neighbors = this.hash.get(key)
      if (neighbors) {
        neighbors.forEach(edgeId => candidates.add(edgeId))
      }
    })
    
    return Array.from(candidates)
  }
}
```

---

## 📋 完整系统总结与整合

### **架构三层概览**

**第一层：Core（系统基建）**
- **不变性原则**：通用、无场景特定逻辑
- **职责链**：SigmaManager → LayerManager → RenderScheduler → DataLoader
- **性能保障**：批量更新防抖、视口裁剪、增量渲染

**第二层：Plugins（场景插件）**
- **布局插件**：支持弧形分布、循环椭圆、空间索引加速
- **交互插件**：双击展开、六边形激活、长距离边处理
- **渲染插件**：箭头方向、悬浮标签、边的空间哈希检测

**第三层：Monitoring（进度监控）**
- **任务跟踪**：LayoutTaskTracker 动态创建/管理任务
- **Worker池集成**：进度报告、耗时统计、并发管理
- **UI展示**：活跃任务/完成历史、实时进度条

### **核心算法整合**

| 问题 | 原复杂度 | 优化后 | 核心改进 |
|------|--------|--------|----------|
| 找最空旷区域 | O(n) | O(1) | 四叉树采样 |
| 找展开方向 | O(n) | O(log n) | 四叉树范围查询 |
| 视口裁剪 | O(n+m) | O(log n) | 显著变化判定 + 四叉树 |
| 边悬浮检测 | O(m) | O(1) | 空间哈希网格 |
| 布局计算 | 阻塞主线程 | 非阻塞 | Web Worker后台 |
| 批量更新 | 每次操作渲染 | 16ms防抖 | requestAnimationFrame |

**综合性能提升**：万级节点从可能的数秒卡顿 → < 100ms 响应时间

### **关键特性整合**

**1. 节点类型的完整处理**
```
top（顶层）      循环（初始椭圆）  regular（展开弧）
    ↓                  ↓                    ↓
无父节点        不可展开         自适应弧 + 空旷方向
```

**2. 复杂父子关系**
- 已展开节点：不移动位置，只添加新边
- 新子节点：计算弧形位置，防止叠加
- 多父场景：追踪展开历史，智能隐藏

**3. 视觉反馈**
- 边方向：箭头指向目标节点（95%位置）
- 边标签：跟随光标悬浮显示，不固定位置
- 长距离边：自适应曲率，更明显的弧线

**4. 性能保障**
- 数据预准备：交互前数据已就绪 
- 立即响应：< 16ms 触发渲染
- 内存管理：活跃节点 < 5000，超出立即释放
- 实时监控：进度跟踪、任务队列、Worker负载

---

**Boss，全面整合完成，涵盖：**

✅ **核心架构** - 三层分明的系统设计
✅ **布局算法** - 循环节点、弧形展开、空间索引
✅ **复杂关系** - 多父多子、已存节点、展开历史
✅ **视觉设计** - 箭头方向、悬浮标签、自适应曲率
✅ **性能优化** - 四叉树、视口裁剪、Web Worker、空间哈希
✅ **进度监控** - 动态任务跟踪、实时进度条、Worker集成
✅ **严格类型** - 官方类型导入、readonly约束、类型安全

---
