# Nimbria æ•°æ®åº“ç³»ç»Ÿè®¾è®¡æ–‡æ¡£

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0  
**åˆ›å»ºæ—¶é—´**: 2025å¹´10æœˆ15æ—¥  
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ15æ—¥  
**è´Ÿè´£äºº**: Nimbria å¼€å‘å›¢é˜Ÿ

---

## ğŸ“‹ ç›®å½•

1. [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
2. [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
3. [æ•°æ®åº“ç»“æ„](#æ•°æ®åº“ç»“æ„)
4. [æœåŠ¡å±‚è®¾è®¡](#æœåŠ¡å±‚è®¾è®¡)
5. [è¿ç§»ç³»ç»Ÿ](#è¿ç§»ç³»ç»Ÿ)
6. [ç±»å‹ç³»ç»Ÿ](#ç±»å‹ç³»ç»Ÿ)
7. [é›†æˆæ–¹æ¡ˆ](#é›†æˆæ–¹æ¡ˆ)
8. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
9. [å®‰å…¨è€ƒè™‘](#å®‰å…¨è€ƒè™‘)
10. [éƒ¨ç½²ç­–ç•¥](#éƒ¨ç½²ç­–ç•¥)

---

## ğŸ¯ ç³»ç»Ÿæ¦‚è¿°

### è®¾è®¡ç›®æ ‡

Nimbriaæ•°æ®åº“ç³»ç»Ÿæ—¨åœ¨ä¸ºå°è¯´åˆ›ä½œå·¥å…·æä¾›é«˜æ•ˆã€å¯é çš„æœ¬åœ°æ•°æ®å­˜å‚¨è§£å†³æ–¹æ¡ˆï¼Œæ”¯æŒï¼š

- **é¡¹ç›®çº§æ•°æ®éš”ç¦»**: æ¯ä¸ªé¡¹ç›®æ‹¥æœ‰ç‹¬ç«‹çš„æ•°æ®åº“å®ä¾‹
- **ç‰ˆæœ¬åŒ–Schemaç®¡ç†**: æ”¯æŒæ•°æ®åº“ç»“æ„çš„æ¸è¿›å¼å‡çº§
- **äº‹ä»¶é©±åŠ¨æ¶æ„**: éµå¾ªNimbriaçš„EventEmitteræ¨¡å¼
- **TypeScriptåŸç”Ÿæ”¯æŒ**: æ‰€æœ‰Schemaå’Œè¿ç§»è„šæœ¬ä½¿ç”¨TypeScriptç¼–å†™
- **é«˜æ€§èƒ½æœ¬åœ°å­˜å‚¨**: åŸºäºSQLiteçš„WALæ¨¡å¼ä¼˜åŒ–

### æ ¸å¿ƒç‰¹æ€§

- âœ… **åŒå±‚æ•°æ®åº“æ¶æ„**: å…¨å±€æ•°æ®åº“ + é¡¹ç›®æ•°æ®åº“
- âœ… **TypeScriptåŒ–Schema**: æ‰€æœ‰æ•°æ®åº“å®šä¹‰ä½¿ç”¨.tsæ–‡ä»¶
- âœ… **è‡ªåŠ¨è¿ç§»ç³»ç»Ÿ**: æ”¯æŒç‰ˆæœ¬é—´çš„è‡ªåŠ¨å‡çº§å’Œå›æ»š
- âœ… **äº‹ä»¶é©±åŠ¨æ“ä½œ**: å¼‚æ­¥æ“ä½œé€šè¿‡äº‹ä»¶åé¦ˆçŠ¶æ€
- âœ… **ç±»å‹å®‰å…¨**: å®Œæ•´çš„TypeScriptç±»å‹å®šä¹‰
- âœ… **æ€§èƒ½ä¼˜åŒ–**: WALæ¨¡å¼ã€ç´¢å¼•ä¼˜åŒ–ã€è¿æ¥æ± ç®¡ç†

### ğŸ¯ äº‹ä»¶é©±åŠ¨æ¶æ„è¦æ±‚

**ä¸¥æ ¼éµå¾ª [äº‹ä»¶é©±åŠ¨æ¶æ„èŒƒå¼](../../../Workflow/äº‹ä»¶é©±åŠ¨æ¶æ„èŒƒå¼æ€»ç»“æ–‡æ¡£.md)**ï¼š

1. **Serviceå±‚çº¯å‡€**: DatabaseServiceç»§æ‰¿EventEmitterï¼Œåªè´Ÿè´£ä¸šåŠ¡é€»è¾‘
2. **ç«‹å³è¿”å›ID**: æ‰€æœ‰å¼‚æ­¥æ–¹æ³•ç«‹å³è¿”å›æ“ä½œIDï¼ˆinitIdã€operationIdã€migrationIdï¼‰
3. **äº‹ä»¶å‘å°„çŠ¶æ€**: é€šè¿‡`this.emit()`å‘å°„è¿›åº¦ã€å®Œæˆã€é”™è¯¯äº‹ä»¶
4. **IPCå±‚è–„è–„çš„**: IPC Handleråªç›‘å¬äº‹ä»¶å¹¶è½¬å‘ï¼Œä¸å‚ä¸ä¸šåŠ¡é€»è¾‘
5. **å‰ç«¯äº‹ä»¶ç›‘å¬**: Storeé€šè¿‡äº‹ä»¶ç›‘å¬å™¨æ›´æ–°æœ¬åœ°çŠ¶æ€
6. **å¤šçª—å£æ”¯æŒ**: äº‹ä»¶è‡ªåŠ¨å¹¿æ’­åˆ°æ‰€æœ‰çª—å£

**æ ¸å¿ƒåŸåˆ™**ï¼š
- âŒ ç¦æ­¢åœ¨å›è°ƒä¸­ä½¿ç”¨æœªè¿”å›çš„å€¼
- âœ… å¼‚æ­¥æ“ä½œä½¿ç”¨`setImmediate()`å»¶è¿Ÿæ‰§è¡Œ
- âœ… äº‹ä»¶ç›‘å¬å™¨åªåœ¨æ³¨å†Œæ—¶æ‰§è¡Œä¸€æ¬¡
- âœ… æ”¯æŒæ“ä½œè¿›åº¦åé¦ˆå’Œé”™è¯¯å¤„ç†

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾

```mermaid
graph TB
    subgraph "å‰ç«¯å±‚"
        A[Vueç»„ä»¶] --> B[Pinia Store]
        B --> C[IPCè°ƒç”¨]
    end
    
    subgraph "IPCé€šä¿¡å±‚"
        C --> D[Database Handlers]
    end
    
    subgraph "æœåŠ¡å±‚"
        D --> E[DatabaseService]
        E --> F[DatabaseManager]
        E --> G[MigrationManager]
        F --> H[ProjectDatabase]
    end
    
    subgraph "æ•°æ®å±‚"
        H --> I[é¡¹ç›®SQLite DB]
        F --> J[å…¨å±€SQLite DB]
    end
    
    subgraph "Schemaç®¡ç†"
        K[Schema Versions] --> E
        L[Migration Scripts] --> G
        M[Type Definitions] --> E
    end
```

### æ–‡ä»¶ç»“æ„è®¾è®¡

```
Nimbria/src-electron/services/database-service/
â”œâ”€â”€ database-service.ts              # ä¸»æœåŠ¡ç±»ï¼ˆEventEmitterï¼‰
â”œâ”€â”€ database-manager.ts              # æ•°æ®åº“è¿æ¥ç®¡ç†
â”œâ”€â”€ project-database.ts              # é¡¹ç›®çº§æ•°æ®åº“æ“ä½œ
â”œâ”€â”€ migration-manager.ts             # è¿ç§»ç®¡ç†å™¨
â”œâ”€â”€ schema/                          # Schemaå®šä¹‰
â”‚   â”œâ”€â”€ versions/                    # ç‰ˆæœ¬åŒ–Schema
â”‚   â”‚   â”œâ”€â”€ v1.0.0.schema.ts        # åŸºç¡€ç‰ˆæœ¬Schema
â”‚   â”‚   â”œâ”€â”€ v1.1.0.schema.ts        # æ–°ç‰ˆæœ¬Schema
â”‚   â”‚   â””â”€â”€ index.ts                # ç‰ˆæœ¬å¯¼å‡ºç®¡ç†
â”‚   â”œâ”€â”€ migrations/                  # è¿ç§»è„šæœ¬
â”‚   â”‚   â”œâ”€â”€ v1.0.0/
â”‚   â”‚   â”‚   â”œâ”€â”€ 001-initial.migration.ts
â”‚   â”‚   â”‚   â””â”€â”€ 002-indexes.migration.ts
â”‚   â”‚   â”œâ”€â”€ v1.1.0/
â”‚   â”‚   â”‚   â”œâ”€â”€ 003-user-preferences.migration.ts
â”‚   â”‚   â”‚   â””â”€â”€ 004-encryption-status.migration.ts
â”‚   â”‚   â””â”€â”€ registry.ts             # è¿ç§»æ³¨å†Œè¡¨
â”‚   â”œâ”€â”€ base-schema.ts              # åŸºç¡€Schemaç±»å‹
â”‚   â””â”€â”€ schema-config.ts            # Schemaé…ç½®
â”œâ”€â”€ types/                          # ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ database-v1.0.0.ts         # v1.0.0ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ database-v1.1.0.ts         # v1.1.0ç±»å‹å®šä¹‰
â”‚   â””â”€â”€ index.ts                    # ç±»å‹å¯¼å‡º
â””â”€â”€ utils/                          # å·¥å…·å‡½æ•°
    â”œâ”€â”€ backup.ts                   # å¤‡ä»½å·¥å…·
    â”œâ”€â”€ validation.ts               # æ•°æ®éªŒè¯
    â””â”€â”€ performance.ts              # æ€§èƒ½ç›‘æ§
```

---

## ğŸ—„ï¸ æ•°æ®åº“ç»“æ„

### åŒå±‚æ•°æ®åº“è®¾è®¡

#### 1. å…¨å±€æ•°æ®åº“ (`nimbria.db`)

**ä½ç½®**: `%USERDATA%/Database/nimbria.db`

**ç”¨é€”**: å­˜å‚¨åº”ç”¨çº§å…¨å±€æ•°æ®

```typescript
// å…¨å±€æ•°æ®åº“è¡¨ç»“æ„
export const GLOBAL_SCHEMA_TABLES = [
  // åº”ç”¨é…ç½®è¡¨
  {
    name: 'app_settings',
    sql: `CREATE TABLE IF NOT EXISTS app_settings (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      key TEXT UNIQUE NOT NULL,
      value TEXT,
      type TEXT DEFAULT 'string',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`
  },
  
  // æœ€è¿‘é¡¹ç›®è¡¨
  {
    name: 'recent_projects',
    sql: `CREATE TABLE IF NOT EXISTS recent_projects (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      project_path TEXT UNIQUE NOT NULL,
      project_name TEXT,
      last_opened DATETIME DEFAULT CURRENT_TIMESTAMP,
      open_count INTEGER DEFAULT 1,
      is_favorite BOOLEAN DEFAULT FALSE
    )`
  },
  
  // ç”¨æˆ·åå¥½è¡¨
  {
    name: 'user_preferences',
    sql: `CREATE TABLE IF NOT EXISTS user_preferences (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      category TEXT NOT NULL,
      key TEXT NOT NULL,
      value TEXT,
      type TEXT DEFAULT 'string',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      UNIQUE(category, key)
    )`
  }
]
```

#### 2. é¡¹ç›®æ•°æ®åº“ (`project.db`)

**ä½ç½®**: `{é¡¹ç›®æ ¹ç›®å½•}/.Database/project.db`

**ç”¨é€”**: å­˜å‚¨é¡¹ç›®ç‰¹å®šæ•°æ®

```typescript
// é¡¹ç›®æ•°æ®åº“è¡¨ç»“æ„
export const PROJECT_SCHEMA_V1_0_0 = [
  // é¡¹ç›®å…ƒæ•°æ®è¡¨
  {
    name: 'project_metadata',
    sql: `CREATE TABLE IF NOT EXISTS project_metadata (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      key TEXT UNIQUE NOT NULL,
      value TEXT,
      type TEXT DEFAULT 'string',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`
  },

  // æ–‡æ¡£è¡¨
  {
    name: 'documents',
    sql: `CREATE TABLE IF NOT EXISTS documents (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      path TEXT UNIQUE NOT NULL,
      title TEXT,
      content_hash TEXT,
      word_count INTEGER DEFAULT 0,
      character_count INTEGER DEFAULT 0,
      status TEXT DEFAULT 'draft',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      last_accessed DATETIME DEFAULT CURRENT_TIMESTAMP
    )`
  },

  // ç« èŠ‚è¡¨
  {
    name: 'chapters',
    sql: `CREATE TABLE IF NOT EXISTS chapters (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      document_id INTEGER,
      title TEXT NOT NULL,
      order_index INTEGER DEFAULT 0,
      word_count INTEGER DEFAULT 0,
      status TEXT DEFAULT 'draft',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE
    )`
  },

  // æ ‡ç­¾è¡¨
  {
    name: 'tags',
    sql: `CREATE TABLE IF NOT EXISTS tags (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT UNIQUE NOT NULL,
      color TEXT DEFAULT '#666666',
      description TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`
  },

  // æ–‡æ¡£æ ‡ç­¾å…³è”è¡¨
  {
    name: 'document_tags',
    sql: `CREATE TABLE IF NOT EXISTS document_tags (
      document_id INTEGER,
      tag_id INTEGER,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      PRIMARY KEY (document_id, tag_id),
      FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE,
      FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
    )`
  },

  // é¡¹ç›®ç»Ÿè®¡è¡¨
  {
    name: 'project_stats',
    sql: `CREATE TABLE IF NOT EXISTS project_stats (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      date TEXT NOT NULL,
      total_words INTEGER DEFAULT 0,
      total_characters INTEGER DEFAULT 0,
      documents_count INTEGER DEFAULT 0,
      chapters_count INTEGER DEFAULT 0,
      writing_time_minutes INTEGER DEFAULT 0,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`
  },

  // å†™ä½œä¼šè¯è¡¨
  {
    name: 'writing_sessions',
    sql: `CREATE TABLE IF NOT EXISTS writing_sessions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      document_id INTEGER,
      start_time DATETIME NOT NULL,
      end_time DATETIME,
      words_written INTEGER DEFAULT 0,
      characters_written INTEGER DEFAULT 0,
      session_type TEXT DEFAULT 'writing',
      notes TEXT,
      FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE
    )`
  }
]
```

### ç´¢å¼•ç­–ç•¥

```typescript
export const PROJECT_INDEXES = [
  // æ–‡æ¡£ç›¸å…³ç´¢å¼•
  `CREATE INDEX IF NOT EXISTS idx_documents_path ON documents(path)`,
  `CREATE INDEX IF NOT EXISTS idx_documents_status ON documents(status)`,
  `CREATE INDEX IF NOT EXISTS idx_documents_updated ON documents(updated_at)`,
  `CREATE INDEX IF NOT EXISTS idx_documents_word_count ON documents(word_count)`,
  
  // ç« èŠ‚ç›¸å…³ç´¢å¼•
  `CREATE INDEX IF NOT EXISTS idx_chapters_document ON chapters(document_id)`,
  `CREATE INDEX IF NOT EXISTS idx_chapters_order ON chapters(order_index)`,
  `CREATE INDEX IF NOT EXISTS idx_chapters_status ON chapters(status)`,
  
  // ç»Ÿè®¡ç›¸å…³ç´¢å¼•
  `CREATE INDEX IF NOT EXISTS idx_project_stats_date ON project_stats(date)`,
  `CREATE INDEX IF NOT EXISTS idx_writing_sessions_document ON writing_sessions(document_id)`,
  `CREATE INDEX IF NOT EXISTS idx_writing_sessions_start_time ON writing_sessions(start_time)`,
  
  // æ ‡ç­¾ç›¸å…³ç´¢å¼•
  `CREATE INDEX IF NOT EXISTS idx_tags_name ON tags(name)`,
  `CREATE INDEX IF NOT EXISTS idx_document_tags_document ON document_tags(document_id)`,
  `CREATE INDEX IF NOT EXISTS idx_document_tags_tag ON document_tags(tag_id)`
]
```

---

## âš™ï¸ æœåŠ¡å±‚è®¾è®¡

### DatabaseService (ä¸»æœåŠ¡ç±»)

**éµå¾ªäº‹ä»¶é©±åŠ¨æ¶æ„èŒƒå¼**ï¼šç»§æ‰¿EventEmitterï¼Œç«‹å³è¿”å›æ“ä½œIDï¼Œé€šè¿‡äº‹ä»¶å‘å°„çŠ¶æ€

```typescript
import { EventEmitter } from 'events'

// äº‹ä»¶æ•°æ®ç±»å‹å®šä¹‰
export interface DatabaseInitEvent {
  initId: string
  success?: boolean
}

export interface DatabaseProjectCreatedEvent {
  operationId: string
  projectPath: string
  databasePath: string
}

export interface DatabaseMigrationEvent {
  migrationId: string
  projectPath: string
  fromVersion: string
  toVersion: string
  progress?: number
}

export interface DatabaseErrorEvent {
  operationId?: string
  projectPath?: string
  error: string
}

export class DatabaseService extends EventEmitter {
  private databaseManager: DatabaseManager
  private migrationManager: MigrationManager
  private projectDatabases: Map<string, ProjectDatabase> = new Map()
  private isInitialized = false

  /**
   * âœ… äº‹ä»¶é©±åŠ¨æ–¹æ³•ï¼šç«‹å³è¿”å›initIdï¼Œé€šè¿‡äº‹ä»¶åé¦ˆçŠ¶æ€
   */
  async initialize(): Promise<string> {
    const initId = `init-${Date.now()}_${Math.random().toString(36).slice(2, 11)}`
    
    // ç«‹å³å‘å°„å¼€å§‹äº‹ä»¶
    this.emit('database:init-start', { initId } as DatabaseInitEvent)
    
    // å¼‚æ­¥å¤„ç†ï¼Œä¸é˜»å¡è¿”å›
    setImmediate(async () => {
      try {
        await this.databaseManager.initialize()
        await this.migrationManager.runBaseMigrations()
        
        this.isInitialized = true
        this.emit('database:init-complete', { initId, success: true } as DatabaseInitEvent)
      } catch (error) {
        this.emit('database:init-error', { 
          initId, 
          error: error instanceof Error ? error.message : String(error) 
        } as DatabaseErrorEvent)
      }
    })
    
    return initId
  }

  /**
   * âœ… äº‹ä»¶é©±åŠ¨æ–¹æ³•ï¼šç«‹å³è¿”å›operationIdï¼Œé€šè¿‡äº‹ä»¶åé¦ˆçŠ¶æ€
   */
  async createProjectDatabase(projectPath: string): Promise<string> {
    const operationId = `create-db-${Date.now()}_${Math.random().toString(36).slice(2, 11)}`
    
    // ç«‹å³å‘å°„å¼€å§‹äº‹ä»¶
    this.emit('database:project-create-start', { operationId, projectPath })
    
    // å¼‚æ­¥å¤„ç†
    setImmediate(async () => {
      try {
        if (!this.isInitialized) {
          throw new Error('Database service not initialized')
        }

        const databaseDir = path.join(projectPath, '.Database')
        await fs.ensureDir(databaseDir)
        
        const projectDb = new ProjectDatabase(projectPath, this.databaseManager)
        await projectDb.initialize()
        
        this.projectDatabases.set(projectPath, projectDb)
        
        this.emit('database:project-created', {
          operationId,
          projectPath,
          databasePath: path.join(databaseDir, 'project.db')
        } as DatabaseProjectCreatedEvent)
        
      } catch (error) {
        this.emit('database:project-error', {
          operationId,
          projectPath,
          error: error instanceof Error ? error.message : String(error)
        } as DatabaseErrorEvent)
      }
    })
    
    return operationId
  }

  /**
   * âœ… äº‹ä»¶é©±åŠ¨æ–¹æ³•ï¼šç«‹å³è¿”å›migrationIdï¼Œé€šè¿‡äº‹ä»¶åé¦ˆè¿›åº¦
   */
  async migrateProjectDatabase(projectPath: string, targetVersion: string): Promise<string> {
    const migrationId = `migrate-${Date.now()}_${Math.random().toString(36).slice(2, 11)}`
    
    // ç«‹å³å‘å°„å¼€å§‹äº‹ä»¶
    this.emit('database:migration-start', { 
      migrationId, 
      projectPath, 
      toVersion: targetVersion 
    } as DatabaseMigrationEvent)
    
    // å¼‚æ­¥å¤„ç†
    setImmediate(async () => {
      try {
        const projectDb = this.projectDatabases.get(projectPath)
        if (!projectDb) {
          throw new Error('Project database not found')
        }

        const currentVersion = await this.getCurrentVersion(projectDb)
        
        // å‘å°„è¿›åº¦äº‹ä»¶
        this.emit('database:migration-progress', {
          migrationId,
          projectPath,
          fromVersion: currentVersion,
          toVersion: targetVersion,
          progress: 50
        } as DatabaseMigrationEvent)
        
        await this.migrationManager.migrateToVersion(projectDb.getRawConnection(), targetVersion)
        
        // å‘å°„å®Œæˆäº‹ä»¶
        this.emit('database:migration-complete', {
          migrationId,
          projectPath,
          fromVersion: currentVersion,
          toVersion: targetVersion
        } as DatabaseMigrationEvent)
        
      } catch (error) {
        this.emit('database:migration-error', {
          migrationId,
          projectPath,
          error: error instanceof Error ? error.message : String(error)
        } as DatabaseErrorEvent)
      }
    })
    
    return migrationId
  }

  // åŒæ­¥æ–¹æ³•ï¼ˆä¸éœ€è¦äº‹ä»¶ï¼‰
  getProjectDatabase(projectPath: string): ProjectDatabase | null {
    return this.projectDatabases.get(projectPath) || null
  }

  async closeProjectDatabase(projectPath: string): Promise<void> {
    const projectDb = this.projectDatabases.get(projectPath)
    if (projectDb) {
      await projectDb.close()
      this.projectDatabases.delete(projectPath)
    }
  }

  async cleanup(): Promise<void> {
    for (const [projectPath, projectDb] of this.projectDatabases) {
      await projectDb.close()
    }
    this.projectDatabases.clear()
    await this.databaseManager.cleanup()
    this.isInitialized = false
  }

  private async getCurrentVersion(projectDb: ProjectDatabase): Promise<string> {
    // å®ç°è·å–å½“å‰ç‰ˆæœ¬é€»è¾‘
    return '1.0.0'
  }
}

// ç±»å‹å¢å¼º
declare interface DatabaseService {
  on<K extends keyof DatabaseServiceEvents>(
    event: K, 
    listener: (data: DatabaseServiceEvents[K]) => void
  ): this
  emit<K extends keyof DatabaseServiceEvents>(
    event: K, 
    data: DatabaseServiceEvents[K]
  ): boolean
}

export interface DatabaseServiceEvents {
  'database:init-start': DatabaseInitEvent
  'database:init-complete': DatabaseInitEvent
  'database:init-error': DatabaseErrorEvent
  'database:project-create-start': { operationId: string; projectPath: string }
  'database:project-created': DatabaseProjectCreatedEvent
  'database:project-error': DatabaseErrorEvent
  'database:migration-start': DatabaseMigrationEvent
  'database:migration-progress': DatabaseMigrationEvent
  'database:migration-complete': DatabaseMigrationEvent
  'database:migration-error': DatabaseErrorEvent
}
```

### DatabaseManager (è¿æ¥ç®¡ç†)

```typescript
export class DatabaseManager {
  private globalDb: Database.Database | null = null
  private projectDbs: Map<string, Database.Database> = new Map()

  // æ ¸å¿ƒæ–¹æ³•
  async initialize(): Promise<void>
  createProjectDatabase(projectPath: string): Database.Database
  getGlobalDatabase(): Database.Database
  getProjectDatabase(projectPath: string): Database.Database | null
  closeProjectDatabase(projectPath: string): void
  async cleanup(): Promise<void>
}
```

### ProjectDatabase (é¡¹ç›®æ•°æ®åº“æ“ä½œ)

```typescript
export class ProjectDatabase {
  private db: Database.Database | null = null
  private projectPath: string
  private databaseManager: DatabaseManager

  // åŸºç¡€æ“ä½œ
  query(sql: string, params?: unknown[]): unknown[]
  queryOne(sql: string, params?: unknown[]): unknown | null
  execute(sql: string, params?: unknown[]): Database.RunResult
  transaction<T>(fn: () => T): T
  
  // é«˜çº§æ“ä½œ
  async getDocuments(filter?: DocumentFilter): Promise<ProjectDocument[]>
  async createDocument(doc: Partial<ProjectDocument>): Promise<number>
  async updateDocument(id: number, updates: Partial<ProjectDocument>): Promise<void>
  async deleteDocument(id: number): Promise<void>
  
  // ç»Ÿè®¡æ“ä½œ
  async getProjectStats(dateRange?: DateRange): Promise<ProjectStats[]>
  async updateDailyStats(): Promise<void>
}
```

---

## ğŸ”„ è¿ç§»ç³»ç»Ÿ

### è¿ç§»è„šæœ¬ç»“æ„

```typescript
export interface MigrationDefinition {
  version: string
  fromVersion: string
  toVersion: string
  description: string
  steps: MigrationStep[]
}

export interface MigrationStep {
  type: 'CREATE_TABLE' | 'ALTER_TABLE' | 'DROP_TABLE' | 'CREATE_INDEX' | 'DROP_INDEX' | 'CUSTOM'
  sql: string
  rollback?: string
  description?: string
  validation?: (db: Database.Database) => boolean
}
```

### è¿ç§»ç¤ºä¾‹

```typescript
// schema/migrations/v1.1.0/003-add-encryption.migration.ts
export const ADD_ENCRYPTION_MIGRATION: MigrationDefinition = {
  version: '1.1.0',
  fromVersion: '1.0.0',
  toVersion: '1.1.0',
  description: 'æ·»åŠ æ–‡æ¡£åŠ å¯†æ”¯æŒ',
  steps: [
    {
      type: 'ALTER_TABLE',
      sql: `ALTER TABLE documents ADD COLUMN encryption_status TEXT DEFAULT 'none'`,
      rollback: `ALTER TABLE documents DROP COLUMN encryption_status`,
      description: 'ä¸ºdocumentsè¡¨æ·»åŠ åŠ å¯†çŠ¶æ€å­—æ®µ',
      validation: (db) => {
        const result = db.prepare(`PRAGMA table_info(documents)`).all()
        return result.some((col: any) => col.name === 'encryption_status')
      }
    },
    {
      type: 'CREATE_INDEX',
      sql: `CREATE INDEX IF NOT EXISTS idx_documents_encryption ON documents(encryption_status)`,
      rollback: `DROP INDEX IF EXISTS idx_documents_encryption`,
      description: 'ä¸ºåŠ å¯†çŠ¶æ€å­—æ®µåˆ›å»ºç´¢å¼•'
    }
  ]
}
```

### è¿ç§»ç®¡ç†å™¨

```typescript
export class MigrationManager extends EventEmitter {
  async migrateToVersion(db: Database.Database, targetVersion: string): Promise<string>
  async rollbackToVersion(db: Database.Database, targetVersion: string): Promise<string>
  async validateMigration(db: Database.Database, migration: MigrationDefinition): Promise<boolean>
  private executeMigrationStep(db: Database.Database, step: MigrationStep): void
  private createBackup(db: Database.Database): Promise<string>
}
```

---

## ğŸ“ ç±»å‹ç³»ç»Ÿ

### ç‰ˆæœ¬åŒ–ç±»å‹å®šä¹‰

```typescript
// types/database-v1.0.0.ts
export interface ProjectDocument {
  id?: number
  path: string
  title?: string
  content_hash?: string
  word_count?: number
  character_count?: number
  status?: 'draft' | 'writing' | 'completed' | 'published'
  created_at?: string
  updated_at?: string
  last_accessed?: string
}

export interface ProjectChapter {
  id?: number
  document_id: number
  title: string
  order_index?: number
  word_count?: number
  status?: 'draft' | 'writing' | 'completed'
  created_at?: string
  updated_at?: string
}

// types/database-v1.1.0.ts
export interface ProjectDocument_V1_1_0 extends Omit<ProjectDocument, 'id'> {
  id?: number
  encryption_status?: 'none' | 'encrypted' | 'pending'
}

// å¯¼å‡ºæœ€æ–°ç‰ˆæœ¬
export type { ProjectDocument_V1_1_0 as ProjectDocument }
```

### æ“ä½œæ¥å£å®šä¹‰

```typescript
export interface DatabaseOperations {
  // æ–‡æ¡£æ“ä½œ
  getDocuments(filter?: DocumentFilter): Promise<ProjectDocument[]>
  getDocument(id: number): Promise<ProjectDocument | null>
  createDocument(doc: Partial<ProjectDocument>): Promise<number>
  updateDocument(id: number, updates: Partial<ProjectDocument>): Promise<void>
  deleteDocument(id: number): Promise<void>
  
  // ç« èŠ‚æ“ä½œ
  getChapters(documentId: number): Promise<ProjectChapter[]>
  createChapter(chapter: Partial<ProjectChapter>): Promise<number>
  updateChapter(id: number, updates: Partial<ProjectChapter>): Promise<void>
  deleteChapter(id: number): Promise<void>
  reorderChapters(documentId: number, chapterIds: number[]): Promise<void>
  
  // æ ‡ç­¾æ“ä½œ
  getTags(): Promise<ProjectTag[]>
  createTag(tag: Partial<ProjectTag>): Promise<number>
  updateTag(id: number, updates: Partial<ProjectTag>): Promise<void>
  deleteTag(id: number): Promise<void>
  
  // ç»Ÿè®¡æ“ä½œ
  getProjectStats(dateRange?: DateRange): Promise<ProjectStats[]>
  updateDailyStats(): Promise<void>
  getWritingSessions(filter?: SessionFilter): Promise<WritingSession[]>
}
```

---

## ğŸ”Œ é›†æˆæ–¹æ¡ˆ

### IPCå¤„ç†å™¨

**ä¸¥æ ¼éµå¾ªäº‹ä»¶é©±åŠ¨æ¶æ„èŒƒå¼**ï¼šäº‹ä»¶ç›‘å¬å™¨åªæ³¨å†Œä¸€æ¬¡ï¼ŒIPC Handleråªè´Ÿè´£çº¯è°ƒç”¨

```typescript
// ipc/main-renderer/database-handlers.ts
import { ipcMain, BrowserWindow } from 'electron'
import type { DatabaseService } from '../services/database-service/database-service'

export function registerDatabaseHandlers(databaseService: DatabaseService) {
  // ========== äº‹ä»¶ç›‘å¬å™¨ï¼ˆåªåœ¨æ³¨å†Œæ—¶æ‰§è¡Œä¸€æ¬¡ï¼‰ ==========
  
  // æ•°æ®åº“åˆå§‹åŒ–äº‹ä»¶
  databaseService.on('database:init-start', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('database:init-start', data)
    })
  })
  
  databaseService.on('database:init-complete', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('database:init-complete', data)
    })
  })
  
  databaseService.on('database:init-error', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('database:init-error', data)
    })
  })
  
  // é¡¹ç›®æ•°æ®åº“åˆ›å»ºäº‹ä»¶
  databaseService.on('database:project-create-start', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('database:project-create-start', data)
    })
  })
  
  databaseService.on('database:project-created', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('database:project-created', data)
    })
  })
  
  databaseService.on('database:project-error', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('database:project-error', data)
    })
  })
  
  // æ•°æ®åº“è¿ç§»äº‹ä»¶
  databaseService.on('database:migration-start', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('database:migration-start', data)
    })
  })
  
  databaseService.on('database:migration-progress', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('database:migration-progress', data)
    })
  })
  
  databaseService.on('database:migration-complete', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('database:migration-complete', data)
    })
  })
  
  databaseService.on('database:migration-error', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('database:migration-error', data)
    })
  })
  
  // ========== IPC Handlersï¼ˆçº¯è°ƒç”¨ï¼Œç«‹å³è¿”å›IDï¼‰ ==========
  
  // åˆå§‹åŒ–æ•°æ®åº“æœåŠ¡
  ipcMain.handle('database:initialize', async (_event) => {
    try {
      const initId = await databaseService.initialize()
      return { success: true, initId }
    } catch (error: any) {
      return { success: false, error: error.message }
    }
  })
  
  // åˆ›å»ºé¡¹ç›®æ•°æ®åº“
  ipcMain.handle('database:create-project', async (_event, { projectPath }) => {
    try {
      const operationId = await databaseService.createProjectDatabase(projectPath)
      return { success: true, operationId }
    } catch (error: any) {
      return { success: false, error: error.message }
    }
  })

  // è¿ç§»é¡¹ç›®æ•°æ®åº“
  ipcMain.handle('database:migrate-project', async (_event, { projectPath, targetVersion }) => {
    try {
      const migrationId = await databaseService.migrateProjectDatabase(projectPath, targetVersion)
      return { success: true, migrationId }
    } catch (error: any) {
      return { success: false, error: error.message }
    }
  })

  // åŒæ­¥æ“ä½œï¼ˆä¸éœ€è¦äº‹ä»¶ï¼‰
  ipcMain.handle('database:get-documents', async (_event, { projectPath, filter }) => {
    try {
      const projectDb = databaseService.getProjectDatabase(projectPath)
      if (!projectDb) {
        return { success: false, error: 'Project database not found' }
      }
      
      const documents = await projectDb.getDocuments(filter)
      return { success: true, documents }
    } catch (error: any) {
      return { success: false, error: error.message }
    }
  })

  // ç»Ÿè®¡æ“ä½œ
  ipcMain.handle('database:get-stats', async (_event, { projectPath, dateRange }) => {
    try {
      const projectDb = databaseService.getProjectDatabase(projectPath)
      if (!projectDb) {
        return { success: false, error: 'Project database not found' }
      }
      
      const stats = await projectDb.getProjectStats(dateRange)
      return { success: true, stats }
    } catch (error: any) {
      return { success: false, error: error.message }
    }
  })
  
  console.log('Database IPC handlers registered')
}
```

### å‰ç«¯Storeé›†æˆ

**éµå¾ªäº‹ä»¶é©±åŠ¨æ¶æ„èŒƒå¼**ï¼šç«‹å³è·å–æ“ä½œIDï¼Œé€šè¿‡äº‹ä»¶ç›‘å¬å™¨æ›´æ–°æœ¬åœ°çŠ¶æ€

```typescript
// Client/stores/database/databaseStore.ts
import { defineStore } from 'pinia'
import { ref, readonly, onMounted } from 'vue'

interface DatabaseOperation {
  id: string
  type: 'init' | 'create-project' | 'migration'
  status: 'running' | 'completed' | 'error'
  projectPath?: string
  progress?: number
  error?: string
  result?: any
}

export const useDatabaseStore = defineStore('database', () => {
  const projectDatabases = ref<Map<string, boolean>>(new Map())
  const activeOperations = ref<Map<string, DatabaseOperation>>(new Map())
  
  // âœ… äº‹ä»¶é©±åŠ¨æ–¹æ³•ï¼šç«‹å³è·å–initIdï¼Œé€šè¿‡äº‹ä»¶æ›´æ–°çŠ¶æ€
  const initializeDatabase = async () => {
    const result = await window.api.database.initialize()
    if (result.success) {
      // åˆ›å»ºæœ¬åœ°çŠ¶æ€
      activeOperations.value.set(result.initId, {
        id: result.initId,
        type: 'init',
        status: 'running'
      })
      return result.initId
    }
    return null
  }
  
  // âœ… äº‹ä»¶é©±åŠ¨æ–¹æ³•ï¼šç«‹å³è·å–operationIdï¼Œé€šè¿‡äº‹ä»¶æ›´æ–°çŠ¶æ€
  const createProjectDatabase = async (projectPath: string) => {
    const result = await window.api.database.createProject({ projectPath })
    if (result.success) {
      // åˆ›å»ºæœ¬åœ°çŠ¶æ€
      activeOperations.value.set(result.operationId, {
        id: result.operationId,
        type: 'create-project',
        status: 'running',
        projectPath
      })
      return result.operationId
    }
    return null
  }
  
  // âœ… äº‹ä»¶é©±åŠ¨æ–¹æ³•ï¼šç«‹å³è·å–migrationIdï¼Œé€šè¿‡äº‹ä»¶æ›´æ–°çŠ¶æ€
  const migrateProjectDatabase = async (projectPath: string, targetVersion: string) => {
    const result = await window.api.database.migrateProject({ projectPath, targetVersion })
    if (result.success) {
      // åˆ›å»ºæœ¬åœ°çŠ¶æ€
      activeOperations.value.set(result.migrationId, {
        id: result.migrationId,
        type: 'migration',
        status: 'running',
        projectPath
      })
      return result.migrationId
    }
    return null
  }
  
  // åŒæ­¥æ“ä½œï¼ˆä¸éœ€è¦äº‹ä»¶ï¼‰
  const getDocuments = async (projectPath: string, filter?: DocumentFilter) => {
    return await window.api.database.getDocuments({ projectPath, filter })
  }
  
  const getProjectStats = async (projectPath: string, dateRange?: DateRange) => {
    return await window.api.database.getStats({ projectPath, dateRange })
  }
  
  // âœ… è®¾ç½®äº‹ä»¶ç›‘å¬å™¨ï¼ˆåœ¨ç»„ä»¶æŒ‚è½½æ—¶è°ƒç”¨ï¼‰
  const setupListeners = () => {
    // æ•°æ®åº“åˆå§‹åŒ–äº‹ä»¶
    window.api.database.onInitStart((data) => {
      console.log('Database initialization started:', data.initId)
    })
    
    window.api.database.onInitComplete((data) => {
      const operation = activeOperations.value.get(data.initId)
      if (operation) {
        operation.status = 'completed'
        operation.result = data
      }
      console.log('Database initialization completed:', data.initId)
    })
    
    window.api.database.onInitError((data) => {
      const operation = activeOperations.value.get(data.initId!)
      if (operation) {
        operation.status = 'error'
        operation.error = data.error
      }
      console.error('Database initialization failed:', data.error)
    })
    
    // é¡¹ç›®æ•°æ®åº“åˆ›å»ºäº‹ä»¶
    window.api.database.onProjectCreateStart((data) => {
      console.log('Project database creation started:', data.operationId)
    })
    
    window.api.database.onProjectCreated((data) => {
      const operation = activeOperations.value.get(data.operationId)
      if (operation) {
        operation.status = 'completed'
        operation.result = data
      }
      
      // æ›´æ–°é¡¹ç›®æ•°æ®åº“çŠ¶æ€
      projectDatabases.value.set(data.projectPath, true)
      console.log('Project database created:', data.projectPath)
    })
    
    window.api.database.onProjectError((data) => {
      const operation = activeOperations.value.get(data.operationId!)
      if (operation) {
        operation.status = 'error'
        operation.error = data.error
      }
      console.error('Project database error:', data.error)
    })
    
    // æ•°æ®åº“è¿ç§»äº‹ä»¶
    window.api.database.onMigrationStart((data) => {
      console.log('Database migration started:', data.migrationId)
    })
    
    window.api.database.onMigrationProgress((data) => {
      const operation = activeOperations.value.get(data.migrationId)
      if (operation) {
        operation.progress = data.progress
      }
      console.log(`Migration progress: ${data.progress}%`)
    })
    
    window.api.database.onMigrationComplete((data) => {
      const operation = activeOperations.value.get(data.migrationId)
      if (operation) {
        operation.status = 'completed'
        operation.result = data
      }
      console.log('Migration completed:', data.migrationId)
    })
    
    window.api.database.onMigrationError((data) => {
      const operation = activeOperations.value.get(data.migrationId)
      if (operation) {
        operation.status = 'error'
        operation.error = data.error
      }
      console.error('Migration failed:', data.error)
    })
  }
  
  // æ¸…ç†å·²å®Œæˆçš„æ“ä½œ
  const clearCompletedOperations = () => {
    for (const [id, operation] of activeOperations.value) {
      if (operation.status === 'completed' || operation.status === 'error') {
        activeOperations.value.delete(id)
      }
    }
  }
  
  return {
    // çŠ¶æ€
    projectDatabases: readonly(projectDatabases),
    activeOperations: readonly(activeOperations),
    
    // æ“ä½œæ–¹æ³•
    initializeDatabase,
    createProjectDatabase,
    migrateProjectDatabase,
    getDocuments,
    getProjectStats,
    
    // å·¥å…·æ–¹æ³•
    setupListeners,
    clearCompletedOperations
  }
})

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
/*
<script setup>
import { onMounted } from 'vue'
import { useDatabaseStore } from '@stores/database/databaseStore'

const databaseStore = useDatabaseStore()

onMounted(() => {
  // âœ… è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
  databaseStore.setupListeners()
})

// âœ… ä½¿ç”¨äº‹ä»¶é©±åŠ¨æ–¹æ³•
const handleCreateProject = async () => {
  const operationId = await databaseStore.createProjectDatabase('/path/to/project')
  if (operationId) {
    console.log('Operation started:', operationId)
    // çŠ¶æ€æ›´æ–°é€šè¿‡äº‹ä»¶è‡ªåŠ¨å¤„ç†
  }
}
</script>
*/
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### æ•°æ®åº“é…ç½®ä¼˜åŒ–

```typescript
export const DATABASE_CONFIG = {
  // WALæ¨¡å¼é…ç½®
  walMode: {
    journal_mode: 'WAL',
    synchronous: 'NORMAL',
    cache_size: 1000,
    temp_store: 'memory',
    mmap_size: 268435456, // 256MB
  },
  
  // è¿æ¥æ± é…ç½®
  connectionPool: {
    maxConnections: 10,
    idleTimeout: 30000,
    acquireTimeout: 60000,
  },
  
  // æŸ¥è¯¢ä¼˜åŒ–
  queryOptimization: {
    enableQueryPlan: true,
    enableStatistics: true,
    autoVacuum: 'incremental',
  }
}
```

### æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥

```typescript
export class QueryOptimizer {
  // æ‰¹é‡æ“ä½œ
  static batchInsert<T>(db: Database.Database, table: string, records: T[]): void {
    const transaction = db.transaction((records: T[]) => {
      const stmt = db.prepare(`INSERT INTO ${table} VALUES (...)`)
      for (const record of records) {
        stmt.run(record)
      }
    })
    transaction(records)
  }
  
  // é¢„ç¼–è¯‘è¯­å¥ç¼“å­˜
  private static statementCache = new Map<string, Database.Statement>()
  
  static getStatement(db: Database.Database, sql: string): Database.Statement {
    if (!this.statementCache.has(sql)) {
      this.statementCache.set(sql, db.prepare(sql))
    }
    return this.statementCache.get(sql)!
  }
}
```

---

## ğŸ”’ å®‰å…¨è€ƒè™‘

### æ•°æ®éªŒè¯

```typescript
export class DatabaseValidator {
  static validateDocument(doc: Partial<ProjectDocument>): ValidationResult {
    const errors: string[] = []
    
    if (!doc.path || typeof doc.path !== 'string') {
      errors.push('Document path is required and must be a string')
    }
    
    if (doc.word_count && (typeof doc.word_count !== 'number' || doc.word_count < 0)) {
      errors.push('Word count must be a non-negative number')
    }
    
    return {
      isValid: errors.length === 0,
      errors
    }
  }
}
```

### å¤‡ä»½ç­–ç•¥

```typescript
export class DatabaseBackup {
  static async createBackup(projectPath: string): Promise<string> {
    const backupDir = path.join(projectPath, '.Database', 'backups')
    await fs.ensureDir(backupDir)
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const backupPath = path.join(backupDir, `backup-${timestamp}.db`)
    
    const sourcePath = path.join(projectPath, '.Database', 'project.db')
    await fs.copy(sourcePath, backupPath)
    
    return backupPath
  }
  
  static async restoreBackup(projectPath: string, backupPath: string): Promise<void> {
    const targetPath = path.join(projectPath, '.Database', 'project.db')
    await fs.copy(backupPath, targetPath)
  }
}
```

---

## ğŸ“¦ éƒ¨ç½²ç­–ç•¥

### æ„å»ºé…ç½®

```typescript
// quasar.config.ts ä¸­çš„æ•°æ®åº“é…ç½®
electron: {
  extendElectronMainConf(esbuildConf) {
    // æ’é™¤better-sqlite3é¿å…æ‰“åŒ…
    esbuildConf.external = esbuildConf.external || []
    esbuildConf.external.push('better-sqlite3')
  },
  
  builder: {
    extraResources: [
      // ç¡®ä¿æ•°æ®åº“ç›¸å…³æ–‡ä»¶è¢«åŒ…å«
      {
        from: 'src-electron/services/database-service/schema',
        to: 'database-schema'
      }
    ]
  }
}
```

### åˆå§‹åŒ–æµç¨‹

```typescript
export class DatabaseInitializer {
  static async initializeApplication(): Promise<void> {
    // 1. æ£€æŸ¥better-sqlite3æ˜¯å¦å¯ç”¨
    await this.checkSqliteAvailability()
    
    // 2. åˆå§‹åŒ–å…¨å±€æ•°æ®åº“
    await this.initializeGlobalDatabase()
    
    // 3. è¿è¡Œå¿…è¦çš„è¿ç§»
    await this.runGlobalMigrations()
    
    // 4. æ¸…ç†æ—§çš„å¤‡ä»½æ–‡ä»¶
    await this.cleanupOldBackups()
  }
}
```

---

## ğŸ“Š ç›‘æ§å’Œæ—¥å¿—

### æ€§èƒ½ç›‘æ§

```typescript
export class DatabaseMonitor {
  private static metrics = {
    queryCount: 0,
    slowQueries: [] as Array<{ sql: string; duration: number }>,
    connectionCount: 0,
    errorCount: 0
  }
  
  static logQuery(sql: string, duration: number): void {
    this.metrics.queryCount++
    
    if (duration > 1000) { // è¶…è¿‡1ç§’çš„æ…¢æŸ¥è¯¢
      this.metrics.slowQueries.push({ sql, duration })
    }
  }
  
  static getMetrics(): typeof DatabaseMonitor.metrics {
    return { ...this.metrics }
  }
}
```

### é”™è¯¯å¤„ç†

```typescript
export class DatabaseErrorHandler {
  static handleError(error: Error, context: string): void {
    const logger = getLogger('DatabaseError')
    
    if (error.message.includes('SQLITE_BUSY')) {
      logger.warn(`Database busy in ${context}, retrying...`)
      // å®ç°é‡è¯•é€»è¾‘
    } else if (error.message.includes('SQLITE_CORRUPT')) {
      logger.error(`Database corruption detected in ${context}`)
      // è§¦å‘å¤‡ä»½æ¢å¤æµç¨‹
    } else {
      logger.error(`Database error in ${context}:`, error)
    }
  }
}
```

---

## ğŸ”® æœªæ¥æ‰©å±•

### è®¡åˆ’åŠŸèƒ½

1. **åˆ†å¸ƒå¼åŒæ­¥**: æ”¯æŒå¤šè®¾å¤‡é—´çš„æ•°æ®åŒæ­¥
2. **å¢é‡å¤‡ä»½**: å®ç°å¢é‡å¤‡ä»½å’Œæ¢å¤
3. **å…¨æ–‡æœç´¢**: é›†æˆFTS5å…¨æ–‡æœç´¢å¼•æ“
4. **æ•°æ®å‹ç¼©**: å®ç°æ•°æ®å‹ç¼©å­˜å‚¨
5. **åŠ å¯†å­˜å‚¨**: æ”¯æŒæ•°æ®åº“çº§åˆ«çš„åŠ å¯†

### æ‰©å±•æ¥å£

```typescript
export interface DatabaseExtension {
  name: string
  version: string
  initialize(db: Database.Database): Promise<void>
  cleanup(db: Database.Database): Promise<void>
}

export class DatabaseExtensionManager {
  private extensions: Map<string, DatabaseExtension> = new Map()
  
  registerExtension(extension: DatabaseExtension): void {
    this.extensions.set(extension.name, extension)
  }
  
  async initializeExtensions(db: Database.Database): Promise<void> {
    for (const extension of this.extensions.values()) {
      await extension.initialize(db)
    }
  }
}
```

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [Better SQLite3 æ–‡æ¡£](https://github.com/WiseLibs/better-sqlite3)
- [SQLite WALæ¨¡å¼](https://www.sqlite.org/wal.html)
- [Electron æ•°æ®åº“æœ€ä½³å®è·µ](https://www.electronjs.org/docs/latest/tutorial/sqlite)
- [Nimbria äº‹ä»¶é©±åŠ¨æ¶æ„æ–‡æ¡£](../../../Workflow/äº‹ä»¶é©±åŠ¨æ¶æ„èŒƒå¼æ€»ç»“æ–‡æ¡£.md)

---

**æ–‡æ¡£ç»“æŸ**

> æœ¬æ–‡æ¡£å°†éšç€ç³»ç»Ÿçš„å‘å±•æŒç»­æ›´æ–°ï¼Œè¯·å…³æ³¨ç‰ˆæœ¬å˜æ›´è®°å½•ã€‚
