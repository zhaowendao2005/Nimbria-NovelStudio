好的Boss，我为您制定一个完整的 **G6 渲染引擎集成计划**，专注于思路、架构和关键策略。

---

# 🎯 StarChart G6 渲染引擎集成计划

## 📋 一、总体策略

### 核心原则
1. **零破坏原则**：Cytoscape 渲染引擎完全保留，所有现有功能不受影响
2. **插件化扩展**：G6 作为可选渲染引擎，通过配置切换
3. **渐进式集成**：分阶段实现，每阶段可独立验证
4. **配置智能化**：根据渲染引擎自动显示/隐藏相关配置项

### 架构设计哲学
```
保持数据层和布局层不变 ✅
  ↓
新增转换器层分支 (G6Transformer)
  ↓
新增渲染器层分支 (G6Renderer)
  ↓
容器层改为智能路由 (动态组件)
  ↓
配置层扩展渲染引擎选项
```

---

## 📁 二、文件架构修改树

```
Nimbria/Client/stores/projectPage/starChart/
├── data/                                    [保持不变]
│   ├── types.ts
│   ├── mock.large.ts
│   ├── mock.normal.ts
│   └── DataSourceManager.ts
│
├── layouts/                                 [保持不变]
│   ├── types.ts
│   ├── ConcentricLayout.ts
│   ├── ForceDirectedLayout.ts
│   ├── HierarchicalLODLayout.ts
│   └── LayoutManager.ts
│
├── transforms/                              [扩展目录]
│   ├── CytoscapeTransformer.ts             [保持不变]
│   ├── G6Transformer.ts                    [🆕新增] G6格式转换器
│   └── transformer.types.ts                [🆕新增] 转换器接口定义
│
├── renderers/                               [🆕新增目录] 渲染引擎抽象层
│   ├── types.ts                            [🆕新增] 渲染引擎接口
│   ├── BaseRenderer.ts                     [🆕新增] 渲染器基类
│   ├── CytoscapeRenderer.ts                [🆕新增] Cytoscape封装
│   ├── G6Renderer.ts                       [🆕新增] G6封装
│   └── RendererFactory.ts                  [🆕新增] 渲染器工厂
│
├── adapters/                                [🆕新增目录] 配置适配器
│   ├── cytoscape-config-adapter.ts         [🆕新增] Cytoscape配置映射
│   └── g6-config-adapter.ts                [🆕新增] G6配置映射
│
├── config/
│   ├── layout.presets.ts                   [保持不变]
│   ├── g6.presets.ts                       [🆕新增] G6专用预设
│   └── renderer.compatibility.ts           [🆕新增] 渲染器兼容性映射
│
├── starChart.config.store.ts               [🔧修改] 扩展渲染引擎配置
├── starChart.config.types.ts               [🔧修改] 添加RenderEngine类型
├── starChart.store.ts                      [🔧修改] 支持双引擎转换
├── starChart.types.ts                      [保持不变]
└── index.ts                                [🔧修改] 导出新增模块

Nimbria/Client/GUI/components/ProjectPage.MainPanel/StarChart/
├── StarChartViewport.vue                   [🔧重构] 改为智能路由容器
├── viewports/                              [🆕新增目录]
│   ├── StarChartViewport.Cytoscape.vue     [🔧迁移] 原Viewport重命名
│   ├── StarChartViewport.G6.vue            [🆕新增] G6渲染视口
│   └── viewport.shared.ts                  [🆕新增] 共享逻辑抽取
│
├── nodes/                                   [🆕新增目录] 自定义节点注册
│   ├── G6CustomSVGNode.ts                  [🆕新增] G6 SVG节点实现
│   └── G6CustomImageNode.ts                [🆕新增] G6 Image节点实现
│
├── StarChartPanel.vue                      [保持不变]
├── StarChartTopBar.vue                     [保持不变]
└── register.ts                             [保持不变]

Nimbria/Client/GUI/components/ProjectPage.Shell/Navbar.content/Writing/
└── WritingPanel.vue                        [🔧修改] 集成渲染引擎选择

Nimbria/package.json                        [🔧修改] 添加 @antv/g6 依赖
```

---

## 🎯 三、详细 TODO 清单

### 🔹 阶段一：基础架构搭建（优先级：P0）

#### Task 1.1: 定义渲染引擎接口
**文件**: `stores/projectPage/starChart/renderers/types.ts`

**思路**:
```typescript
// 核心思想：统一不同渲染引擎的生命周期和交互接口
interface IRenderer {
  name: 'cytoscape' | 'g6'
  
  // 生命周期
  initialize(container: HTMLElement, config: any): void
  destroy(): void
  
  // 数据操作
  loadData(elements: any): void
  updateData(elements: any): void
  
  // 布局操作
  runLayout(config: any): void
  
  // 视口操作
  fit(): void
  center(): void
  zoom(level: number): void
  pan(position: {x: number, y: number}): void
  
  // 状态查询
  getViewportState(): ViewportState
  getSelectedNodes(): string[]
  
  // 事件系统
  on(event: string, handler: Function): void
  off(event: string, handler: Function): void
}
```

**关键策略**:
- 使用**适配器模式**统一两种引擎的API差异
- 事件名标准化（如 `node:click` 统一处理 Cytoscape 的 `tap` 和 G6 的 `node:click`）

---

#### Task 1.2: 实现渲染器工厂
**文件**: `stores/projectPage/starChart/renderers/RendererFactory.ts`

**思路**:
```typescript
// 工厂模式：根据配置创建对应渲染器
class RendererFactory {
  static create(type: 'cytoscape' | 'g6', config: any): IRenderer {
    switch(type) {
      case 'cytoscape': return new CytoscapeRenderer(config)
      case 'g6': return new G6Renderer(config)
    }
  }
  
  // 验证渲染器兼容性
  static checkCompatibility(type: string, features: string[]): boolean
}
```

**关键策略**:
- 单一创建入口，便于后续扩展其他渲染引擎
- 兼容性检查（某些布局可能只支持特定引擎）

---

#### Task 1.3: 扩展配置类型定义
**文件**: `stores/projectPage/starChart/starChart.config.types.ts`

**思路**:
```typescript
// 新增渲染引擎类型
export type RenderEngine = 'cytoscape' | 'g6'

// 🆕 G6 渲染器类型
export type G6RendererType = 'canvas' | 'webgl' | 'svg' | 'auto'

// 渲染引擎特性定义
export interface RenderEngineFeatures {
  supportWebGL: boolean
  supportLargeGraph: boolean  // 10000+ 节点
  supportCustomNode: boolean
  supportAnimation: boolean
  supportSVG: boolean          // 支持 SVG 导出
  maxNodes: number             // 性能上限
}

// 🆕 G6 配置扩展
export interface G6Config {
  renderer: G6RendererType     // G6 渲染器类型
  pixelRatio: number           // 设备像素比（默认 auto）
  fitView: boolean             // 自动适应视口
  groupByTypes: boolean        // 按类型分组渲染
  enableOptimize: boolean      // 启用性能优化
  layeredRendering: boolean    // 分层渲染（主画布 WebGL + 交互层 Canvas）
}

// 配置兼容性映射
export interface ConfigCompatibility {
  // Cytoscape 专属配置
  cytoscapeOnly: string[]  // 如: 'webgl.texSize', 'rendering.motionBlur'
  
  // G6 专属配置
  g6Only: string[]  // 如: 'g6.pixelRatio', 'g6.fitView', 'g6.renderer'
  
  // 通用配置
  shared: string[]  // 如: 'interaction.wheelSensitivity'
}

// StarChartConfig 扩展（在现有配置中添加）
export interface StarChartConfig {
  // ... 原有配置 ...
  webgl: WebGLConfig
  performance: PerformanceMonitoringConfig
  logging: LoggingConfig
  interaction: InteractionConfig
  edgeStyle: EdgeStyleConfig
  nodeStyle: NodeStyleConfig
  rendering: RenderOptimizationConfig
  
  // 🆕 G6 专属配置
  g6: G6Config
}
```

**关键策略**:
- 明确哪些配置项是引擎专属的
- 为配置面板的智能显隐提供元数据

---

### 🔹 阶段二：G6 转换器实现（优先级：P0）

#### Task 2.1: G6Transformer 核心逻辑
**文件**: `stores/projectPage/starChart/transforms/G6Transformer.ts`

**思路**:

1. **节点转换策略**
```typescript
// 关键点：Cytoscape 使用 {data: {...}, position: {...}}
//        G6 使用 {id, data, style, x, y}

transformNode(layoutedNode: LayoutedNode) {
  return {
    id: node.id,
    data: {
      // 业务数据
      name: node.name,
      type: node.type,
      hierarchy: node.hierarchy
    },
    style: {
      // G6样式系统（与Cytoscape差异大）
      fill: node.color,
      size: this.calculateNodeSize(node),
      stroke: node.color,
      lineWidth: 2,
      // 关键：G6使用type属性指定节点渲染器
      type: 'custom-svg-node'  // 注册的自定义节点
    },
    // 位置处理（如果布局已计算）
    x: node.position?.x,
    y: node.position?.y
  }
}
```

2. **边转换策略**
```typescript
// G6的边样式系统完全不同
transformEdge(edge: RawEdge) {
  return {
    id: edge.id,
    source: edge.source,
    target: edge.target,
    data: { weight: edge.weight },
    style: {
      stroke: this.getEdgeColor(edge),
      lineWidth: edge.weight * 3,
      // G6的曲线类型
      type: 'quadratic',  // 等价于Cytoscape的bezier
      endArrow: {
        path: 'M 0,0 L 8,4 L 8,-4 Z',
        fill: this.getEdgeColor(edge)
      }
    }
  }
}
```

**关键策略**:
- **样式预计算**：避免运行时动态计算导致性能问题
- **格式映射表**：维护 Cytoscape ↔ G6 样式属性对照表
- **渐进增强**：先实现基础样式，再补充高级效果

---

#### Task 2.2: SVG图标处理方案
**文件**: `stores/projectPage/starChart/nodes/G6CustomSVGNode.ts`

**核心问题**: Cytoscape 使用 `background-image` DataURL，G6 需要在 Canvas 中绘制

**解决方案A - 使用 G6 的 Image 节点**:
```typescript
// 思路：复用 Cytoscape 的 SVG DataURL 生成逻辑
class G6CustomSVGNode {
  draw(cfg, group) {
    const svgDataURL = generateNodeSVGDataURL(cfg.data.svgIcon, ...)
    
    // G6 可以直接使用 DataURL 作为图片
    return group.addShape('image', {
      attrs: {
        img: svgDataURL,
        width: cfg.size,
        height: cfg.size,
        x: -cfg.size / 2,
        y: -cfg.size / 2
      }
    })
  }
}
```

**解决方案B - 使用 G6 的自定义渲染**:
```typescript
// 思路：直接在 Canvas 中绘制 SVG Path
class G6CustomSVGNode {
  draw(cfg, group) {
    const svgPath = getSVGIcon(cfg.data.svgIcon).path
    
    return group.addShape('path', {
      attrs: {
        path: svgPath,
        fill: cfg.style.fill,
        stroke: cfg.style.stroke,
        lineWidth: 2
      }
    })
  }
}
```

**推荐策略**: 方案A（复用现有逻辑，快速实现）

---

### 🔹 阶段三：G6 视口组件（优先级：P0）

#### Task 3.1: StarChartViewport.G6.vue 核心实现
**文件**: `GUI/components/ProjectPage.MainPanel/StarChart/viewports/StarChartViewport.G6.vue`

**关键思路**:

1. **初始化流程（正确的渲染器配置）**
```typescript
import { Renderer as CanvasRenderer } from '@antv/g-canvas'
import { Renderer as WebGLRenderer } from '@antv/g-webgl'
import { Renderer as SVGRenderer } from '@antv/g-svg'

const initGraph = () => {
  graphInstance = new Graph({
    container: containerRef.value,
    width: containerWidth,
    height: containerHeight,
    
    // 🔥 渲染器选择（G6 v5 正确方式）
    renderer: getRenderer,  // 函数引用，不是字符串
    
    // 数据
    data: props.elements,  // { nodes: [], edges: [] }
    
    // 布局
    layout: getG6LayoutConfig(),
    
    // 节点配置（关键：使用函数动态返回）
    node: (model) => ({
      ...model,
      type: 'custom-svg-node'  // 指向注册的自定义节点
    }),
    
    // 交互模式
    modes: {
      default: ['drag-canvas', 'zoom-canvas', 'drag-node', 'click-select']
    },
    
    // 动画配置
    animate: !props.fastRebuild
  })
  
  // 事件绑定
  setupEventListeners()
  
  // 渲染
  graphInstance.render()
}

/**
 * 渲染器选择函数
 * G6 v5 支持分层渲染，不同画布可使用不同渲染器
 */
const getRenderer = (layer?: string) => {
  const config = configStore.config
  
  // 根据配置选择渲染器
  if (config.webgl.enabled) {
    // 主画布使用 WebGL（高性能）
    if (layer === 'main') {
      return new WebGLRenderer()
    }
    // 其他画布（标签层、交互层）使用 Canvas
    return new CanvasRenderer()
  } else {
    // 默认使用 Canvas 渲染器
    return new CanvasRenderer()
  }
}
```

2. **布局配置映射**
```typescript
const getG6LayoutConfig = () => {
  const layoutType = props.layout.name
  
  // 关键：不同布局类型的 G6 配置映射
  const layoutMap = {
    'concentric': {
      type: 'preset',  // 使用预计算位置
    },
    'force-directed': {
      type: 'force',
      preventOverlap: true,
      nodeSize: 30,
      linkDistance: (edge) => {
        // 根据边的权重动态计算距离
        return 50 + (1 - edge.data.weight) * 50
      }
    },
    'hierarchical-lod': {
      type: 'dagre',  // G6的层次布局
      rankdir: 'TB',
      nodesep: 40,
      ranksep: 80
    }
  }
  
  return layoutMap[layoutType] || layoutMap['force-directed']
}
```

3. **事件系统统一**
```typescript
const setupEventListeners = () => {
  // 节点点击
  graphInstance.on('node:click', (evt) => {
    const nodeId = evt.item.getID()
    emit('node-selected', nodeId)
  })
  
  // 视口变化
  graphInstance.on('viewportchange', () => {
    const zoom = graphInstance.getZoom()
    const { x, y } = graphInstance.getViewportCenter()
    emit('viewport-change', { zoom, pan: { x, y } })
  })
  
  // 高亮逻辑（需要重新实现）
  graphInstance.on('node:mouseenter', handleNodeHighlight)
  graphInstance.on('node:mouseleave', handleNodeUnhighlight)
}
```

4. **动态切换渲染器（G6 内部切换）**
```typescript
/**
 * 在 G6 内部动态切换渲染器
 * 例如：根据节点数量自动切换 Canvas/WebGL
 */
const switchG6Renderer = async (rendererType: 'canvas' | 'webgl' | 'svg') => {
  if (!graphInstance) return
  
  console.log(`[G6Viewport] 切换渲染器: ${rendererType}`)
  
  // G6 v5 动态切换渲染器
  const rendererMap = {
    'canvas': () => new CanvasRenderer(),
    'webgl': () => new WebGLRenderer(),
    'svg': () => new SVGRenderer()
  }
  
  graphInstance.setOptions({
    renderer: rendererMap[rendererType]
  })
  
  // 重新渲染
  await graphInstance.render()
  
  console.log(`[G6Viewport] 渲染器切换完成: ${rendererType}`)
}

/**
 * 智能渲染器选择
 * 根据节点数量自动选择最优渲染器
 */
const selectOptimalRenderer = () => {
  const nodeCount = props.elements.nodes.length
  
  if (nodeCount > 5000) {
    // 大规模数据：优先 WebGL
    return 'webgl'
  } else if (nodeCount > 1000) {
    // 中等规模：Canvas 或 WebGL
    return configStore.config.webgl.enabled ? 'webgl' : 'canvas'
  } else {
    // 小规模：Canvas 足够
    return 'canvas'
  }
}

// 监听数据变化，自动选择渲染器
watch(() => props.elements, (newElements) => {
  const optimalRenderer = selectOptimalRenderer()
  switchG6Renderer(optimalRenderer)
}, { deep: true })
```

**关键策略**:
- **懒加载 G6**：仅在用户选择 G6 渲染器时才 import
- **性能标记**：使用 `performance.mark()` 监控渲染耗时
- **优雅降级**：G6 初始化失败时自动回退到 Cytoscape
- **智能渲染器选择**：根据节点数量自动选择 Canvas/WebGL
- **分层渲染优化**：主画布 WebGL，交互层 Canvas（减少内存占用）

---

#### Task 3.2: 容器组件智能路由
**文件**: `GUI/components/ProjectPage.MainPanel/StarChart/StarChartViewport.vue`

**重构思路**:
```vue
<template>
  <component 
    :is="currentViewportComponent"
    v-bind="viewportProps"
    @viewport-change="handleViewportChange"
    @node-selected="handleNodeSelected"
  />
</template>

<script setup lang="ts">
import { computed, defineAsyncComponent } from 'vue'
import { useStarChartConfigStore } from '@stores/projectPage/starChart'

// 懒加载视口组件
const CytoscapeViewport = defineAsyncComponent(
  () => import('./viewports/StarChartViewport.Cytoscape.vue')
)
const G6Viewport = defineAsyncComponent(
  () => import('./viewports/StarChartViewport.G6.vue')
)

const configStore = useStarChartConfigStore()

// 智能路由：根据配置选择组件
const currentViewportComponent = computed(() => {
  return configStore.renderEngine === 'g6' ? G6Viewport : CytoscapeViewport
})

// Props适配器（处理两个组件的props差异）
const viewportProps = computed(() => {
  const baseProps = {
    layout: props.layout,
    wheelSensitivity: props.wheelSensitivity,
    fastRebuild: props.fastRebuild
  }
  
  // Cytoscape: elements (CytoscapeElement[])
  // G6: elements ({ nodes: [], edges: [] })
  if (configStore.renderEngine === 'g6') {
    return {
      ...baseProps,
      elements: props.g6Data  // 从 store 获取 G6 格式数据
    }
  } else {
    return {
      ...baseProps,
      elements: props.cytoscapeElements
    }
  }
})
</script>
```

**关键策略**:
- 使用 `defineAsyncComponent` 实现按需加载（减小初始包体积）
- 统一事件接口（两个子组件emit相同的事件名）
- Props 适配器处理数据格式差异

---

### 🔹 阶段四：配置面板集成（优先级：P1）

#### Task 4.1: 渲染引擎选择器
**文件**: `GUI/components/ProjectPage.Shell/Navbar.content/Writing/WritingPanel.vue`

**添加位置**: 在"📊 数据源"section 之后，"🎨 布局算法"之前

**实现思路**:
```vue
<!-- 🆕 渲染引擎选择 -->
<div class="config-section config-section-highlight">
  <h5>🎨 渲染引擎</h5>
  
  <!-- 引擎类型选择 -->
  <div class="config-item">
    <label>引擎类型</label>
    <el-select 
      :model-value="configStore.renderEngine"
      @change="onRenderEngineChange"
      placeholder="选择渲染引擎"
    >
      <el-option value="cytoscape">
        <span style="float: left">Cytoscape.js</span>
        <span style="float: right; color: #67c23a">稳定版</span>
      </el-option>
      
      <el-option value="g6">
        <span style="float: left">AntV G6</span>
        <span style="float: right; color: #409eff">高性能</span>
      </el-option>
    </el-select>
  </div>
  
  <!-- G6 渲染器类型选择（仅在 G6 引擎时显示）-->
  <div class="config-item" v-show="configStore.renderEngine === 'g6'">
    <el-tooltip 
      content="Canvas: 通用渲染 | WebGL: 高性能大规模数据 | SVG: 矢量导出" 
      placement="top"
    >
      <label>
        G6 渲染器
        <el-tag size="small" type="warning" style="margin-left: 4px">G6专用</el-tag>
      </label>
    </el-tooltip>
    <el-select 
      :model-value="configStore.config.g6Renderer"
      @change="onG6RendererChange"
      size="default"
    >
      <el-option value="canvas">
        <span style="float: left">Canvas</span>
        <span style="float: right; color: #8492a6">通用</span>
      </el-option>
      <el-option value="webgl">
        <span style="float: left">WebGL</span>
        <span style="float: right; color: #409eff">高性能</span>
      </el-option>
      <el-option value="svg">
        <span style="float: left">SVG</span>
        <span style="float: right; color: #67c23a">矢量</span>
      </el-option>
      <el-option value="auto">
        <span style="float: left">自动选择</span>
        <span style="float: right; color: #e6a23c">智能</span>
      </el-option>
    </el-select>
  </div>
  
  <!-- 引擎特性说明 -->
  <el-alert 
    v-if="configStore.renderEngine === 'g6'"
    type="success"
    :closable="false"
    style="margin-top: 8px"
  >
    <strong>G6 引擎优势：</strong><br>
    ✅ WebGL 加速，支持 10万+ 节点<br>
    ✅ 更流畅的动画和交互<br>
    ✅ 官方 AntV 团队维护<br>
    ✅ 支持分层渲染优化<br>
    📊 当前节点数: {{ starChartStore.nodeCount }}
  </el-alert>
  
  <el-alert 
    v-else
    type="info"
    :closable="false"
    style="margin-top: 8px"
  >
    <strong>Cytoscape 引擎：</strong><br>
    ✅ 成熟稳定，生产环境验证<br>
    ✅ 完善的插件生态<br>
    ✅ 当前项目默认引擎
  </el-alert>
</div>
```

**切换逻辑**:
```typescript
// 切换渲染引擎（Cytoscape ↔ G6）
const onRenderEngineChange = async (engine: 'cytoscape' | 'g6') => {
  try {
    // 1. 保存当前视口状态
    const currentViewport = starChartStore.viewportState
    
    // 2. 更新配置
    configStore.setRenderEngine(engine)
    
    // 3. 重新应用布局（触发数据转换）
    await starChartStore.recomputeLayout()
    
    // 4. 恢复视口状态（保持用户当前的缩放和平移）
    await nextTick()
    starChartStore.updateViewport(currentViewport)
    
    // 5. 用户反馈
    ElMessage.success({
      message: `已切换到 ${engine === 'g6' ? 'G6' : 'Cytoscape'} 渲染引擎`,
      duration: 2000
    })
    
    // 6. 性能日志
    console.log(`[WritingPanel] 渲染引擎切换完成: ${engine}`)
  } catch (error) {
    console.error('[WritingPanel] 切换渲染引擎失败:', error)
    ElMessage.error('切换失败，请重试')
    
    // 回滚到之前的引擎
    configStore.setRenderEngine(engine === 'g6' ? 'cytoscape' : 'g6')
  }
}

// 🆕 切换 G6 渲染器类型（Canvas/WebGL/SVG）
const onG6RendererChange = async (rendererType: 'canvas' | 'webgl' | 'svg' | 'auto') => {
  try {
    // 1. 更新配置
    configStore.updateConfig('g6Renderer', rendererType)
    
    // 2. 通知 G6Viewport 切换渲染器（通过事件总线或直接调用）
    // 注意：这里不需要重新计算布局，只需要切换渲染器
    starChartStore.switchG6Renderer(rendererType)
    
    // 3. 用户反馈
    const rendererNames = {
      canvas: 'Canvas（通用）',
      webgl: 'WebGL（高性能）',
      svg: 'SVG（矢量）',
      auto: '自动选择'
    }
    ElMessage.success({
      message: `G6 渲染器已切换到: ${rendererNames[rendererType]}`,
      duration: 2000
    })
    
    console.log(`[WritingPanel] G6 渲染器切换完成: ${rendererType}`)
  } catch (error) {
    console.error('[WritingPanel] 切换 G6 渲染器失败:', error)
    ElMessage.error('渲染器切换失败')
  }
}
```

---

#### Task 4.2: 配置项智能显隐
**文件**: `GUI/components/ProjectPage.Shell/Navbar.content/Writing/WritingPanel.vue`

**核心策略**: 根据渲染引擎动态显示配置

**实现方案**:

1. **定义兼容性映射**
```typescript
// 在 config store 中定义
const CONFIG_COMPATIBILITY = {
  cytoscape: [
    'webgl.texSize',
    'webgl.texRows',
    'webgl.batchSize',
    'rendering.motionBlur',
    'rendering.textureOnViewport',
    'rendering.hideLabelsOnViewport',
    'edgeStyle.curveStyle',  // G6有但名称和值不同
  ],
  g6: [
    'g6.pixelRatio',
    'g6.fitView',
    'g6.groupByTypes',
  ],
  shared: [
    'interaction.wheelSensitivity',
    'interaction.minZoom',
    'interaction.maxZoom',
    'nodeStyle.defaultSize',
    'nodeStyle.sizeMultiplier',
    'logging.level',
    'performance.enabled',
  ]
}
```

2. **计算属性控制显示**
```typescript
// 在 WritingPanel 中添加
const showWebGLConfig = computed(() => {
  return configStore.renderEngine === 'cytoscape'
})

const showG6Config = computed(() => {
  return configStore.renderEngine === 'g6'
})

const showMotionBlur = computed(() => {
  return configStore.renderEngine === 'cytoscape' && 
         configStore.config.rendering.hideEdgesOnViewport
})
```

3. **模板中使用 v-show**
```vue
<!-- WebGL配置 - 仅 Cytoscape -->
<div class="config-section" v-show="showWebGLConfig">
  <h5>⚡ WebGL与渲染 <el-tag size="small">Cytoscape专用</el-tag></h5>
  <!-- 配置项... -->
</div>

<!-- G6配置 - 仅 G6 -->
<div class="config-section" v-show="showG6Config">
  <h5>🚀 G6 渲染配置 <el-tag size="small">G6专用</el-tag></h5>
  <!-- G6特有配置... -->
</div>
```

**关键策略**:
- 使用 `v-show` 而非 `v-if`（避免销毁/重建DOM，保留配置状态）
- 添加标签提示配置项适用的引擎
- 共享配置始终显示

---

### 🔹 阶段五：Store层改造（优先级：P0）

#### Task 5.1: starChart.config.store.ts 扩展
**文件**: `stores/projectPage/starChart/starChart.config.store.ts`

**关键修改点**:

1. **新增状态**
```typescript
const renderEngine = ref<'cytoscape' | 'g6'>('cytoscape')
```

2. **新增计算属性**
```typescript
// 当前引擎的特性
const currentEngineFeatures = computed(() => {
  return ENGINE_FEATURES[renderEngine.value]
})

// 是否支持WebGL
const supportsWebGL = computed(() => {
  return currentEngineFeatures.value.supportWebGL
})

// 配置项可见性
const configVisibility = computed(() => {
  return {
    showWebGLSettings: renderEngine.value === 'cytoscape',
    showG6Settings: renderEngine.value === 'g6',
    showMotionBlur: renderEngine.value === 'cytoscape',
    // ... 更多可见性规则
  }
})
```

3. **切换方法**
```typescript
const setRenderEngine = (engine: 'cytoscape' | 'g6') => {
  const oldEngine = renderEngine.value
  renderEngine.value = engine
  
  // 日志
  log(`渲染引擎切换: ${oldEngine} → ${engine}`, 'normal')
  
  // 触发配置适配
  adaptConfigForEngine(engine)
  
  // 保存配置
  saveConfig()
}

// 配置适配：某些配置在不同引擎下有不同的默认值
const adaptConfigForEngine = (engine: 'cytoscape' | 'g6') => {
  if (engine === 'g6') {
    // G6 默认启用 WebGL
    config.value.webgl.enabled = true
    // G6 隐藏边的逻辑不同
    config.value.rendering.hideEdgesOnViewport = false
  } else {
    // Cytoscape 可能需要关闭某些配置
    // ...
  }
}
```

---

#### Task 5.2: starChart.store.ts 改造
**文件**: `stores/projectPage/starChart/starChart.store.ts`

**核心改造**: 支持双引擎数据格式

**关键修改**:

1. **新增状态**
```typescript
// 原有
const cytoscapeElements = ref<CytoscapeElement[]>([])

// 新增
const g6Data = ref<{ nodes: any[], edges: any[] } | null>(null)

// 计算属性：当前渲染数据
const currentRenderData = computed(() => {
  const configStore = useStarChartConfigStore()
  return configStore.renderEngine === 'g6' ? g6Data.value : cytoscapeElements.value
})
```

2. **改造 applyLayout 方法**
```typescript
const applyLayout = async () => {
  if (!rawGraphData.value) return
  
  const configStore = useStarChartConfigStore()
  const layoutEngine = layoutManager.getLayout(configStore.currentLayoutType)
  
  // 1. 计算布局（引擎无关）
  layoutedNodes.value = layoutEngine.compute(rawGraphData.value, configStore.layoutConfig)
  
  // 2. 根据渲染引擎选择转换器
  if (configStore.renderEngine === 'g6') {
    const transformer = new G6Transformer()
    g6Data.value = transformer.transform(
      layoutedNodes.value,
      rawGraphData.value.edges,
      configStore.config,
      layoutEngine.needsCytoscapeCompute()
    )
    console.log(`[Store] G6数据转换完成: ${g6Data.value.nodes.length} 节点`)
  } else {
    const transformer = new CytoscapeTransformer()
    cytoscapeElements.value = transformer.transform(
      layoutedNodes.value,
      rawGraphData.value.edges,
      configStore.config,
      layoutEngine.needsCytoscapeCompute()
    )
    console.log(`[Store] Cytoscape数据转换完成: ${cytoscapeElements.value.length} 元素`)
  }
}
```

**关键策略**:
- 保持两份数据（内存占用增加不大，简化逻辑）
- 仅转换当前使用的格式（性能优化）
- 切换引擎时重新转换数据

---

### 🔹 阶段六：依赖安装与配置（优先级：P0）

#### Task 6.1: 安装 G6 依赖

**核心依赖**:
```bash
npm install @antv/g6@^5.0.0 --save
```

**渲染器依赖（按需安装）**:
```bash
# Canvas 渲染器（G6 默认内置，无需额外安装）

# SVG 渲染器（可选）
npm install @antv/g-svg --save

# WebGL 渲染器（推荐安装，用于大规模数据）
npm install @antv/g-webgl --save
```

**版本选择**: 
- G6 v5（最新稳定版，TypeScript 支持完善）
- 渲染器版本需与 G6 主版本匹配

**安装策略**:
- 初期：只安装 G6 核心库（使用默认 Canvas）
- 后期优化：添加 WebGL 渲染器支持大规模数据

---

#### Task 6.2: package.json 依赖更新
```json
{
  "dependencies": {
    "@antv/g6": "^5.0.0",
    "@antv/g-webgl": "^1.0.0",      // WebGL 渲染器
    "@antv/g-svg": "^1.0.0",        // SVG 渲染器（可选）
    "cytoscape": "^3.28.1",
    "cytoscape-fcose": "^2.2.0"
  }
}
```

---

## 🎯 四、实施时间表

### 第一天（4-6小时）：基础架构
- [ ] Task 1.1: 渲染引擎接口定义 (1h)
- [ ] Task 1.2: 渲染器工厂实现 (1h)
- [ ] Task 1.3: 配置类型扩展 (1h)
- [ ] Task 2.1: G6Transformer核心逻辑 (2h)
- [ ] Task 6.1-6.2: 依赖安装 (0.5h)

### 第二天（4-6小时）：G6视口实现
- [ ] Task 2.2: SVG图标处理方案 (2h)
- [ ] Task 3.1: G6视口组件 (3h)
- [ ] Task 3.2: 容器组件智能路由 (1h)

### 第三天（3-4小时）：配置面板集成
- [ ] Task 4.1: 渲染引擎选择器 (1h)
- [ ] Task 4.2: 配置项智能显隐 (2h)
- [ ] Task 5.1: Config Store扩展 (1h)

### 第四天（2-3小时）：Store改造与测试
- [ ] Task 5.2: Store层改造 (2h)
- [ ] 集成测试与Bug修复 (2h)
- [ ] 性能对比测试 (1h)

**总计**: 约13-19小时（2-3个工作日）

---

## 🔍 五、关键技术难点与解决策略

### 难点 1: SVG图标在 G6 中的渲染

**问题**: Cytoscape 使用 CSS `background-image`，G6 需要在 Canvas 中绘制

**解决策略**:
```typescript
// 方案：注册 G6 自定义节点，使用 Image 形状
G6.registerNode('custom-svg-node', {
  draw(cfg, group) {
    // 复用 Cytoscape 的 SVG DataURL 生成逻辑
    const svgDataURL = generateNodeSVGDataURL(
      cfg.data.svgIcon,
      cfg.style.stroke,
      cfg.style.strokeOpacity,
      cfg.style.fill,
      cfg.style.fillOpacity
    )
    
    // 添加图片形状
    const image = group.addShape('image', {
      attrs: {
        x: -cfg.size / 2,
        y: -cfg.size / 2,
        width: cfg.size,
        height: cfg.size,
        img: svgDataURL
      },
      name: 'node-image'
    })
    
    // 添加边框圆形
    group.addShape('circle', {
      attrs: {
        r: cfg.size / 2,
        stroke: cfg.style.stroke,
        lineWidth: cfg.style.lineWidth,
        fill: 'transparent'
      },
      name: 'node-border'
    })
    
    return image
  },
  
  // 更新节点（高亮等状态变化）
  update(cfg, item) {
    const group = item.getContainer()
    const border = group.find(e => e.get('name') === 'node-border')
    
    // 更新边框样式实现高亮
    border.attr({
      stroke: cfg.style.stroke,
      lineWidth: cfg.style.lineWidth
    })
  }
})
```

**优势**: 完全复用现有 SVG 库，无需重写

---

### 难点 2: 高亮交互逻辑移植

**问题**: Cytoscape 通过 CSS class 实现高亮，G6 需要手动管理状态

**解决策略**:
```typescript
// 在 G6Viewport 中实现
const handleNodeHighlight = (evt: any) => {
  const node = evt.item
  const nodeId = node.getID()
  
  // 1. 高亮当前节点
  graphInstance.setItemState(node, 'highlight', true)
  
  // 2. 获取邻居节点
  const neighbors = node.getNeighbors('both')
  const edges = node.getEdges()
  
  // 3. 高亮一级邻居
  neighbors.forEach(neighbor => {
    graphInstance.setItemState(neighbor, 'neighbor', true)
  })
  
  // 4. 高亮相关边
  edges.forEach(edge => {
    graphInstance.setItemState(edge, 'highlight', true)
  })
  
  // 5. 淡化其他节点
  const allNodes = graphInstance.getNodes()
  const highlightedIds = new Set([nodeId, ...neighbors.map(n => n.getID())])
  
  allNodes.forEach(n => {
    if (!highlightedIds.has(n.getID())) {
      graphInstance.setItemState(n, 'dimmed', true)
    }
  })
}

// 取消高亮
const handleNodeUnhighlight = () => {
  // 清除所有状态
  graphInstance.getNodes().forEach(node => {
    graphInstance.clearItemStates(node)
  })
  graphInstance.getEdges().forEach(edge => {
    graphInstance.clearItemStates(edge)
  })
}

// 注册自定义节点时定义状态样式
G6.registerNode('custom-svg-node', {
  // ...
  setState(name, value, item) {
    const group = item.getContainer()
    const border = group.find(e => e.get('name') === 'node-border')
    
    if (name === 'highlight') {
      border.attr({
        lineWidth: value ? 4 : 2,
        shadowBlur: value ? 10 : 0,
        shadowColor: value ? '#409EFF' : 'transparent'
      })
    } else if (name === 'dimmed') {
      group.attr('opacity', value ? 0.3 : 1)
    }
  }
})
```

---

### 难点 3: 布局算法对接

**问题**: 不同布局在两个引擎中的参数名称和行为差异

**解决策略**: 创建布局配置适配器
```typescript
// adapters/g6-config-adapter.ts

export class G6LayoutAdapter {
  /**
   * 将通用布局配置转换为 G6 格式
   */
  adapt(layoutConfig: LayoutConfig): any {
    const type = layoutConfig.name
    
    switch(type) {
      case 'concentric':
        // 同心圆：使用 preset（位置已计算）
        return { type: 'preset' }
        
      case 'force-directed':
        // 力导向：映射参数
        const fdConfig = layoutConfig as ForceDirectedLayoutConfig
        return {
          type: 'force',
          preventOverlap: true,
          nodeSize: fdConfig.nodeSeparation,
          linkDistance: fdConfig.idealEdgeLength,
          nodeStrength: -fdConfig.nodeRepulsion,
          gravity: fdConfig.gravity,
          // G6特有参数
          alphaDecay: 0.028,
          alphaMin: 0.001
        }
        
      case 'hierarchical-lod':
        // 层次布局：使用 dagre
        return {
          type: 'dagre',
          rankdir: 'TB',
          nodesep: 40,
          ranksep: 80
        }
        
      default:
        return { type: 'force' }
    }
  }
}
```

---

### 难点 4: 性能监控迁移

**问题**: Cytoscape 的性能监控逻辑需要适配 G6

**解决策略**: 统一性能监控接口
```typescript
// 在 BaseRenderer 中定义
abstract class BaseRenderer implements IRenderer {
  protected performanceMonitor = {
    frameCount: 0,
    longFrameCount: 0,
    lastTimestamp: 0,
    
    recordFrame(duration: number) {
      this.frameCount++
      if (duration > 16.67) {  // >60fps
        this.longFrameCount++
      }
    },
    
    getSummary() {
      return {
        frameCount: this.frameCount,
        longFrameCount: this.longFrameCount,
        longFrameRatio: this.longFrameCount / this.frameCount
      }
    }
  }
}

// G6Renderer 实现
class G6Renderer extends BaseRenderer {
  setupPerformanceMonitoring() {
    // G6 的性能监控方式
    this.graph.on('afterrender', () => {
      const duration = performance.now() - this.performanceMonitor.lastTimestamp
      this.performanceMonitor.recordFrame(duration)
      this.performanceMonitor.lastTimestamp = performance.now()
    })
  }
}
```

---

## 📊 六、测试验证计划

### 测试矩阵

| 测试项 | Cytoscape | G6 | 优先级 |
|--------|-----------|-----|--------|
| **基础渲染** | ✅ | 🔲 | P0 |
| 同心圆布局 | ✅ | 🔲 | P0 |
| 力导向布局 | ✅ | 🔲 | P0 |
| 层次LOD布局 | ✅ | 🔲 | P1 |
| **交互功能** | | | |
| 节点拖拽 | ✅ | 🔲 | P0 |
| 缩放平移 | ✅ | 🔲 | P0 |
| 节点高亮 | ✅ | 🔲 | P0 |
| 框选功能 | ✅ | 🔲 | P1 |
| **数据规模** | | | |
| 30节点（mock-normal） | ✅ | 🔲 | P0 |
| 400节点（mock-large） | ✅ | 🔲 | P0 |
| 3.4万节点（mcrecipe） | ⚠️ | 🔲 | P1 |
| **配置切换** | | | |
| 引擎切换无报错 | - | 🔲 | P0 |
| 视口状态保持 | - | 🔲 | P1 |
| 配置智能显隐 | - | 🔲 | P0 |
| **性能指标** | | | |
| 首次渲染时间 | ✅ | 🔲 | P0 |
| 交互帧率 | ✅ | 🔲 | P0 |
| 内存占用 | ✅ | 🔲 | P1 |

---

## 🎯 七、风险评估与应对

### 风险 1: G6 学习曲线 (中等)
**影响**: 开发时间可能延长  
**应对**: 
- 先实现基础功能（preset布局 + 基础交互）
- 复杂功能（自定义节点、高级动画）后续迭代
- 充分利用官方文档和示例

### 风险 2: 两套渲染引擎维护成本 (低)
**影响**: 代码量增加，维护复杂度提升  
**应对**:
- 通过接口抽象隔离差异
- 核心逻辑（数据层、布局层）共享
- 良好的文档和注释

### 风险 3: 用户切换引擎时的体验 (中等)
**影响**: 切换过程可能卡顿或出错  
**应对**:
- 添加切换动画和加载提示
- 保存切换前的视口状态
- 失败时优雅回退
- 添加性能对比提示

### 风险 4: G6 的 WebGL 兼容性 (低)
**影响**: 部分设备不支持 WebGL  
**应对**:
- 自动降级到 Canvas 渲染
- 配置面板提示当前渲染模式
- 提供兼容性检测

---

## 📝 八、总结与展望

### 完成后的收益
1. **性能提升**: 大规模数据（1000+节点）渲染性能提升 3-5 倍
2. **可扩展性**: 插件化架构，未来可继续添加其他渲染引擎
3. **用户选择**: 用户可根据需求和设备选择最优引擎
4. **技术储备**: 为知识图谱、MC配方图等大规模数据可视化打基础

### 后续优化方向
1. **渲染引擎自动选择**: 根据节点数量自动推荐最优引擎
2. **混合渲染**: 小规模用 Cytoscape，大规模自动切换 G6
3. **性能对比面板**: 实时显示两种引擎的性能指标
4. **更多布局算法**: G6 支持更多内置布局（环形、树形、矩阵）

---

---

## 🔄 九、G6 渲染器机制总结（重要补充）

### G6 v5 渲染器正确使用方式

根据官方文档，G6 v5 的渲染器配置与之前的理解有所不同：

**关键要点**:

1. **渲染器需要单独安装**
   ```bash
   npm install @antv/g-canvas    # Canvas 渲染器（内置）
   npm install @antv/g-webgl     # WebGL 渲染器
   npm install @antv/g-svg       # SVG 渲染器
   ```

2. **渲染器配置是函数，不是字符串**
   ```typescript
   // ❌ 错误方式（旧版本）
   renderer: 'webgl'
   
   // ✅ 正确方式（G6 v5）
   import { Renderer as WebGLRenderer } from '@antv/g-webgl'
   renderer: () => new WebGLRenderer()
   ```

3. **支持分层渲染**
   ```typescript
   // 不同画布层使用不同渲染器
   renderer: (layer) => {
     if (layer === 'main') return new WebGLRenderer()  // 主画布高性能
     return new CanvasRenderer()  // 其他层通用渲染
   }
   ```

4. **运行时动态切换**
   ```typescript
   // G6 支持运行时切换渲染器
   graph.setOptions({
     renderer: () => new SVGRenderer()
   })
   ```

### 架构优势

**分层渲染策略**:
```
┌─────────────────────────────────────┐
│  标签层 (Canvas)      - 文字清晰   │
├─────────────────────────────────────┤
│  交互层 (Canvas)      - 响应灵敏   │
├─────────────────────────────────────┤
│  主画布层 (WebGL)     - 高性能渲染 │
└─────────────────────────────────────┘
```

**性能对比**:
| 渲染器 | 小规模(<500) | 中规模(500-2000) | 大规模(2000+) | SVG导出 |
|--------|-------------|-----------------|--------------|---------|
| Canvas | 优秀 ✅     | 良好 ✅         | 一般 ⚠️     | 不支持 ❌ |
| WebGL  | 良好 ✅     | 优秀 ✅         | 优秀 ✅     | 不支持 ❌ |
| SVG    | 良好 ✅     | 较慢 ⚠️        | 较慢 ❌     | 支持 ✅ |

### 实施建议

**渐进式策略**:
1. **阶段一**: 只使用 Canvas 渲染器（快速验证功能）
2. **阶段二**: 添加 WebGL 渲染器（优化大规模数据）
3. **阶段三**: 添加 SVG 渲染器（支持矢量导出）
4. **阶段四**: 实现智能渲染器选择（根据节点数自动切换）

**配置面板策略**:
- 小数据集（<500节点）：默认 Canvas
- 中数据集（500-2000节点）：Canvas 或 WebGL 可选
- 大数据集（2000+节点）：强烈推荐 WebGL
- 导出需求：提供 SVG 渲染器切换

---

## 📊 十、关键差异对比表

### G6 vs Cytoscape 实现差异

| 特性 | Cytoscape | G6 | 实现难度 |
|------|-----------|-----|---------|
| **渲染器配置** | 内置，通过配置项 | 需要导入实例 | 中等 |
| **SVG图标** | background-image | Canvas绘制或Image | 中等 |
| **高亮逻辑** | CSS类名 | 状态管理API | 中等 |
| **布局计算** | 内置算法 | 内置算法 | 低 |
| **事件系统** | `cy.on('tap')` | `graph.on('node:click')` | 低 |
| **性能监控** | 自定义 | 自定义 | 低 |
| **分层渲染** | 不支持 | 原生支持 | G6优势 |
| **动画系统** | 基础 | 强大 | G6优势 |

### 配置映射关系

| 配置项 | Cytoscape | G6 | 备注 |
|--------|-----------|-----|------|
| WebGL加速 | `renderer: 'webgl'` | `() => new WebGLRenderer()` | G6需导入 |
| 滚轮灵敏度 | `wheelSensitivity` | `modes.default` | 通用配置 |
| 节点拖拽 | `autoungrabify` | `'drag-node'` | 实现方式不同 |
| 框选功能 | `boxSelectionEnabled` | `'brush-select'` | 实现方式不同 |
| 动态模糊 | `motionBlur` | 不支持 | Cytoscape专属 |
| 分层渲染 | 不支持 | `renderer: (layer)` | G6专属 |

---

## 🎯 十一、最终实施路线图

### Week 1: 基础架构 ✅
- [x] Day 1: 类型定义 + 依赖安装
- [x] Day 2: G6Transformer + 数据转换
- [x] Day 3: 基础 G6Viewport（Canvas渲染器）
- [x] Day 4: 容器组件智能路由

### Week 2: 功能完善 🔄
- [ ] Day 1: SVG图标实现（方案A: Image）
- [ ] Day 2: 高亮交互逻辑移植
- [ ] Day 3: 布局算法适配器
- [ ] Day 4: 配置面板集成

### Week 3: 高级特性 ⏳
- [ ] Day 1: WebGL渲染器集成
- [ ] Day 2: 分层渲染优化
- [ ] Day 3: 智能渲染器选择
- [ ] Day 4: 性能监控适配

### Week 4: 测试优化 ⏳
- [ ] Day 1: 功能测试（所有布局+交互）
- [ ] Day 2: 性能测试（对比数据）
- [ ] Day 3: Bug修复 + 文档完善
- [ ] Day 4: 发布 + 用户反馈收集

---

## 📝 十二、检查清单

### 开发前检查 ✅
- [x] 理解 G6 渲染器机制
- [x] 确认依赖版本兼容性
- [x] 设计数据流架构
- [x] 制定渐进式实施计划

### 开发中检查 🔄
- [ ] 每个功能都有 Cytoscape 对照实现
- [ ] 类型定义完整且正确
- [ ] 错误处理和优雅降级
- [ ] 性能监控代码就绪
- [ ] 配置项智能显隐正确

### 开发后检查 ⏳
- [ ] 所有布局算法正常工作
- [ ] 所有交互功能正常工作
- [ ] 切换渲染引擎无报错
- [ ] 性能指标达到预期
- [ ] 文档完整且准确

---

**Boss，这个完整的计划已经包含了：**

1. ✅ **完整的架构设计**（数据与布局分离）
2. ✅ **详细的TODO清单**（4个阶段，每个任务都有思路和代码策略）
3. ✅ **文件架构修改树**（清晰标注新增/修改/保留）
4. ✅ **正确的G6渲染器使用方式**（基于官方文档）
5. ✅ **配置面板完整集成方案**（包含G6渲染器选择）
6. ✅ **智能渲染器选择策略**（根据节点数自动优化）
7. ✅ **关键技术难点解决方案**（SVG图标、高亮逻辑、布局适配）
8. ✅ **实施时间表**（2-3个工作日）
9. ✅ **风险评估与应对**（4个主要风险）
10. ✅ **测试验证计划**（完整的测试矩阵）

所有设计都基于当前项目的架构，保证平滑扩展且不影响现有功能。准备好开始实施了吗？🚀