我来分析哪个方案改动最少，然后汇总完整的行动计划。

[7 tools called]

## 📊 **方案对比分析**

### **方案1：改回原始名称** ✅ **推荐**

改动文件：2个 | 改动行数：6行

```typescript
// llm-translate-service.ts 线117-131
this.emit('task:progress', event)        // 改自 progress-updated
this.emit('task:complete', event)        // 改自 completed  
this.emit('task:error', event)           // 改自 error-occurred

// translate.store.ts 线542, 577
'llm-translate:task-progress'            // 改自 task-progress-updated
'llm-translate:task-error'               // 改自 task-error-occurred
// task-complete 已经正确，不用改
```

**优势**：
- ✅ 改动最少（2个文件，6行）
- ✅ 逻辑最清晰（恢复原设计）
- ✅ 影响最小化
- ✅ 与IPC处理器现有设计一致

---

### **方案2：改IPC处理器到新名称**

改动文件：1个 | 改动行数：8行

```typescript
// llm-translate-handlers.ts 线93, 99, 105
llmTranslateService.on('task:progress-updated', ...)
llmTranslateService.on('task:completed', ...)
llmTranslateService.on('task:error-occurred', ...)
// 以及对应的send调用也要改
```

**劣势**：
- ❌ IPC处理器逻辑复杂化
- ❌ 新名称与原IPC设计不符
- ⚠️ 前端已经用了新名称，无法完全同步

---

**✅ 选择方案1**（改回原始名称）

---

## 🎯 **完整行动计划**

### **第一部分：事件链路修复**

#### **P0-1: 恢复事件名称** (2个文件，6行)

**修改文件1**: `llm-translate-service.ts` 线117-131
```diff
- this.emit('task:progress-updated', event)
+ this.emit('task:progress', event)

- this.emit('task:completed', event)
+ this.emit('task:complete', event)

- this.emit('task:error-occurred', event)
+ this.emit('task:error', event)
```

**修改文件2**: `translate.store.ts` 线542, 577
```diff
- ;(window as any).nimbria.on('llm-translate:task-progress-updated', ...)
+ ;(window as any).nimbria.on('llm-translate:task-progress', ...)

- ;(window as any).nimbria.on('llm-translate:task-error-occurred', ...)
+ ;(window as any).nimbria.on('llm-translate:task-error', ...)
```

**预期效果**：
- ✅ 前端能收到进度更新
- ✅ 前端能收到任务完成
- ✅ 调度器能继续处理下一批

---

### **第二部分：业务逻辑优化**

#### **P0-2: 流式写入改整体写入** (task-state-manager.ts)

**改动**: 移除 `updateProgress()` 中的数据库写入

```typescript
// 线149：删除这行
// await this.persistProgress(taskId, progress, currentTokens, updated.translation || '')
```

**理由**：
- 流式进度仅用于UI显示（通过事件）
- 最终结果在 `markComplete()` 时一次性写入
- 减少数据库写入频次（从数百次 → 2-3次）
- 如果任务中断，进度数据被error数据覆盖，无需保留

**修改点**：
```typescript
async updateProgress(taskId, chunk, currentTokens) {
  const current = this.stateCache.get(taskId)
  if (!current) return

  // 计算进度
  const progress = Math.min((currentTokens / current.estimatedTokens) * 100, 100)
  
  // ✅ 只更新内存缓存
  this.stateCache.set(taskId, {
    ...current,
    progress,
    currentTokens,
    translation: (current.translation || '') + chunk
  })

  // ✅ 节流发射UI事件（保留）
  if (this.shouldEmitProgress(taskId)) {
    this.emit('progress:update', {...})
    this.progressUpdateThrottle.set(taskId, Date.now())
  }
  // ❌ 删除: await this.persistProgress(...)
}
```

---

#### **P0-3: waiting 状态保持不变**

**改动**: `llm-translate-service.ts` 线197-233 `handleTerminatedTasks()`

```typescript
private async handleTerminatedTasks(): void {
  if (!this.projectDatabase) return

  const waitingTasks = this.projectDatabase.query(
    `SELECT ... FROM Llmtranslate_tasks WHERE status = 'waiting'`
  )

  if (waitingTasks.length > 0) {
    console.log(`⚠️ [LlmTranslateService] 发现 ${waitingTasks.length} 个等待中的任务，保持状态不变`)
    // ✅ 什么都不做，让这些任务保留为 waiting 状态
    // 用户重启后可以手动点击"发送"重新提交，或点击"取消等待"改回 unsent
  }
}
```

**理由**：
- waiting 状态表示"队列中，等待发送"
- 程序重启后这些任务保留为 waiting，用户可以选择：
  - 继续发送（点击"发送"按钮）
  - 取消等待（点击"取消等待"按钮，状态改回 unsent）
- 不需要特殊标记或 terminated 状态，逻辑简洁清晰

---

#### **P0-4: sending → error（异常重启）**

**改动**: `llm-translate-service.ts` 线243-277 `handleRecoveryTasks()`

```typescript
private async handleRecoveryTasks(): void {
  if (!this.projectDatabase) return

  const sendingTasks = this.projectDatabase.query(
    `SELECT ... FROM Llmtranslate_tasks WHERE status = 'sending'`
  )

  if (sendingTasks.length > 0) {
    console.log(`⚠️ [LlmTranslateService] 发现 ${sendingTasks.length} 个异常中止任务，已标记为 error`)
    
    // 标记为 error，错误类型为 APP_CRASHED
    this.projectDatabase.execute(
      `UPDATE Llmtranslate_tasks 
       SET status = 'error', 
           error_type = 'APP_CRASHED',
           error_message = '程序异常中止，任务未完成。请检查API或重新发送',
           updated_at = CURRENT_TIMESTAMP
       WHERE status = 'sending'`
    )
    
    // 更新批次统计
    const batchIds = new Set(sendingTasks.map(t => t.batchId))
    for (const batchId of batchIds) {
      await this.updateBatchStats(batchId)
    }
  }
}
```

**理由**：
- `sending` 状态表示"正在API调用中"
- 如果程序异常重启，这些任务可能已部分处理或完全未处理，状态不明确
- 标记为 error 并清晰指出原因，用户可以：
  - 检查API是否成功处理（查看数据库或API日志）
  - 如果确实失败，点击"重试"
  - 如果成功，手动标记为完成

---

### **第三部分：UI优化**

#### **P1: 等待中卡片优化** (TaskManagePage.vue)

**改动1**: 修改 `.task-card.waiting` 的背景色为橙黄色

```vue
<style scoped>
.task-card.waiting {
  background-color: #fef3c7;  /* 橙黄色 */
  border-color: #fcd34d;
}

.task-card.waiting:hover {
  background-color: #fde68a;
}
</style>
```

**改动2**: 添加"取消等待"按钮

```vue
<template>
  <!-- 在 waiting 状态的任务卡片中 -->
  <div v-if="task.status === 'waiting'" class="task-actions">
    <el-button 
      size="small" 
      type="warning"
      @click="handleCancelWaiting(task.id)"
    >
      取消等待
    </el-button>
  </div>
</template>

<script setup>
// 取消等待：waiting → unsent，从调度队列移除
const handleCancelWaiting = async (taskId: string) => {
  try {
    // 1. 调用后端API将任务状态改为 unsent
    await window.nimbria.invoke('llm-translate:cancel-waiting-task', { taskId })
    
    // 2. 更新本地任务状态
    const task = taskList.value.find(t => t.id === taskId)
    if (task) {
      task.status = 'unsent'
    }
    
    ElMessage.success('已取消等待')
  } catch (error) {
    ElMessage.error('取消失败')
  }
}
</script>
```

**后端支持** (llm-translate-service.ts 新增方法):

```typescript
/**
 * 取消等待中的任务
 * 将 waiting → unsent，从调度队列移除
 */
async cancelWaitingTask(taskId: string): Promise<void> {
  if (!this.projectDatabase) return
  
  // 更新数据库状态
  this.projectDatabase.execute(
    `UPDATE Llmtranslate_tasks 
     SET status = 'unsent', updated_at = CURRENT_TIMESTAMP 
     WHERE id = ? AND status = 'waiting'`,
    [taskId]
  )
  
  // 从调度器队列中移除（如果调度器正在运行）
  const task = await this.getTask(taskId)
  if (task) {
    const scheduler = this.schedulers.get(task.batchId)
    if (scheduler) {
      scheduler.removeTaskFromQueue(taskId)
    }
  }
  
  console.log(`✂️ [LlmTranslateService] 任务 ${taskId} 已取消等待`)
}
```

**理由**：
- waiting (橙黄) ≠ sending (蓝色)，视觉上清晰区分队列状态和执行状态
- 用户可以灵活控制队列：如果不想发送某个 waiting 任务，可以取消回到 unsent
- 配合 P0-3 的设计，用户重启后可以选择继续发送或取消等待

---

## 📋 **执行清单**

| 优先级 | 任务 | 文件 | 改动 | 预期效果 |
|--------|------|------|------|---------|
| 🔴 P0 | 恢复事件名称 | llm-translate-service.ts | 3行 | ✅ 前端收到进度/完成/错误 |
| 🔴 P0 | 恢复事件名称 | translate.store.ts | 2行 | ✅ 前端能监听到事件 |
| 🔴 P0 | 流式写入改整体写入 | task-state-manager.ts | -1行 | ✅ 减少DB写入，日志清洁 |
| 🔴 P0 | waiting保持不变 | llm-translate-service.ts | 删除逻辑 | ✅ 简化恢复流程 |
| 🔴 P0 | sending改error | llm-translate-service.ts | +15行 | ✅ 清晰表示异常中止 |
| 🟡 P1 | 等待中卡片优化 | TaskManagePage.vue + llm-translate-service.ts | 新增功能 | ✅ UI清晰+取消等待 |

---

## 🚀 **执行步骤**

### **Step 1: 修复事件链路** (立即修复调度器阻塞)
```bash
1. 改 llm-translate-service.ts 3个emit
2. 改 translate.store.ts 2个监听
3. 验证：重启后进度条应该动了
```

### **Step 2: 优化流式写入** (减少DB压力)
```bash
1. 注释 task-state-manager.ts 的persistProgress调用
2. 验证：日志应该干净得多
```

### **Step 3: 简化异常处理** (清晰的恢复流程)
```bash
1. 改 handleTerminatedTasks: 删除所有处理逻辑，waiting 保持不变
2. 改 handleRecoveryTasks: sending → error (APP_CRASHED)
3. 验证：重启测试，waiting 任务保持原样，sending 任务变为 error
```

### **Step 4: UI改进 + 取消等待功能**
```bash
1. 改 TaskManagePage.vue 的等待中卡片样式为橙黄色
2. 添加"取消等待"按钮（waiting → unsent）
3. 实现后端 cancelWaitingTask 方法
4. 添加 IPC handler: 'llm-translate:cancel-waiting-task'
5. 验证：点击"取消等待"，任务回到 unsent 状态
```

---

