我会使用 SequentialThinking 工具来深入分析用户提出的新需求。让我系统地分析当前架构、已完成的工作和新需求的实现方案。

[8 tools called]

---

## 📋 **分析完成 - 完整设计方案**

基于 Sequential Thinking 深度分析，我为用户整理了关于三个新功能需求的完整实现方案。由于用户要求仅分析不编辑，以下是详细的架构分析报告：

---

## 🎯 **当前项目状态总结**

### **已完成的核心能力**（来自三份工作总结）
```
✅ 单任务执行：LlmTranslationClient（流式翻译、token计数、错误分类）
✅ 状态管理：TaskStateManager（实时追踪、进度计算、4类事件驱动）
✅ 事件架构：完整的 Service → IPC → Store → UI 链路
✅ 错误处理：RATE_LIMIT、TIMEOUT、NETWORK等分类
✅ 限流重试：已能区分429vs其他错误
✅ 任务取消：cancel流程完整
✅ UI展示：进度条、状态标签、详情抽屉
```

**缺少的能力**：
- ❌ 批量调度（并发控制）
- ❌ 队列管理（排队、等待）
- ❌ 限流恢复机制（探针、定时测试）
- ❌ Token预估（基于已完成任务回归）

---

## 🏗️ **三个新功能的完整设计方案**

### **功能1：Token回归估计模式**

#### 核心原理
```
已完成任务收集 → { contentLength, outputTokens, modelId } 
                  ↓
            回归分析（多元线性回归）
                  ↓
          预估其他任务的outputTokens
                  ↓
            进度条基准值更新
```

#### 实现架构
| 层级 | 组件 | 职责 |
|-----|------|------|
| **Electron** | TokenRegressionEstimator | 维护样本库、计算回归系数、估值 |
| **Service** | LlmTranslateService | 在taskComplete时记录样本 |
| **前端** | HomePage.vue | 显示模式选择（预计/等额/回归） |
| **类型** | types/config.ts | TokenEstimationMode enum |

#### 关键设计决策
```typescript
// 样本要求
const MIN_SAMPLES = 3  // 至少3个同模型任务完成
const SAMPLE_GROUP_BY = 'modelId'  // 按模型分组

// 回归训练触发
在 TaskStateManager.emit('task:complete') 时
→ 保存 { inputLength, outputTokens, modelId }
→ 维护滑动窗口（最新100个样本）

// 预估调用时机
任务进入waiting状态前
→ 调用 estimator.estimate(contentLength, modelId)
→ 若样本不足 → 降级到指定的预计值或等额
→ 将结果保存到 task.predictedTokens
```

#### 需要埋的钩子（Electron层）
```
✓ 在 TaskStateManager 中
  - onTaskComplete: 记录样本 { inputLength, actualTokens, modelId }
  
✓ 在 LlmTranslateService 中
  - estimateTokens(taskId): 返回预估值
  
✓ 通过IPC暴露
  - estimate-tokens: 前端调用预估接口
```

---

### **功能2：批次调度器（核心功能）**

#### 系统架构设计

```typescript
// 核心类结构
class BatchScheduler {
  // 状态
  private waitingQueue: TaskId[]        // 待发送队列
  private activeSet: Set<TaskId>        // 执行中的任务
  private maxConcurrency: number        // 最大并发数
  private throttledUntil: number        // 限流恢复时间戳
  
  // 核心方法
  async start()                         // 启动调度循环
  async processQueue()                  // 处理队列
  async handleTaskComplete(taskId)      // 任务完成→发送下一批
  async handleTaskError(taskId)         // 任务失败处理
  async handleThrottled()               // 限流暂停
}
```

#### 调度流程设计（事件驱动）

```
┌─ 用户点击"发送"
│
├─ 前端：selectTasks → datasource.sendTasks()
│
├─ IPC：llm-translate:submit-tasks
│
├─ 后端：llmTranslateService.submitTasks()
│   │
│   ├─ 将任务标记为 waiting（写入DB）
│   │
│   ├─ 创建 BatchScheduler 实例
│   │
│   └─ 调用 scheduler.start()
│
├─ 调度器核心循环：
│   ├─ 检查 activeCount < maxConcurrency
│   │
│   ├─ 从waitingQueue取出 min(remaining, maxConcurrency)
│   │
│   ├─ 调用 executor.executeTasks(taskId) ← 仍用现有方法！
│   │
│   ├─ 监听 taskStateManager.on('task:complete')
│   │
│   └─ activeCount-- → processQueue() ← 触发下一批
│
└─ 循环直到 waitingQueue 为空
```

#### 三个关键决策点

| 决策 | 选项A | 选项B | **推荐** |
|-----|------|------|--------|
| **发送策略** | 定时loop（setInterval） | 事件驱动 | **事件驱动** |
| **超时方式** | 固定时间（30s） | 动态计算 | **固定+可配** |
| **流式特殊处理** | 无chunk→error | 流式不计超时 | **无数据N秒→error** |

#### 配置参数（需要在UI中可配）

```typescript
interface SchedulerConfig {
  maxConcurrency: number                  // 最大并发数（1-10）
  taskTimeoutSeconds: number              // 普通任务超时（5-120s）
  streamNoDataTimeoutSeconds: number      // 流式无数据超时（10-60s）
  throttleProbeIntervalSeconds: number    // 限流探针间隔（5-30s）
  throttleProbeType: 'quick' | 'api'      // 探针类型
  autoRetryThrottled: boolean             // 限流后自动重试
  schedulingStrategy: 'timed' | 'event'   // 调度策略
}
```

#### 与现有机制的整合（最小改动！）

```
✗ 不修改 TranslationExecutor.executeTasks()
✓ 调度器作为上层协调者
✓ 利用现有的 TaskStateManager 事件
✓ 监听 'task:complete' / 'task:error' 触发下一批
```

---

### **功能3：限流测试与恢复机制**

#### 限流处理流程

```
后端发生429错误
   ↓
errorType 标记为 RATE_LIMIT
   ↓
TaskStateManager.emit('task:error', { errorType: 'RATE_LIMIT' })
   ↓
BatchScheduler 监听到 RATE_LIMIT
   ↓
├─ 停止processQueue()
├─ 启动 ThrottleProbe.startProbing()
└─ 设置恢复时间戳
   ↓
ThrottleProbe 定时发送测试请求
   ├─ 快速模式：发送最小化请求（可能是head请求或ping）
   └─ API模式：调用API发送短内容
   ↓
收到200响应
   ↓
├─ 通知调度器恢复
└─ 根据 autoRetryThrottled：
   ├─ true: 将失败的任务重新加入waitingQueue
   └─ false: 标记为throttled状态，等用户手动操作
```

#### ThrottleProbe类设计

```typescript
class ThrottleProbe {
  private modelId: string
  private config: ProbeConfig
  private lastProbeTime: number
  
  // 探针方法
  async quickProbe(): Promise<boolean>      // 轻量级检查
  async apiProbe(): Promise<boolean>        // 调用实际API
  
  // 恢复管理
  async startProbing()                      // 启动定时探测
  async reset()                             // 重置状态
  
  // 事件
  on('recovered', callback)                 // 恢复事件
}
```

#### 手动限流测试入口

```
UI: TaskManagePage 工具栏
   └─ 按钮位置：当前已有的 testThrottle() 按钮
   
行为：
1. 用户点击 testThrottle
2. 前端调用 datasource.testThrottle()
3. IPC: llm-translate:test-throttle
4. 后端：probe.apiProbe() 或 probe.quickProbe()
5. 返回结果：{ status: 'ok' | 'throttled', responseTime }
6. UI显示：状态提示 + 响应时间
```

---

## 🎨 **前端UI改动清单**

### **改动1：标签修改**
```
HomePage.vue 中的并发数
❌ 改前：每分钟最高并发数
✅ 改后：最高并发数
```

### **改动2：任务列表排序**
```typescript
// 新的排序优先级
const TASK_STATUS_ORDER = [
  'sending',      // 1️⃣ 发送中（最优先显示）
  'waiting',      // 2️⃣ 排队中
  'throttled',    // 3️⃣ 被限流
  'completed',    // 4️⃣ 已完成
  'error',        // 5️⃣ 错误
  'unsent'        // 6️⃣ 未发送
]
```

### **改动3：工具栏"更多配置"按钮**
```
位置：TaskManagePage 工具栏第2行最右边
图标：齿轮icon (SettingOutlined)
行为：点击 → 从右边打开 SchedulerConfigDrawer

SchedulerConfigDrawer 内容：
├─ 【基础设置】
│  ├─ 最高并发数（slider 1-10）
│  ├─ 任务超时时间（input 5-120s）
│  └─ 流式无数据超时（input 10-60s）
│
├─ 【限流处理】
│  ├─ 限流探针间隔（input 5-30s）
│  ├─ 探针类型（radio: 快速 / API调用）
│  └─ 自动重发限流任务（checkbox）
│
└─ 【高级选项】
   ├─ 调度策略（radio: 事件驱动 / 定时）
   └─ 保存按钮
```

---

## 📊 **文件变更规划**

### **新增文件**
```
src-electron/services/llm-translate-service/
├─ batch-scheduler.ts                    ← 调度器核心
├─ throttle-probe.ts                     ← 限流探针
└─ token-regression-estimator.ts         ← Token回归估计

Client/GUI/DemoPage/LlmTranslate/
├─ components/SchedulerConfigDrawer.vue  ← 配置抽屉
└─ types/scheduler.ts                    ← 调度器类型
```

### **修改文件**
```
后端核心：
- src-electron/services/llm-translate-service/llm-translate-service.ts
  ├─ 初始化 scheduler, probe, estimator
  ├─ submitTasks() 改为使用 scheduler
  └─ 暴露 testThrottle() 方法

- src-electron/services/llm-translate-service/task-state-manager.ts
  └─ 在 task:complete 时记录样本

- src-electron/ipc/main-renderer/llm-translate-handlers.ts
  ├─ 新增 test-throttle handler
  └─ 转发 scheduler 事件

前端UI：
- Client/GUI/DemoPage/LlmTranslate/components/TaskManagePage.vue
  ├─ 修改排序逻辑
  ├─ 加"更多配置"按钮
  └─ 移除 testThrottle 中的mock

- Client/GUI/DemoPage/LlmTranslate/components/HomePage.vue
  └─ 标签改为"最高并发数"

- Client/GUI/DemoPage/LlmTranslate/stores/translate.store.ts
  ├─ 新增 schedulerConfig 状态
  └─ 新增 updateSchedulerConfig() action

- Client/GUI/DemoPage/LlmTranslate/types/config.ts
  └─ 新增 SchedulerConfig 类型

类型系统：
- src-electron/types/LlmTranslate/backend/events.ts
  ├─ ThrottleRecoveredEvent
  └─ ThrottleTestResultEvent
```

---

## ⚠️ **关键风险点 & 解决方案**

| 风险 | 影响 | 缓解方案 |
|-----|------|---------|
| **并发过高导致更多429** | 陷入反复限流 | 添加自适应降速：检测到429频率>50% → 自动降低maxConcurrency |
| **流式超时检测不准确** | 误杀正常任务 | 使用chunk时间戳，10秒内有任何chunk更新都重置计时器 |
| **样本不足回归失败** | token预估错误 | 样本<3时降级到"等额"或"预计值"模式 |
| **调度器内存泄漏** | 长时间运行OOM | 任务完成后立即清理，使用WeakMap缓存 |
| **事件监听重复注册** | 消息重复处理 | 调度器start时检查 `if(isRunning) return` |

---

## 🔄 **推荐实现顺序**

```
优先级顺序（按依赖关系）：

1️⃣ BatchScheduler        【基础设施】
   └─ 为调度器打好基础

2️⃣ UI改动（排序、按钮）   【可见收益】
   └─ 用户可以看到变化

3️⃣ SchedulerConfigDrawer 【用户交互】
   └─ 让用户能配置参数

4️⃣ ThrottleProbe        【限流恢复】
   └─ 处理429的关键机制

5️⃣ TokenRegressionEstimator 【优化功能】
   └─ 改进体验但不是核心
```

---

## 📁 **详细的文件夹架构修改树**

### **后端结构调整（Electron主进程）**

```
Nimbria/src-electron/services/llm-translate-service/
├─ llm-translate-service.ts          ✏️ 修改
│  └─ 新增属性：scheduler, probe, estimator
│  └─ 修改方法：submitTasks(), constructor()
│  └─ 新增方法：estimateTokens(), testThrottle(), setupSchedulerListeners()
│
├─ translation-executor.ts            ✅ 保持不变（不修改！）
│
├─ task-state-manager.ts              ✏️ 修改
│  └─ 在 emit('task:complete') 时记录样本
│  └─ 调用 estimator.addSample()
│
├─ batch-scheduler.ts                 ✨ 新增
│  └─ 导出类：BatchScheduler
│  ├─ 构造器：constructor(batchId, taskIds, config, maxConcurrency)
│  ├─ 核心属性：waitingQueue, activeSet, throttledUntil, isRunning
│  ├─ 核心方法：
│  │  ├─ start(): 启动调度循环
│  │  ├─ stop(): 暂停调度
│  │  ├─ processQueue(): 处理排队任务
│  │  ├─ handleTaskComplete(taskId): 任务完成→发送下一批
│  │  ├─ handleTaskError(taskId, errorType): 错误处理
│  │  ├─ handleThrottled(): 限流暂停
│  │  └─ getStatus(): 返回调度器状态
│
├─ throttle-probe.ts                  ✨ 新增
│  └─ 导出类：ThrottleProbe
│  ├─ 构造器：constructor(modelId, config)
│  ├─ 核心方法：
│  │  ├─ quickProbe(): 轻量级连接检查
│  │  ├─ apiProbe(): 实际API短请求测试
│  │  ├─ startProbing(): 启动定时探测循环
│  │  ├─ stopProbing(): 停止探测
│  │  └─ reset(): 重置状态
│  └─ 事件系统：on(event, callback) - 发射 'recovered', 'testFailed' 事件
│
└─ token-regression-estimator.ts      ✨ 新增
   └─ 导出类：TokenRegressionEstimator
   ├─ 构造器：constructor()
   ├─ 内部状态：samples(滑动窗口≤100), coefficients(回归系数)
   ├─ 核心方法：
   │  ├─ addSample(sample): 添加完成任务样本
   │  ├─ train(): 执行回归计算（样本≥3时）
   │  ├─ estimate(contentLength, modelId): 预估输出token数
   │  ├─ hasSufficientSamples(modelId): 检查样本是否充分
   │  └─ getSampleCount(modelId): 获取指定模型的样本数
   └─ 按 modelId 分组维护样本库
```

### **IPC层改动**

```
Nimbria/src-electron/ipc/main-renderer/llm-translate-handlers.ts ✏️ 修改
├─ 修改现有Handler：
│  └─ 'llm-translate:submit-tasks': 改为使用 scheduler 而非直接调用 executor
│
├─ 新增Handler：
│  ├─ 'llm-translate:test-throttle': 手动限流测试
│  │  └─ 返回 { status: 'ok'|'throttled', responseTime: ms }
│  │
│  ├─ 'llm-translate:update-scheduler-config': 更新调度器配置
│  │  └─ 接收 SchedulerConfig，存储到当前batch
│  │
│  └─ 'llm-translate:get-scheduler-config': 获取当前配置
│     └─ 返回当前batch的scheduler配置
│
└─ 新增事件广播函数：setupSchedulerEventBroadcast()
   ├─ 监听 scheduler 的状态变化事件
   ├─ 向所有渲染进程发送 'llm-translate:scheduler-status-changed'
   └─ 监听 probe 的恢复事件
      └─ 向渲染进程发送 'llm-translate:throttle-recovered'
```

### **类型系统扩展（保持现有规范）**

```
Nimbria/src-electron/types/LlmTranslate/
├─ backend/
│  ├─ events.ts                       ✏️ 修改
│  │  ├─ 新增类型：ThrottleRecoveredEvent
│  │  ├─ 新增类型：ThrottleTestResultEvent
│  │  └─ 新增类型：SchedulerStatusChangedEvent
│  │
│  └─ scheduler.ts                    ✨ 新增（后端独有类型）
│     ├─ 导出：SchedulerOptions (配置选项)
│     ├─ 导出：TokenRegressionSample (样本结构)
│     └─ 导出：内部使用的scheduler状态类型
│
├─ client/
│  └─ index.ts                        ✏️ 修改
│     ├─ 新增导出：export type { SchedulerConfig } from '@demo/LlmTranslate/types/scheduler'
│     ├─ 新增导出：export type { ThrottleProbeMode } from '@demo/LlmTranslate/types/scheduler'
│     └─ 新增导出：export type { SchedulingStrategy } from '@demo/LlmTranslate/types/scheduler'
│     └─ 注释说明这些来自前端定义
│
└─ index.ts                           ✏️ 修改
   └─ 更新导出列表包含新的scheduler相关类型
```

### **前端结构调整（Vue组件层）**

```
Nimbria/Client/GUI/DemoPage/LlmTranslate/
├─ types/
│  ├─ config.ts                       ✏️ 修改
│  │  └─ 扩展 TranslateConfig interface
│  │     └─ 新增可选字段：schedulerConfig?: SchedulerConfig
│  │
│  ├─ scheduler.ts                    ✨ 新增
│  │  ├─ 导出：SchedulerConfig interface
│  │  │  ├─ maxConcurrency: number (1-10)
│  │  │  ├─ taskTimeoutSeconds: number (5-120)
│  │  │  ├─ streamNoDataTimeoutSeconds: number (10-60)
│  │  │  ├─ throttleProbeIntervalSeconds: number (5-30)
│  │  │  ├─ throttleProbeType: 'quick' | 'api'
│  │  │  ├─ autoRetryThrottled: boolean
│  │  │  └─ schedulingStrategy: 'timed' | 'event'
│  │  ├─ 导出：SchedulerStatus enum
│  │  │  ├─ IDLE | RUNNING | PAUSED | THROTTLED
│  │  ├─ 导出：ThrottleProbeMode type
│  │  └─ 导出：SchedulingStrategy type
│  │
│  └─ index.ts                        ✏️ 修改
│     └─ 导出新的 scheduler.ts 中的所有类型
│
├─ components/
│  ├─ TaskManagePage.vue              ✏️ 修改
│  │  ├─ 新增常量：TASK_STATUS_ORDER 定义排序优先级
│  │  │  └─ ['sending', 'waiting', 'throttled', 'completed', 'error', 'unsent']
│  │  ├─ 修改computed：sortedTasks 使用新排序优先级
│  │  ├─ 工具栏第2行最右边新增按钮：
│  │  │  ├─ icon: SettingOutlined (齿轮图标)
│  │  │  ├─ title: "更多配置"
│  │  │  └─ click: showSchedulerConfig()
│  │  ├─ testThrottle 按钮改为真实调用 (移除mock)
│  │  ├─ 新增ref：configDrawerVisible, currentSchedulerConfig
│  │  ├─ 新增methods：
│  │  │  ├─ showSchedulerConfig(): 打开配置抽屉
│  │  │  ├─ handleConfigSave(config): 保存并应用配置
│  │  │  └─ handleConfigClose(): 关闭抽屉
│  │  └─ 修改testThrottle：显示探针结果提示
│  │
│  ├─ SchedulerConfigDrawer.vue       ✨ 新增
│  │  ├─ Props: visible (boolean), initialConfig (SchedulerConfig)
│  │  ├─ 局部状态：form (表单数据), activeTab (当前tab), loading
│  │  ├─ 三个Tab标签：
│  │  │  ├─ 【基础设置】Tab
│  │  │  │  ├─ 最高并发数 (Slider 1-10)
│  │  │  │  ├─ 任务超时时间 (Input 5-120 秒)
│  │  │  │  └─ 流式无数据超时 (Input 10-60 秒)
│  │  │  ├─ 【限流处理】Tab
│  │  │  │  ├─ 限流探针间隔 (Input 5-30 秒)
│  │  │  │  ├─ 探针类型 (Radio: 快速检查 / API调用)
│  │  │  │  └─ 自动重发限流任务 (Checkbox)
│  │  │  └─ 【高级选项】Tab
│  │  │     └─ 调度策略 (Radio: 事件驱动 / 定时轮询)
│  │  ├─ 底部按钮：保存 (确认) / 取消 (关闭)
│  │  ├─ 表单验证：validateForm()
│  │  └─ Emits: @update (保存), @close (关闭)
│  │
│  ├─ HomePage.vue                    ✏️ 修改
│  │  ├─ 并发数标签：
│  │  │  └─ "每分钟最高并发数" → "最高并发数"
│  │  └─ 保留slider和input绑定逻辑
│  │
│  └─ ModelSelector.vue               ✏️ 修改（可选）
│     ├─ 预留token估计模式选择的位置
│     └─ 保持现有功能
│
├─ stores/
│  ├─ translate.store.ts              ✏️ 修改
│  │  ├─ 新增状态：
│  │  │  ├─ schedulerConfig: SchedulerConfig
│  │  │  └─ schedulerStatus: SchedulerStatus
│  │  ├─ 新增Action：
│  │  │  ├─ updateSchedulerConfig(config): 更新配置
│  │  │  ├─ updateSchedulerStatus(status): 更新状态
│  │  │  └─ setupSchedulerEventListeners(): 监听scheduler事件
│  │  ├─ 修改现有Action：
│  │  │  ├─ initialize(): 调用 setupSchedulerEventListeners()
│  │  │  └─ setupEventListeners(): 新增scheduler事件监听
│  │  │     ├─ 监听 'llm-translate:scheduler-status-changed'
│  │  │     ├─ 监听 'llm-translate:throttle-recovered'
│  │  │     └─ 相应更新 schedulerConfig, schedulerStatus
│  │  └─ 新增Computed：
│  │     └─ currentSchedulerConfig: 当前批次的调度器配置
│  │
│  └─ translate.datasource.ts         ✏️ 修改
│     ├─ 新增方法：
│     │  ├─ updateSchedulerConfig(config): 通过IPC更新配置
│     │  ├─ getSchedulerConfig(): 通过IPC获取配置
│     │  ├─ testThrottle(): 通过IPC测试限流
│     │  └─ getSchedulerStatus(): 通过IPC获取调度器状态
│     └─ 所有方法都基于 electronAPI 的IPC调用
│
└─ preload/
   └─ project-preload.ts              ✏️ 修改（可能）
      ├─ 暴露新的IPC接口：
      │  ├─ updateSchedulerConfig(config)
      │  ├─ getSchedulerConfig()
      │  ├─ testThrottle()
      │  └─ getSchedulerStatus()
      └─ 这些可能已经通过通用的 handle/invoke 机制暴露
```

---

## 📋 **完整的实现Todo清单（按阶段组织）**

### **Phase 1️⃣ : BatchScheduler 基础设施**

**后端实现**
- [ ] 新增 `batch-scheduler.ts` 文件
  - [ ] 导出 `BatchScheduler` 类骨架
  - [ ] 实现构造器：初始化 waitingQueue, activeSet, maxConcurrency
  - [ ] 实现 `start()` 方法：启动调度循环
  - [ ] 实现 `processQueue()` 方法：核心调度逻辑
    - [ ] 检查 activeCount < maxConcurrency
    - [ ] 从 waitingQueue 取任务
    - [ ] 调用 executor.executeTasks(taskId)
  - [ ] 实现 `handleTaskComplete(taskId)` 方法
    - [ ] activeSet.delete(taskId)
    - [ ] 触发 processQueue() 发送下一批
  - [ ] 实现 `handleTaskError()` 方法
    - [ ] 根据错误类型处理
    - [ ] 如果是RATE_LIMIT，触发 handleThrottled()
  - [ ] 实现 `handleThrottled()` 方法
    - [ ] 停止 processQueue()
    - [ ] 设置 throttledUntil 时间戳
  - [ ] 实现 `getStatus()` 返回调度器状态
  - [ ] 添加详细的日志输出（emoji标记）
  - [ ] 编写基本的单元测试

- [ ] 修改 `llm-translate-service.ts`
  - [ ] 新增属性：`scheduler: BatchScheduler | null`
  - [ ] 在 constructor 中初始化调度器引用
  - [ ] 修改 `submitTasks()` 方法
    - [ ] 创建 BatchScheduler 实例
    - [ ] 将任务标记为 'waiting'（写入DB）
    - [ ] 调用 `scheduler.start()`
    - [ ] 返回 submissionId
  - [ ] 新增 `setupSchedulerListeners()` 方法
    - [ ] 监听 executor 的 task:complete 事件
    - [ ] 监听 executor 的 task:error 事件
    - [ ] 调用相应的 scheduler 方法
  - [ ] 改进日志输出（方便调试）

- [ ] 修改 `llm-translate-handlers.ts` IPC层
  - [ ] 修改 `'llm-translate:submit-tasks'` handler
    - [ ] 调用 service.submitTasks() 时实际使用scheduler
    - [ ] 返回 submissionId

**测试验证**
- [ ] 前端发送10个任务，并发数为3
  - [ ] 观察前3个任务进入 'sending' 状态
  - [ ] 第1个完成后，第4个自动进入 'sending'
  - [ ] 验证队列机制正确

---

### **Phase 2️⃣ : UI改动（排序、按钮、标签）**

**前端UI调整**
- [ ] 修改 `TaskManagePage.vue`
  - [ ] 在文件顶部新增常量
    ```typescript
    const TASK_STATUS_ORDER = ['sending', 'waiting', 'throttled', 'completed', 'error', 'unsent']
    ```
  - [ ] 修改 `filteredTaskList` computed
    - [ ] 调整排序逻辑使用 TASK_STATUS_ORDER
  - [ ] 在工具栏第2行最右边添加"更多配置"按钮
    - [ ] Icon: SettingOutlined
    - [ ] Title: "更多配置"
    - [ ] @click: showSchedulerConfig()
  - [ ] 修改 `testThrottle` 按钮行为
    - [ ] 从mock改为真实调用 datasource.testThrottle()
    - [ ] 显示返回结果提示（成功/失败 + 响应时间）

- [ ] 修改 `HomePage.vue`
  - [ ] 找到并发数的标签文本
    - [ ] 改为 "最高并发数"（删除"每分钟"）
  - [ ] 验证slider和input的绑定

**验证**
- [ ] 任务列表按新优先级排序
- [ ] "更多配置"按钮出现在工具栏
- [ ] testThrottle 显示真实结果

---

### **Phase 3️⃣ : SchedulerConfigDrawer 配置抽屉**

**新增组件**
- [ ] 新增 `SchedulerConfigDrawer.vue` 组件
  - [ ] Props 定义
    - [ ] visible: boolean
    - [ ] initialConfig: SchedulerConfig
  - [ ] 局部状态
    - [ ] form: SchedulerConfig 对象
    - [ ] activeTab: string (当前tab)
    - [ ] loading: boolean
  - [ ] 模板结构（三个Tab）
    - [ ] El-Tabs 容器
    - [ ] Tab1: 【基础设置】
      - [ ] 最高并发数：Slider (范围1-10)
      - [ ] 任务超时：Input (范围5-120秒)
      - [ ] 流式超时：Input (范围10-60秒)
    - [ ] Tab2: 【限流处理】
      - [ ] 探针间隔：Input (范围5-30秒)
      - [ ] 探针类型：Radio (快速/API)
      - [ ] 自动重发：Checkbox
    - [ ] Tab3: 【高级选项】
      - [ ] 调度策略：Radio (事件驱动/定时)
  - [ ] 底部按钮
    - [ ] 保存按钮：调用 handleSave()
    - [ ] 取消按钮：调用 handleCancel()
  - [ ] Methods
    - [ ] handleSave(): 验证表单→emit 'update' 事件
    - [ ] validateForm(): 检查参数范围
    - [ ] handleCancel(): emit 'close' 事件
    - [ ] handleReset(): 恢复到初始值
  - [ ] Emits
    - [ ] @update (新配置)
    - [ ] @close

**修改TaskManagePage**
- [ ] 导入 SchedulerConfigDrawer 组件
- [ ] 新增 ref
  - [ ] configDrawerVisible: boolean (默认false)
  - [ ] currentSchedulerConfig: SchedulerConfig
- [ ] 在模板中添加 SchedulerConfigDrawer 组件
  - [ ] :visible="configDrawerVisible"
  - [ ] :initialConfig="currentSchedulerConfig"
  - [ ] @update="handleConfigSave"
  - [ ] @close="handleConfigClose"
- [ ] 新增 methods
  - [ ] showSchedulerConfig()
    - [ ] 加载当前配置
    - [ ] configDrawerVisible = true
  - [ ] handleConfigSave(config)
    - [ ] 调用 datasource.updateSchedulerConfig(config)
    - [ ] 更新 store.schedulerConfig
    - [ ] 显示成功提示
  - [ ] handleConfigClose()
    - [ ] configDrawerVisible = false

**修改Store**
- [ ] 新增状态（translate.store.ts）
  - [ ] schedulerConfig: SchedulerConfig (保存当前配置)
  - [ ] schedulerStatus: SchedulerStatus
- [ ] 新增 Action
  - [ ] updateSchedulerConfig(config)
    - [ ] 更新 state.schedulerConfig
  - [ ] updateSchedulerStatus(status)
    - [ ] 更新 state.schedulerStatus
  - [ ] loadSchedulerConfig()
    - [ ] 调用 datasource.getSchedulerConfig()
    - [ ] 保存到状态
- [ ] 修改现有 Action
  - [ ] initialize()
    - [ ] 调用 loadSchedulerConfig()
    - [ ] 调用 setupSchedulerEventListeners()

**修改Datasource**
- [ ] 新增 methods（translate.datasource.ts）
  - [ ] async updateSchedulerConfig(config)
    - [ ] 调用 IPC: 'llm-translate:update-scheduler-config'
  - [ ] async getSchedulerConfig()
    - [ ] 调用 IPC: 'llm-translate:get-scheduler-config'
    - [ ] 返回配置对象
  - [ ] async getSchedulerStatus()
    - [ ] 调用 IPC: 'llm-translate:get-scheduler-status'

**修改IPC Handler**
- [ ] 修改 `llm-translate-handlers.ts`
  - [ ] 新增 handler: 'llm-translate:update-scheduler-config'
    - [ ] 接收 config: SchedulerConfig
    - [ ] 当前batch的scheduler更新配置
  - [ ] 新增 handler: 'llm-translate:get-scheduler-config'
    - [ ] 返回当前batch的配置

**验证**
- [ ] 点击"更多配置"按钮打开抽屉
- [ ] 修改参数值
- [ ] 点击保存，配置被应用
- [ ] 关闭重新打开，显示已保存的配置

---

### **Phase 4️⃣ : ThrottleProbe 限流探针**

**后端实现**
- [ ] 新增 `throttle-probe.ts` 文件
  - [ ] 导出 `ThrottleProbe` 类
  - [ ] 构造器：constructor(modelId: string, config: ThrottleProbeConfig)
    - [ ] 初始化 modelId, config, lastProbeTime, isProbing
  - [ ] 实现 `quickProbe()` 方法
    - [ ] 发送最小化请求（可能是HEAD请求）
    - [ ] 返回 boolean (成功/失败)
  - [ ] 实现 `apiProbe()` 方法
    - [ ] 调用实际API发送短内容翻译
    - [ ] 返回 boolean (成功/失败)
  - [ ] 实现 `startProbing()` 方法
    - [ ] isProbing = true
    - [ ] 启动 setInterval 循环
    - [ ] 根据配置的probeType调用快速或API探针
    - [ ] 如果收到200，emit 'recovered' 事件
  - [ ] 实现 `stopProbing()` 方法
    - [ ] 清除定时器，isProbing = false
  - [ ] 实现 `reset()` 方法
    - [ ] 重置所有状态
  - [ ] 事件系统
    - [ ] on(event, callback): 监听事件
    - [ ] emit(event, data): 发射事件
    - [ ] 支持事件：'recovered', 'testFailed'
  - [ ] 添加详细日志

- [ ] 修改 `llm-translate-service.ts`
  - [ ] 新增属性：`probe: ThrottleProbe`
  - [ ] 在 constructor 中初始化 probe
  - [ ] 修改 setupSchedulerListeners()
    - [ ] 监听 scheduler 的限流事件
    - [ ] 调用 `probe.startProbing()`
    - [ ] 监听 probe 的 'recovered' 事件
    - [ ] 通知 scheduler 恢复调度
  - [ ] 新增 `testThrottle()` 方法
    - [ ] 立即执行一次探针测试
    - [ ] 返回 { status: string, responseTime: number }
  - [ ] 新增 `setupProbeEventBroadcast()` 方法
    - [ ] 监听 probe 的所有事件
    - [ ] 广播给前端

- [ ] 修改 `llm-translate-handlers.ts` IPC层
  - [ ] 新增 handler: 'llm-translate:test-throttle'
    - [ ] 调用 service.testThrottle()
    - [ ] 返回测试结果
  - [ ] 新增事件广播函数 `setupProbeEventBroadcast()`
    - [ ] 监听 service 的 probe 事件
    - [ ] 向所有窗口广播 'llm-translate:throttle-test-result'

**前端交互**
- [ ] 修改 `TaskManagePage.vue`
  - [ ] testThrottle 按钮改为真实调用
    ```typescript
    async testThrottle() {
      try {
        const result = await datasource.testThrottle()
        if (result.status === 'ok') {
          ElMessage.success(`限流测试通过 (${result.responseTime}ms)`)
        } else {
          ElMessage.error('当前处于限流状态，请稍后')
        }
      } catch (error) {
        ElMessage.error('限流测试失败: ' + error.message)
      }
    }
    ```

- [ ] 修改 Store（translate.store.ts）
  - [ ] 在 setupEventListeners 中监听
    - [ ] 'llm-translate:throttle-test-result'
    - [ ] 更新 UI 状态

**验证**
- [ ] 手动点击"测试限流"按钮
- [ ] 显示测试结果和响应时间
- [ ] 模拟限流：触发429错误
- [ ] 观察调度器停止，探针开始定时测试
- [ ] 探针恢复后，调度器自动继续

---

### **Phase 5️⃣ : TokenRegressionEstimator 回归估计**

**后端实现**
- [ ] 新增 `token-regression-estimator.ts` 文件
  - [ ] 导出 `TokenRegressionEstimator` 类
  - [ ] 构造器：constructor()
    - [ ] 初始化 samples (Map<modelId, Array>), coefficients (Map)
  - [ ] 实现 `addSample(sample)` 方法
    - [ ] 解析 sample: { modelId, inputLength, outputTokens, ... }
    - [ ] 按 modelId 分组维护
    - [ ] 保持滑动窗口 (≤100个样本)
  - [ ] 实现 `train()` 方法
    - [ ] 针对每个 modelId 的样本集合
    - [ ] 执行线性回归计算
    - [ ] 生成系数存储到 coefficients
  - [ ] 实现 `estimate(contentLength, modelId)` 方法
    - [ ] 检查是否有充足样本（≥3）
    - [ ] 如果有系数，使用回归公式计算
    - [ ] 返回预估的输出token数
  - [ ] 实现 `hasSufficientSamples(modelId)` 方法
    - [ ] 检查样本数 ≥ MIN_SAMPLES (3)
  - [ ] 实现 `getSampleCount(modelId)` 方法
    - [ ] 返回指定模型的样本数
  - [ ] 添加日志（样本收集、训练、预估）

- [ ] 修改 `llm-translate-service.ts`
  - [ ] 新增属性：`estimator: TokenRegressionEstimator`
  - [ ] 在 constructor 中初始化 estimator
  - [ ] 新增 `estimateTokens(taskId)` 方法
    - [ ] 从数据库读取任务
    - [ ] 提取 modelId, inputLength
    - [ ] 调用 estimator.estimate()
    - [ ] 返回预估值

- [ ] 修改 `task-state-manager.ts`
  - [ ] 在 `emit('task:complete', data)` 时
    - [ ] 收集样本信息
    - [ ] 调用 estimator.addSample()
    - [ ] 周期性调用 estimator.train()（如每10个样本后）

- [ ] 修改 `llm-translate-handlers.ts` IPC层
  - [ ] 新增 handler: 'llm-translate:estimate-tokens'
    - [ ] 接收 taskId
    - [ ] 调用 service.estimateTokens(taskId)
    - [ ] 返回预估值

**前端交互**
- [ ] 修改 `HomePage.vue` ModelSelector 组件（可选）
  - [ ] 在token模式选择区域
    - [ ] 如果选择"回归估计"
    - [ ] 显示当前样本数：`样本充分 (12个) / 样本不足 (1个)`

- [ ] 修改 Store（translate.store.ts）
  - [ ] 任务进入 'waiting' 前调用预估
  - [ ] 将预估值存储在任务的 predictedTokens 字段

**验证**
- [ ] 手动完成5个任务
- [ ] 观察后续任务的预估准确度
- [ ] 验证样本不足时是否降级到其他模式

---

### **Phase 6️⃣ : 类型系统和文档更新**

**类型定义**
- [ ] 新增 `types/scheduler.ts` 文件
  - [ ] 定义 `SchedulerConfig` interface
    ```typescript
    export interface SchedulerConfig {
      maxConcurrency: number
      taskTimeoutSeconds: number
      streamNoDataTimeoutSeconds: number
      throttleProbeIntervalSeconds: number
      throttleProbeType: 'quick' | 'api'
      autoRetryThrottled: boolean
      schedulingStrategy: 'timed' | 'event'
    }
    ```
  - [ ] 定义 `SchedulerStatus` enum
  - [ ] 定义 `ThrottleProbeMode` type
  - [ ] 定义 `SchedulingStrategy` type

- [ ] 修改 `types/config.ts`
  - [ ] 扩展 `TranslateConfig` interface
    - [ ] 新增可选字段：`schedulerConfig?: SchedulerConfig`

- [ ] 修改 `types/index.ts`
  - [ ] 导出 scheduler.ts 中的所有类型

- [ ] 新增 `backend/scheduler.ts` 文件（后端独有）
  - [ ] 定义 `SchedulerOptions` interface
  - [ ] 定义 `TokenRegressionSample` interface
  - [ ] 定义内部使用的状态类型

- [ ] 修改 `backend/events.ts`
  - [ ] 新增 `ThrottleRecoveredEvent` interface
  - [ ] 新增 `ThrottleTestResultEvent` interface
  - [ ] 新增 `SchedulerStatusChangedEvent` interface

- [ ] 修改 `client/index.ts`
  - [ ] 转发前端的 `SchedulerConfig`
    ```typescript
    export type { SchedulerConfig } from '@demo/LlmTranslate/types/scheduler'
    ```
  - [ ] 转发其他scheduler相关类型

**文档更新**
- [ ] 更新现有的类型通用规范文档
  - [ ] 添加 scheduler 类型的分层说明
  - [ ] 说明前端↔后端的类型转发关系

- [ ] 在项目计划文档中
  - [ ] 整合本次新功能的完整规划
  - [ ] 建立任务间的依赖关系
  - [ ] 预估各阶段的工作量

---

## 📌 **类型系统遵循的规范**

根据《类型通用规范.md》，所有新增类型应满足：

```
✅ 前端类型位置
   Client/GUI/DemoPage/LlmTranslate/types/
   ├─ config.ts      (扩展 SchedulerConfig)
   ├─ scheduler.ts   (新增)
   └─ index.ts       (统一导出)

✅ 后端导入方式
   src-electron/types/LlmTranslate/
   ├─ client/index.ts (别名转发前端类型)
   └─ backend/
      ├─ events.ts    (后端事件）
      └─ scheduler.ts (后端独有的scheduler类型)

✅ Service导入规范
   import type { SchedulerConfig, ... } 
     from '../../types/LlmTranslate'
   // 这样导入的是别名转发的前端定义
```

---

## ✅ **分析总结**

用户的需求涉及**三个正交的功能模块**，但都能在现有架构基础上优雅地集成：

1. **Token预估** → 轻量级统计模块，不影响现有流程
2. **批量调度** → 上层编排层，复用现有executor和事件系统
3. **限流恢复** → 并发控制补集，与调度器紧密协作

**核心设计哲学**：最小化现有代码改动，利用事件驱动架构的优势，将新功能作为上层组件而非修改下层逻辑。