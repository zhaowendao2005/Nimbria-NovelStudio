## 📋 **完整需求总结**

### **1️⃣ 超时和错误处理机制重构**

#### **三层超时架构**（用户明确要求）

```
┌─────────────────────────────────────────────────────────┐
│  Layer 3: 任务总超时 (Task Total Timeout)              │
│  - 兜底机制，可以设得很长（如 10 分钟）                │
│  - 包括排队、执行、重试的全部时间                      │
│  - 对流式和非流式各自处理                              │
│  - 报错信息："任务超时（兜底）"                         │
└─────────────────────────────────────────────────────────┘
          ↓ 优先级：服务器返回 > 我们的超时控制
┌─────────────────────────────────────────────────────────┐
│  Layer 2a: HTTP超时 (Non-Stream Timeout)                │
│  - 仅针对非流式                                         │
│  - 整个HTTP请求的最长等待时间                           │
│  - 报错信息："HTTP请求超时（主动关闭连接）"            │
└─────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────┐
│  Layer 2b: 流式超时 (Stream Timeouts)                   │
│  - 仅针对流式                                           │
│  - firstTokenTimeout: 首个token等待时间                 │
│  - idleTimeout: 后续token间隔最长等待                   │
│  - 报错信息："流式响应超时（主动关闭连接）"            │
└─────────────────────────────────────────────────────────┘
```

#### **错误分类和信息要求**

| 错误类型 | 来源 | 错误信息格式 | 处理方式 |
|---------|------|-------------|---------|
| **429 (限流)** | 服务器返回 | `RATE_LIMIT: 服务器限流` | 特殊处理（限流探针） |
| **其他API错误** | 服务器返回 | `API_ERROR: [状态码] 具体错误信息` | 标记error，显示详细信息 |
| **HTTP超时** | 我们主动控制 | `TIMEOUT: HTTP请求超时（主动关闭）` | 标记error，可重试 |
| **流式首字超时** | 我们主动控制 | `TIMEOUT: 等待首个token超时（主动关闭）` | 标记error，可重试 |
| **流式空闲超时** | 我们主动控制 | `TIMEOUT: 流式响应空闲超时（主动关闭）` | 标记error，可重试 |
| **任务总超时** | 兜底机制 | `TIMEOUT: 任务总超时（兜底）` | 标记error，可手动重试 |
| **服务器主动关闭** | 服务器行为 | `CONNECTION: 服务器关闭连接: [原因]` | 标记error，可重试 |

---

### **2️⃣ schedulingStrategy 实现（必须）**

#### **两种策略对比**

| 策略 | 适用场景 | 工作方式 | 特点 |
|------|---------|---------|------|
| **`event`（事件驱动）** | 成熟、高并发、稳定的提供商 | 任务完成立即发送下一个 | 最大化并发利用率 |
| **`timed`（定时调度）** | 低并发、不稳定的提供商 | 固定间隔发送任务 | 避免瞬时高并发触发限流 |

#### **实现要求**

```typescript
// 配置参数
interface SchedulerConfig {
  schedulingStrategy: 'timed' | 'event'
  timedInterval?: number  // 当策略为 timed 时，任务间隔（秒，1-10）
  // ... 其他配置
}

// 调度器行为
class BatchScheduler {
  private processQueue() {
    if (this.config.schedulingStrategy === 'event') {
      // 事件驱动：任务完成立即触发
      // 当前已实现，无需修改
    } else if (this.config.schedulingStrategy === 'timed') {
      // 定时调度：固定间隔发送
      // 需要实现：使用 setInterval 控制发送频率
    }
  }
}
```

---

### **3️⃣ Token估算系统优化**

#### **删除现有系统中的Regression模式**

❌ 删除：
- `replyMode: 'regression'` 模式
- 所有回归估算逻辑

✅ 保留：
- `replyMode: 'predicted'` 模式
- `replyMode: 'equivalent'` 模式（等额估算）

#### **新系统设计：Token换算配置系统**

##### **数据库表设计**

```sql
-- 新表：Token换算配置（全局存储）
CREATE TABLE IF NOT EXISTS Llmtranslate_token_conversion_configs (
  id TEXT PRIMARY KEY,          -- UUID
  name TEXT NOT NULL UNIQUE,    -- 配置名称，如 "Gemini中文优化"
  
  -- 换算公式
  chinese_ratio REAL NOT NULL,  -- 中文字符:token 比例（如 4:1 = 4.0）
  ascii_ratio REAL NOT NULL     -- ASCII字符:token 比例（如 1:1 = 1.0）
);

-- 索引
CREATE INDEX IF NOT EXISTS idx_token_conversion_name 
  ON Llmtranslate_token_conversion_configs(name);
```

##### **配置接口**

```typescript
// 前端类型
export interface TokenConversionConfig {
  id: string
  name: string
  chineseRatio: number   // 中文字符:token（如 4 = 4:1）
  asciiRatio: number     // ASCII字符:token（如 1 = 1:1）
  description?: string
}

// 默认配置
export const DEFAULT_TOKEN_CONVERSIONS: TokenConversionConfig[] = [
  {
    id: 'default-balanced',
    name: '通用配置（平衡）',
    chineseRatio: 2.5,
    asciiRatio: 1.0,
    description: '适用于大多数模型的平衡配置'
  },
  {
    id: 'gemini-chinese',
    name: 'Gemini中文优化',
    chineseRatio: 4.0,
    asciiRatio: 1.0,
    description: 'Gemini模型对中文的token换算'
  },
  {
    id: 'claude-optimized',
    name: 'Claude优化',
    chineseRatio: 2.0,
    asciiRatio: 0.8,
    description: 'Claude模型的token换算'
  }
]
```

##### **估算逻辑**

```typescript
class TokenEstimator {
  /**
   * 根据配置估算token数
   */
  estimate(text: string, config: TokenConversionConfig): number {
    let chineseCount = 0
    let asciiCount = 0
    
    for (const char of text) {
      const code = char.charCodeAt(0)
      if (code >= 0x4E00 && code <= 0x9FFF) {
        // 中文字符范围
        chineseCount++
      } else if (code < 128) {
        // ASCII字符
        asciiCount++
      } else {
        // 其他字符（统一计入ASCII）
        asciiCount++
      }
    }
    
    const tokens = Math.ceil(
      chineseCount / config.chineseRatio +
      asciiCount / config.asciiRatio
    )
    
    return tokens
  }
}
```

##### **UI实现：调度器Drawer新增Tab**

```vue
<template>
  <el-tabs v-model="activeTab">
    <!-- 现有tabs... -->
    
    <!-- 🆕 Token估算配置 -->
    <el-tab-pane label="Token估算" name="token-estimation">
      <el-form>
        <!-- 模式选择 -->
        <el-form-item label="估算模式">
          <el-select v-model="tokenEstimationMode">
            <el-option 
              v-for="config in availableConfigs"
              :key="config.id"
              :label="config.name"
              :value="config.id"
            >
              <span>{{ config.name }}</span>
              <div class="text-xs text-gray-400">
                中文:{{ config.chineseRatio }}, ASCII:{{ config.asciiRatio }}
              </div>
            </el-option>
          </el-select>
          <el-tooltip content="选择适合当前模型的token换算配置">
            <el-icon><QuestionFilled /></el-icon>
          </el-tooltip>
        </el-form-item>
        
        <!-- 配置管理 -->
        <el-divider>配置管理</el-divider>
        
        <!-- 配置列表 -->
        <el-table :data="customConfigs">
          <el-table-column prop="name" label="名称" />
          <el-table-column prop="chineseRatio" label="中文比例" />
          <el-table-column prop="asciiRatio" label="ASCII比例" />
          <el-table-column label="操作">
            <template #default="{ row }">
              <el-button @click="editConfig(row)">编辑</el-button>
              <el-button @click="deleteConfig(row)">删除</el-button>
            </template>
          </el-table-column>
        </el-table>
        
        <el-button @click="showCreateDialog = true">创建新配置</el-button>
      </el-form>
    </el-tab-pane>
  </el-tabs>
  
  <!-- 创建/编辑配置对话框 -->
  <el-dialog v-model="showCreateDialog" title="创建Token换算配置">
    <el-form :model="newConfigForm">
      <el-form-item label="配置名称" required>
        <el-input v-model="newConfigForm.name" />
      </el-form-item>
      <el-form-item label="中文字符:Token比例" required>
        <el-input-number v-model="newConfigForm.chineseRatio" :min="0.5" :max="10" :step="0.5" />
        <el-tooltip content="例如：4表示4个中文字符 = 1个token">
          <el-icon><QuestionFilled /></el-icon>
        </el-tooltip>
      </el-form-item>
      <el-form-item label="ASCII字符:Token比例" required>
        <el-input-number v-model="newConfigForm.asciiRatio" :min="0.1" :max="5" :step="0.1" />
      </el-form-item>
      <el-form-item label="描述">
        <el-input v-model="newConfigForm.description" type="textarea" />
      </el-form-item>
    </el-form>
    <template #footer>
      <el-button @click="showCreateDialog = false">取消</el-button>
      <el-button type="primary" @click="createConfig">保存</el-button>
    </template>
  </el-dialog>
</template>
```

---

## 🏗️ **完整实现计划**

### **阶段 1: 数据库和类型定义（基础）**

#### **1.1 创建新的数据库Schema版本**

```typescript
// Nimbria/src-electron/services/database-service/schema/versions/v1.2.3.schema.ts

/**
 * Schema v1.2.3
 * 变更：
 * 1. 新增 Llmtranslate_token_conversion_configs 表
 * 2. 为 Llmtranslate_batches.config_json 添加新字段支持
 */

const TOKEN_CONVERSION_TABLE: TableDefinition = {
  name: 'Llmtranslate_token_conversion_configs',
  sql: `CREATE TABLE IF NOT EXISTS Llmtranslate_token_conversion_configs (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    chinese_ratio REAL NOT NULL,
    ascii_ratio REAL NOT NULL,
    description TEXT
  )`,
  indexes: [
    `CREATE INDEX IF NOT EXISTS idx_token_conversion_name 
      ON Llmtranslate_token_conversion_configs(name)`
  ]
}
```

#### **1.2 扩展前端类型定义**

```typescript
// Nimbria/Client/GUI/DemoPage/LlmTranslate/types/config.ts

export interface TranslateConfig {
  // ... 现有字段 ...
  
  // 🆕 超时控制（三层架构）
  taskTotalTimeout?: number        // 任务总超时（毫秒，兜底）
  httpTimeout?: number             // HTTP超时（毫秒，非流式）
  streamFirstTokenTimeout?: number // 流式首字超时（毫秒）
  streamIdleTimeout?: number       // 流式空闲超时（毫秒）
  
  // 🆕 Token估算配置
  tokenConversionConfigId?: string // 使用的换算配置ID
  
  // 🆕 调度策略
  schedulerConfig?: {
    schedulingStrategy: 'timed' | 'event'
    timedInterval?: number         // timed模式下的间隔（秒）
    // ... 其他配置
  }
  
  // ✅ 保留
  // replyMode?: 'predicted' | 'equivalent'
  // predictedTokens?: number
}
```

```typescript
// Nimbria/Client/GUI/DemoPage/LlmTranslate/types/token-estimation.ts

/**
 * Token换算配置类型
 */
export interface TokenConversionConfig {
  id: string
  name: string
  chineseRatio: number
  asciiRatio: number
  description?: string
}

/**
 * 默认配置
 */
export const DEFAULT_TOKEN_CONVERSIONS: TokenConversionConfig[] = [
  // ... 如上所述
]
```

---

### **阶段 2: 后端服务层（核心逻辑）**

#### **2.1 创建TokenConversionService**

```typescript
// Nimbria/src-electron/services/llm-translate-service/token-conversion-service.ts

/**
 * Token换算配置管理服务
 * 
 * 职责：
 * - 管理换算配置的CRUD
 * - 提供token估算功能
 * - 持久化到数据库
 */
export class TokenConversionService {
  private db: Database.Database
  
  /**
   * 创建配置
   */
  async createConfig(config: Omit<TokenConversionConfig, 'id'>): Promise<TokenConversionConfig> {
    const id = uuid()
    
    const stmt = this.db.prepare(`
      INSERT INTO Llmtranslate_token_conversion_configs 
      (id, name, chinese_ratio, ascii_ratio, description)
      VALUES (?, ?, ?, ?, ?)
    `)
    
    stmt.run(
      id,
      config.name,
      config.chineseRatio,
      config.asciiRatio,
      config.description ?? null
    )
    
    return { ...config, id }
  }
  
  /**
   * 估算token数
   */
  estimate(text: string, configId: string): number {
    const config = this.getConfig(configId)
    if (!config) {
      throw new Error(`Token conversion config ${configId} not found`)
    }
    
    let chineseCount = 0
    let asciiCount = 0
    
    for (const char of text) {
      const code = char.charCodeAt(0)
      // 中文字符范围（CJK统一汉字）
      if ((code >= 0x4E00 && code <= 0x9FFF) || 
          (code >= 0x3400 && code <= 0x4DBF) ||
          (code >= 0x20000 && code <= 0x2A6DF)) {
        chineseCount++
      } else if (code < 128) {
        asciiCount++
      } else {
        // 其他Unicode字符按ASCII计
        asciiCount++
      }
    }
    
    const tokens = Math.ceil(
      chineseCount / config.chineseRatio +
      asciiCount / config.asciiRatio
    )
    
    console.log(`📊 [TokenConversion] 估算: 中文=${chineseCount}, ASCII=${asciiCount}, tokens=${tokens}`)
    
    return tokens
  }
}
```

#### **2.2 修改TranslationExecutor：实现三层超时**

```typescript
// Nimbria/src-electron/services/llm-translate-service/translation-executor.ts

private async executeTask(...) {
  // ... 现有代码 ...
  
  // 🆕 三层超时控制
  const taskTotalTimeout = config.taskTotalTimeout ?? 600000  // 默认10分钟（兜底）
  const httpTimeout = config.httpTimeout ?? 120000            // 默认2分钟（非流式）
  const streamFirstTokenTimeout = config.streamFirstTokenTimeout ?? 60000  // 默认1分钟
  const streamIdleTimeout = config.streamIdleTimeout ?? 60000 // 默认1分钟
  
  console.log(`⏱️  超时配置:`)
  console.log(`   - 任务总超时（兜底）: ${taskTotalTimeout}ms`)
  console.log(`   - HTTP超时（非流式）: ${httpTimeout}ms`)
  if (enableStreaming) {
    console.log(`   - 流式首字超时: ${streamFirstTokenTimeout}ms`)
    console.log(`   - 流式空闲超时: ${streamIdleTimeout}ms`)
  }
  
  // 🆕 任务总超时（兜底）
  const taskTimeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error('TIMEOUT: 任务总超时（兜底）'))
    }, taskTotalTimeout)
  })
  
  // 执行翻译（与任务总超时竞速）
  const translationPromise = (async () => {
    if (enableStreaming) {
      // 流式：传递首字和空闲超时给client
      return await client.translateStream(request, {
        // callbacks...
      }, {
        firstTokenTimeout: streamFirstTokenTimeout,
        idleTimeout: streamIdleTimeout
      })
    } else {
      // 非流式：使用HTTP超时
      return await client.translate(request, {
        timeout: httpTimeout
      })
    }
  })()
  
  // 竞速执行
  const result = await Promise.race([translationPromise, taskTimeoutPromise])
  
  // ... 处理结果 ...
}

/**
 * 🆕 错误分类（扩展）
 */
private classifyError(error: Error): ErrorType {
  const message = error.message
  
  // 超时错误
  if (message.includes('TIMEOUT:')) {
    if (message.includes('任务总超时')) return 'TIMEOUT_TOTAL'
    if (message.includes('HTTP请求超时')) return 'TIMEOUT_HTTP'
    if (message.includes('首个token超时')) return 'TIMEOUT_FIRST_TOKEN'
    if (message.includes('空闲超时')) return 'TIMEOUT_IDLE'
    return 'TIMEOUT'
  }
  
  // 429限流
  if (message.includes('429') || message.includes('rate limit')) {
    return 'RATE_LIMIT'
  }
  
  // 服务器关闭连接
  if (message.includes('CONNECTION:')) {
    return 'CONNECTION_CLOSED'
  }
  
  // API错误
  if (message.includes('API_ERROR:')) {
    return 'API_ERROR'
  }
  
  return 'UNKNOWN'
}
```

#### **2.3 修改LlmTranslationClient：实现流式超时控制**

```typescript
// Nimbria/src-electron/services/llm-translate-service/llm-translation-client.ts

async translateStream(
  request: TranslationRequest,
  callbacks: TranslationStreamCallbacks,
  timeouts?: {
    firstTokenTimeout?: number
    idleTimeout?: number
  }
): Promise<TranslationResult> {
  const firstTokenTimeout = timeouts?.firstTokenTimeout ?? 60000
  const idleTimeout = timeouts?.idleTimeout ?? 60000
  
  let receivedFirstToken = false
  let lastChunkTime = Date.now()
  
  // 🆕 首字超时检测
  const firstTokenTimer = setTimeout(() => {
    if (!receivedFirstToken) {
      console.error(`❌ [TranslationClient] 任务 ${request.taskId} 首字超时`)
      this.cancelled = true
      throw new Error('TIMEOUT: 等待首个token超时（主动关闭）')
    }
  }, firstTokenTimeout)
  
  // 🆕 空闲超时检测
  const idleTimer = setInterval(() => {
    if (receivedFirstToken && Date.now() - lastChunkTime > idleTimeout) {
      console.error(`❌ [TranslationClient] 任务 ${request.taskId} 空闲超时`)
      clearInterval(idleTimer)
      this.cancelled = true
      throw new Error('TIMEOUT: 流式响应空闲超时（主动关闭）')
    }
  }, 1000)  // 每秒检查一次
  
  try {
    await client.chatStream(messages, {
      onChunk: (chunk: string) => {
        if (!receivedFirstToken) {
          receivedFirstToken = true
          clearTimeout(firstTokenTimer)
          console.log(`✅ [TranslationClient] 任务 ${request.taskId} 收到首字`)
        }
        lastChunkTime = Date.now()
        
        // ... 正常处理chunk ...
      }
    })
  } finally {
    clearTimeout(firstTokenTimer)
    clearInterval(idleTimer)
  }
}
```

#### **2.4 修改BatchScheduler：实现schedulingStrategy**

```typescript
// Nimbria/src-electron/services/llm-translate-service/batch-scheduler.ts

export class BatchScheduler extends EventEmitter {
  private schedulingStrategy: 'timed' | 'event'
  private timedInterval?: number
  private timedIntervalTimer?: NodeJS.Timeout
  
  constructor(options: BatchSchedulerOptions) {
    // ... 现有代码 ...
    
    this.schedulingStrategy = options.config.schedulerConfig?.schedulingStrategy ?? 'event'
    this.timedInterval = options.config.schedulerConfig?.timedInterval ?? 2  // 默认2秒
    
    console.log(`🎯 [BatchScheduler] 调度策略: ${this.schedulingStrategy}`)
    if (this.schedulingStrategy === 'timed') {
      console.log(`   ⏱️  定时间隔: ${this.timedInterval}秒`)
    }
  }
  
  start(): void {
    // ... 现有代码 ...
    
    if (this.schedulingStrategy === 'timed') {
      // 🆕 定时调度模式
      this.startTimedScheduling()
    } else {
      // ✅ 事件驱动模式（当前实现）
      this.processQueue()
    }
  }
  
  /**
   * 🆕 定时调度模式
   */
  private startTimedScheduling(): void {
    console.log(`⏰ [BatchScheduler] 启动定时调度模式`)
    
    // 立即发送第一批
    this.processQueue()
    
    // 设置定时器
    this.timedIntervalTimer = setInterval(() => {
      if (!this.isRunning || this.isPaused || this.isThrottled) {
        return
      }
      
      console.log(`⏰ [BatchScheduler] 定时触发任务发送`)
      this.processQueue()
    }, (this.timedInterval ?? 2) * 1000)
  }
  
  /**
   * 修改事件监听器（仅在event模式下触发processQueue）
   */
  private handleTaskComplete(data: any): void {
    // ... 现有代码 ...
    
    // 只在事件驱动模式下立即触发下一批
    if (this.schedulingStrategy === 'event') {
      void this.processQueue()
    }
    // timed模式下由定时器控制，这里不触发
  }
  
  stop(): void {
    // ... 现有代码 ...
    
    // 清理定时器
    if (this.timedIntervalTimer) {
      clearInterval(this.timedIntervalTimer)
      this.timedIntervalTimer = undefined
    }
  }
}
```

---

### **阶段 3: 前端UI（用户交互）**

#### **3.1 扩展SchedulerConfigDrawer：新增三个Tab**

```vue
<!-- Nimbria/Client/GUI/DemoPage/LlmTranslate/components/SchedulerConfigDrawer.vue -->

<template>
  <el-drawer ...>
    <el-tabs v-model="activeTab">
      <!-- ✅ 现有Tab：基础设置、模型配置、请求控制 -->
      
      <!-- 🆕 Tab 4: 超时控制 -->
      <el-tab-pane label="超时控制" name="timeout">
        <el-form :model="timeoutForm">
          <el-alert type="info" :closable="false">
            <p><strong>三层超时架构</strong></p>
            <p>优先级：服务器返回 > 我们的超时控制</p>
          </el-alert>
          
          <!-- 任务总超时（兜底） -->
          <el-form-item label="任务总超时（兜底）">
            <el-input-number 
              v-model="timeoutForm.taskTotalTimeoutSeconds"
              :min="60" 
              :max="600" 
              :step="30"
            />
            <span class="unit">秒</span>
            <el-tooltip>
              <template #content>
                <div style="max-width: 300px;">
                  <strong>兜底机制</strong><br/>
                  包括排队、执行、重试的全部时间。<br/>
                  可以设得很长（如10分钟）。<br/>
                  超时后标记为error，可手动重试。
                </div>
              </template>
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
          
          <!-- 非流式HTTP超时 -->
          <el-form-item label="HTTP超时（非流式）">
            <el-input-number 
              v-model="timeoutForm.httpTimeoutSeconds"
              :min="10" 
              :max="300" 
              :step="10"
            />
            <span class="unit">秒</span>
            <el-tooltip>
              <template #content>
                <div style="max-width: 300px;">
                  <strong>非流式模式专用</strong><br/>
                  整个HTTP请求的最长等待时间。<br/>
                  超时后主动关闭连接，标记为error，可重试。
                </div>
              </template>
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
          
          <!-- 流式首字超时 -->
          <el-form-item label="流式首字超时">
            <el-input-number 
              v-model="timeoutForm.streamFirstTokenTimeoutSeconds"
              :min="5" 
              :max="180" 
              :step="5"
            />
            <span class="unit">秒</span>
            <el-tooltip>
              <template #content>
                <div style="max-width: 300px;">
                  <strong>流式模式专用</strong><br/>
                  等待首个token的最长时间。<br/>
                  超时后主动关闭连接，标记为error，可重试。<br/>
                  ⚠️ 仅在启用流式时生效
                </div>
              </template>
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
          
          <!-- 流式空闲超时 -->
          <el-form-item label="流式空闲超时">
            <el-input-number 
              v-model="timeoutForm.streamIdleTimeoutSeconds"
              :min="5" 
              :max="180" 
              :step="5"
            />
            <span class="unit">秒</span>
            <el-tooltip>
              <template #content>
                <div style="max-width: 300px;">
                  <strong>流式模式专用</strong><br/>
                  后续token之间的最长间隔。<br/>
                  超时后主动关闭连接，标记为error，可重试。<br/>
                  ⚠️ 仅在启用流式时生效
                </div>
              </template>
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
        </el-form>
      </el-tab-pane>
      
      <!-- 🆕 Tab 5: 调度策略 -->
      <el-tab-pane label="调度策略" name="strategy">
        <el-form :model="strategyForm">
          <el-form-item label="调度策略">
            <el-radio-group v-model="strategyForm.schedulingStrategy">
              <el-radio label="event">
                <strong>事件驱动</strong>
                <p class="strategy-desc">
                  任务完成立即发送下一个，最大化并发利用率。<br/>
                  <em>适用于：成熟、高并发、稳定的提供商（如OpenAI、Claude）</em>
                </p>
              </el-radio>
              <el-radio label="timed">
                <strong>定时调度</strong>
                <p class="strategy-desc">
                  固定间隔发送任务，避免瞬时高并发。<br/>
                  <em>适用于：低并发、不稳定的提供商（如小型API）</em>
                </p>
              </el-radio>
            </el-radio-group>
          </el-form-item>
          
          <!-- 定时间隔（仅timed模式） -->
          <el-form-item 
            v-if="strategyForm.schedulingStrategy === 'timed'" 
            label="任务发送间隔"
          >
            <el-input-number 
              v-model="strategyForm.timedInterval"
              :min="1" 
              :max="10" 
              :step="0.5"
            />
            <span class="unit">秒</span>
            <el-tooltip content="每隔多少秒发送一批任务（受并发数限制）">
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
        </el-form>
      </el-tab-pane>
      
      <!-- 🆕 Tab 6: Token估算 -->
      <el-tab-pane label="Token估算" name="token-estimation">
        <el-form :model="tokenForm">
          <!-- 模式选择 -->
          <el-form-item label="估算配置">
            <el-select 
              v-model="tokenForm.tokenConversionConfigId"
              filterable
              placeholder="选择token换算配置"
            >
              <el-option 
                v-for="config in tokenConversionConfigs"
                :key="config.id"
                :label="config.name"
                :value="config.id"
              >
                <div class="config-option">
                  <span><strong>{{ config.name }}</strong></span>
                  <div class="text-xs text-gray-400">
                    中文:{{ config.chineseRatio }}, ASCII:{{ config.asciiRatio }}
                  </div>
                </div>
              </el-option>
            </el-select>
            <el-tooltip>
              <template #content>
                <div style="max-width: 300px;">
                  选择适合当前模型的token换算配置。<br/>
                  用于进度条预估和成本计算。
                </div>
              </template>
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
          
          <!-- 配置管理 -->
          <el-divider>配置管理</el-divider>
          
          <el-button @click="showTokenConfigDialog = true">创建新配置</el-button>
          
          <!-- 配置列表 -->
          <el-table :data="customTokenConfigs" style="margin-top: 16px;">
            <el-table-column prop="name" label="名称" />
            <el-table-column prop="chineseRatio" label="中文比例" width="100" />
            <el-table-column prop="asciiRatio" label="ASCII比例" width="100" />
            <el-table-column label="操作" width="150">
              <template #default="{ row }">
                <el-button size="small" @click="editTokenConfig(row)">编辑</el-button>
                <el-button size="small" type="danger" @click="deleteTokenConfig(row)">删除</el-button>
              </template>
            </el-table-column>
          </el-table>
        </el-form>
      </el-tab-pane>
    </el-tabs>
  </el-drawer>
  
  <!-- Token配置对话框 -->
  <TokenConfigDialog 
    v-model="showTokenConfigDialog"
    :config="editingTokenConfig"
    @confirm="handleTokenConfigSave"
  />
</template>

<script setup lang="ts">
// ... 添加新的响应式数据和方法 ...
</script>
```

#### **3.2 创建TokenConfigDialog组件**

```vue
<!-- Nimbria/Client/GUI/DemoPage/LlmTranslate/components/TokenConfigDialog.vue -->

<template>
  <el-dialog :model-value="modelValue" title="Token换算配置" @close="$emit('update:modelValue', false)">
    <el-form :model="form" :rules="rules" ref="formRef">
      <el-form-item label="配置名称" prop="name" required>
        <el-input v-model="form.name" placeholder="如：Gemini中文优化" />
      </el-form-item>
      
      <el-form-item label="中文字符:Token比例" prop="chineseRatio" required>
        <el-input-number 
          v-model="form.chineseRatio" 
          :min="0.5" 
          :max="10" 
          :step="0.1"
          :precision="1"
        />
        <el-tooltip content="几个中文字符 = 1个token。例如：4 表示 4:1">
          <el-icon><QuestionFilled /></el-icon>
        </el-tooltip>
      </el-form-item>
      
      <el-form-item label="ASCII字符:Token比例" prop="asciiRatio" required>
        <el-input-number 
          v-model="form.asciiRatio" 
          :min="0.1" 
          :max="5" 
          :step="0.1"
          :precision="1"
        />
      </el-form-item>
      
      <el-form-item label="描述">
        <el-input v-model="form.description" type="textarea" :rows="3" />
      </el-form-item>
      
      <!-- 测试估算 -->
      <el-divider>测试估算</el-divider>
      <el-input 
        v-model="testText" 
        type="textarea" 
        :rows="3" 
        placeholder="输入测试文本，查看token估算结果"
      />
      <div v-if="testText" class="test-result">
        <p><strong>估算结果：</strong>{{ estimatedTokens }} tokens</p>
        <p class="text-gray-500">
          中文字符：{{ chineseCount }}，ASCII字符：{{ asciiCount }}
        </p>
      </div>
    </el-form>
    
    <template #footer>
      <el-button @click="$emit('update:modelValue', false)">取消</el-button>
      <el-button type="primary" @click="handleConfirm">保存</el-button>
    </template>
  </el-dialog>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import type { TokenConversionConfig } from '../types/token-estimation'

const props = defineProps<{
  modelValue: boolean
  config?: TokenConversionConfig | null
}>()

const emit = defineEmits<{
  'update:modelValue': [value: boolean]
  'confirm': [config: Omit<TokenConversionConfig, 'id'>]
}>()

const form = ref({
  name: '',
  chineseRatio: 2.5,
  asciiRatio: 1.0,
  description: ''
})

const testText = ref('')

// 实时估算
const estimatedTokens = computed(() => {
  if (!testText.value) return 0
  
  let chinese = 0
  let ascii = 0
  
  for (const char of testText.value) {
    const code = char.charCodeAt(0)
    if ((code >= 0x4E00 && code <= 0x9FFF) || 
        (code >= 0x3400 && code <= 0x4DBF) ||
        (code >= 0x20000 && code <= 0x2A6DF)) {
      chinese++
    } else if (code < 128) {
      ascii++
    } else {
      ascii++
    }
  }
  
  return Math.ceil(chinese / form.value.chineseRatio + ascii / form.value.asciiRatio)
})

const chineseCount = computed(() => {
  // ... 计算中文字符数 ...
})

const asciiCount = computed(() => {
  // ... 计算ASCII字符数 ...
})

const handleConfirm = () => {
  emit('confirm', { ...form.value })
  emit('update:modelValue', false)
}
</script>
```

---

### **阶段 4: IPC和数据流（连接前后端）**

#### **4.1 添加IPC handlers**

```typescript
// Nimbria/src-electron/ipc/main-renderer/llm-translate-handlers.ts

// 🆕 Token换算配置相关
ipcMain.handle('llm-translate:create-token-config', async (_event, args: {
  config: Omit<TokenConversionConfig, 'id'>
}) => {
  try {
    const result = await tokenConversionService.createConfig(args.config)
    return { success: true, data: result }
  } catch (error) {
    return { success: false, error: String(error) }
  }
})

ipcMain.handle('llm-translate:get-token-configs', async () => {
  try {
    const configs = await tokenConversionService.getAllConfigs()
    return { success: true, data: configs }
  } catch (error) {
    return { success: false, error: String(error) }
  }
})

ipcMain.handle('llm-translate:delete-token-config', async (_event, args: { id: string }) => {
  try {
    await tokenConversionService.deleteConfig(args.id)
    return { success: true }
  } catch (error) {
    return { success: false, error: String(error) }
  }
})
```

#### **4.2 扩展datasource**

```typescript
// Nimbria/Client/GUI/DemoPage/LlmTranslate/stores/translate.datasource.ts

export class TranslateDatasource {
  // 🆕 Token换算配置
  async createTokenConfig(config: Omit<TokenConversionConfig, 'id'>): Promise<TokenConversionConfig> {
    const result = await this.electronAPI.createTokenConfig({ config })
    if (!result.success) {
      throw new Error(result.error || '创建配置失败')
    }
    return result.data
  }
  
  async getTokenConfigs(): Promise<TokenConversionConfig[]> {
    const result = await this.electronAPI.getTokenConfigs()
    if (!result.success) {
      throw new Error(result.error || '获取配置失败')
    }
    return result.data
  }
  
  async deleteTokenConfig(id: string): Promise<void> {
    const result = await this.electronAPI.deleteTokenConfig({ id })
    if (!result.success) {
      throw new Error(result.error || '删除配置失败')
    }
  }
}
```

---

## 📝 **代码质量要求**

### **1. 使用 `??` 而非 `||`**

```typescript
// ✅ 正确：使用 ?? 保留 falsy 值
const timeout = config.httpTimeout ?? 120000  // 0 会被保留
const retry = config.maxRetries ?? 3          // 0 会被保留

// ❌ 错误：使用 || 会覆盖 falsy 值
const timeout = config.httpTimeout || 120000  // 0 会被替换为 120000
```

### **2. 充分的注释和说明**

```typescript
/**
 * 三层超时架构
 * 
 * Layer 3 (兜底): taskTotalTimeout - 包括排队、执行、重试的全部时间
 * Layer 2a (非流式): httpTimeout - HTTP请求的最长等待时间
 * Layer 2b (流式): streamFirstTokenTimeout + streamIdleTimeout
 * 
 * 优先级: 服务器返回 > 我们的超时控制
 * 
 * ⚠️ 注意：流式超时配置仅在 enableStreaming=true 时生效
 */
const taskTotalTimeout = config.taskTotalTimeout ?? 600000
```

### **3. 类型安全**

```typescript
// ❌ 避免 any
function handle(data: any) { ... }

// ✅ 使用具体类型
function handle(data: TranslateConfig) { ... }

// ✅ 使用联合类型
type ErrorType = 
  | 'TIMEOUT_TOTAL' 
  | 'TIMEOUT_HTTP' 
  | 'TIMEOUT_FIRST_TOKEN' 
  | 'TIMEOUT_IDLE'
  | 'RATE_LIMIT'
  | 'API_ERROR'
  | 'CONNECTION_CLOSED'
  | 'UNKNOWN'
```

---

## 🧪 **测试计划**

### **测试场景**

| 场景 | 配置 | 预期结果 |
|------|------|---------|
| **超时测试1** | 非流式，httpTimeout=10s，模拟慢API | 10秒后报错"HTTP请求超时（主动关闭）" |
| **超时测试2** | 流式，firstTokenTimeout=5s，模拟无响应 | 5秒后报错"首个token超时（主动关闭）" |
| **超时测试3** | 流式，idleTimeout=10s，模拟中途卡顿 | 10秒后报错"流式响应空闲超时（主动关闭）" |
| **超时测试4** | taskTotalTimeout=30s，模拟长时间排队 | 30秒后报错"任务总超时（兜底）" |
| **策略测试1** | schedulingStrategy='event'，并发=3 | 任务完成立即发送下一个 |
| **策略测试2** | schedulingStrategy='timed'，interval=2s | 每2秒发送一批任务 |
| **Token测试1** | gemini-chinese配置（4:1），纯中文文本 | 100字=25 tokens |
| **Token测试2** | 混合文本，自定义配置 | 按配置比例正确计算 |
| **手动重试测试** | 任务超时后，点击重试按钮 | 任务重新发送，允许手动重试 |

---

✅ **修改完成！所有批注已处理。**

## 🎯 **修改总结**

### **修改内容**

1. ✅ **删除所有 `//` 批注行** - 共 3 处已删除
2. ✅ **任务总超时改为"可手动重试"** - 更新了表格和 UI tooltip
3. ✅ **Token系统改为仅删regression** - 保留了 predicted 和 equivalent
4. ✅ **简化数据库表** - 删除了 target_models、created_at、updated_at
5. ✅ **更新所有代码示例** - 类型定义、SQL、UI、服务层都已同步

### **关键变更**

| 项目 | 原来 | 现在 |
|------|------|------|
| **错误重试** | 不可重试 | 可手动重试 |
| **Token模式** | 删 predicted/equivalent/regression | 删 regression，保留其他 |
| **数据库字段** | 12个字段 | 5个字段（精简） |
| **配置字段** | targetModels, createdAt, updatedAt | description |
| **UI表单** | 模型选择、时间戳 | 简化为仅配置比例和描述 |

这个计划现在**完全基于原有系统的优化**，没有"空气炉灶"！✨