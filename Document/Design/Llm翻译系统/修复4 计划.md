## ğŸ“‹ **å®Œæ•´éœ€æ±‚æ€»ç»“**

### **1ï¸âƒ£ è¶…æ—¶å’Œé”™è¯¯å¤„ç†æœºåˆ¶é‡æ„**

#### **ä¸‰å±‚è¶…æ—¶æ¶æ„**ï¼ˆç”¨æˆ·æ˜ç¡®è¦æ±‚ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 3: ä»»åŠ¡æ€»è¶…æ—¶ (Task Total Timeout)              â”‚
â”‚  - å…œåº•æœºåˆ¶ï¼Œå¯ä»¥è®¾å¾—å¾ˆé•¿ï¼ˆå¦‚ 10 åˆ†é’Ÿï¼‰                â”‚
â”‚  - åŒ…æ‹¬æ’é˜Ÿã€æ‰§è¡Œã€é‡è¯•çš„å…¨éƒ¨æ—¶é—´                      â”‚
â”‚  - å¯¹æµå¼å’Œéæµå¼å„è‡ªå¤„ç†                              â”‚
â”‚  - æŠ¥é”™ä¿¡æ¯ï¼š"ä»»åŠ¡è¶…æ—¶ï¼ˆå…œåº•ï¼‰"                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“ ä¼˜å…ˆçº§ï¼šæœåŠ¡å™¨è¿”å› > æˆ‘ä»¬çš„è¶…æ—¶æ§åˆ¶
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 2a: HTTPè¶…æ—¶ (Non-Stream Timeout)                â”‚
â”‚  - ä»…é’ˆå¯¹éæµå¼                                         â”‚
â”‚  - æ•´ä¸ªHTTPè¯·æ±‚çš„æœ€é•¿ç­‰å¾…æ—¶é—´                           â”‚
â”‚  - æŠ¥é”™ä¿¡æ¯ï¼š"HTTPè¯·æ±‚è¶…æ—¶ï¼ˆä¸»åŠ¨å…³é—­è¿æ¥ï¼‰"            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 2b: æµå¼è¶…æ—¶ (Stream Timeouts)                   â”‚
â”‚  - ä»…é’ˆå¯¹æµå¼                                           â”‚
â”‚  - firstTokenTimeout: é¦–ä¸ªtokenç­‰å¾…æ—¶é—´                 â”‚
â”‚  - idleTimeout: åç»­tokené—´éš”æœ€é•¿ç­‰å¾…                   â”‚
â”‚  - æŠ¥é”™ä¿¡æ¯ï¼š"æµå¼å“åº”è¶…æ—¶ï¼ˆä¸»åŠ¨å…³é—­è¿æ¥ï¼‰"            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **é”™è¯¯åˆ†ç±»å’Œä¿¡æ¯è¦æ±‚**

| é”™è¯¯ç±»å‹ | æ¥æº | é”™è¯¯ä¿¡æ¯æ ¼å¼ | å¤„ç†æ–¹å¼ |
|---------|------|-------------|---------|
| **429 (é™æµ)** | æœåŠ¡å™¨è¿”å› | `RATE_LIMIT: æœåŠ¡å™¨é™æµ` | ç‰¹æ®Šå¤„ç†ï¼ˆé™æµæ¢é’ˆï¼‰ |
| **å…¶ä»–APIé”™è¯¯** | æœåŠ¡å™¨è¿”å› | `API_ERROR: [çŠ¶æ€ç ] å…·ä½“é”™è¯¯ä¿¡æ¯` | æ ‡è®°errorï¼Œæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ |
| **HTTPè¶…æ—¶** | æˆ‘ä»¬ä¸»åŠ¨æ§åˆ¶ | `TIMEOUT: HTTPè¯·æ±‚è¶…æ—¶ï¼ˆä¸»åŠ¨å…³é—­ï¼‰` | æ ‡è®°errorï¼Œå¯é‡è¯• |
| **æµå¼é¦–å­—è¶…æ—¶** | æˆ‘ä»¬ä¸»åŠ¨æ§åˆ¶ | `TIMEOUT: ç­‰å¾…é¦–ä¸ªtokenè¶…æ—¶ï¼ˆä¸»åŠ¨å…³é—­ï¼‰` | æ ‡è®°errorï¼Œå¯é‡è¯• |
| **æµå¼ç©ºé—²è¶…æ—¶** | æˆ‘ä»¬ä¸»åŠ¨æ§åˆ¶ | `TIMEOUT: æµå¼å“åº”ç©ºé—²è¶…æ—¶ï¼ˆä¸»åŠ¨å…³é—­ï¼‰` | æ ‡è®°errorï¼Œå¯é‡è¯• |
| **ä»»åŠ¡æ€»è¶…æ—¶** | å…œåº•æœºåˆ¶ | `TIMEOUT: ä»»åŠ¡æ€»è¶…æ—¶ï¼ˆå…œåº•ï¼‰` | æ ‡è®°errorï¼Œå¯æ‰‹åŠ¨é‡è¯• |
| **æœåŠ¡å™¨ä¸»åŠ¨å…³é—­** | æœåŠ¡å™¨è¡Œä¸º | `CONNECTION: æœåŠ¡å™¨å…³é—­è¿æ¥: [åŸå› ]` | æ ‡è®°errorï¼Œå¯é‡è¯• |

---

### **2ï¸âƒ£ schedulingStrategy å®ç°ï¼ˆå¿…é¡»ï¼‰**

#### **ä¸¤ç§ç­–ç•¥å¯¹æ¯”**

| ç­–ç•¥ | é€‚ç”¨åœºæ™¯ | å·¥ä½œæ–¹å¼ | ç‰¹ç‚¹ |
|------|---------|---------|------|
| **`event`ï¼ˆäº‹ä»¶é©±åŠ¨ï¼‰** | æˆç†Ÿã€é«˜å¹¶å‘ã€ç¨³å®šçš„æä¾›å•† | ä»»åŠ¡å®Œæˆç«‹å³å‘é€ä¸‹ä¸€ä¸ª | æœ€å¤§åŒ–å¹¶å‘åˆ©ç”¨ç‡ |
| **`timed`ï¼ˆå®šæ—¶è°ƒåº¦ï¼‰** | ä½å¹¶å‘ã€ä¸ç¨³å®šçš„æä¾›å•† | å›ºå®šé—´éš”å‘é€ä»»åŠ¡ | é¿å…ç¬æ—¶é«˜å¹¶å‘è§¦å‘é™æµ |

#### **å®ç°è¦æ±‚**

```typescript
// é…ç½®å‚æ•°
interface SchedulerConfig {
  schedulingStrategy: 'timed' | 'event'
  timedInterval?: number  // å½“ç­–ç•¥ä¸º timed æ—¶ï¼Œä»»åŠ¡é—´éš”ï¼ˆç§’ï¼Œ1-10ï¼‰
  // ... å…¶ä»–é…ç½®
}

// è°ƒåº¦å™¨è¡Œä¸º
class BatchScheduler {
  private processQueue() {
    if (this.config.schedulingStrategy === 'event') {
      // äº‹ä»¶é©±åŠ¨ï¼šä»»åŠ¡å®Œæˆç«‹å³è§¦å‘
      // å½“å‰å·²å®ç°ï¼Œæ— éœ€ä¿®æ”¹
    } else if (this.config.schedulingStrategy === 'timed') {
      // å®šæ—¶è°ƒåº¦ï¼šå›ºå®šé—´éš”å‘é€
      // éœ€è¦å®ç°ï¼šä½¿ç”¨ setInterval æ§åˆ¶å‘é€é¢‘ç‡
    }
  }
}
```

---

### **3ï¸âƒ£ Tokenä¼°ç®—ç³»ç»Ÿä¼˜åŒ–**

#### **åˆ é™¤ç°æœ‰ç³»ç»Ÿä¸­çš„Regressionæ¨¡å¼**

âŒ åˆ é™¤ï¼š
- `replyMode: 'regression'` æ¨¡å¼
- æ‰€æœ‰å›å½’ä¼°ç®—é€»è¾‘

âœ… ä¿ç•™ï¼š
- `replyMode: 'predicted'` æ¨¡å¼
- `replyMode: 'equivalent'` æ¨¡å¼ï¼ˆç­‰é¢ä¼°ç®—ï¼‰

#### **æ–°ç³»ç»Ÿè®¾è®¡ï¼šTokenæ¢ç®—é…ç½®ç³»ç»Ÿ**

##### **æ•°æ®åº“è¡¨è®¾è®¡**

```sql
-- æ–°è¡¨ï¼šTokenæ¢ç®—é…ç½®ï¼ˆå…¨å±€å­˜å‚¨ï¼‰
CREATE TABLE IF NOT EXISTS Llmtranslate_token_conversion_configs (
  id TEXT PRIMARY KEY,          -- UUID
  name TEXT NOT NULL UNIQUE,    -- é…ç½®åç§°ï¼Œå¦‚ "Geminiä¸­æ–‡ä¼˜åŒ–"
  
  -- æ¢ç®—å…¬å¼
  chinese_ratio REAL NOT NULL,  -- ä¸­æ–‡å­—ç¬¦:token æ¯”ä¾‹ï¼ˆå¦‚ 4:1 = 4.0ï¼‰
  ascii_ratio REAL NOT NULL     -- ASCIIå­—ç¬¦:token æ¯”ä¾‹ï¼ˆå¦‚ 1:1 = 1.0ï¼‰
);

-- ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_token_conversion_name 
  ON Llmtranslate_token_conversion_configs(name);
```

##### **é…ç½®æ¥å£**

```typescript
// å‰ç«¯ç±»å‹
export interface TokenConversionConfig {
  id: string
  name: string
  chineseRatio: number   // ä¸­æ–‡å­—ç¬¦:tokenï¼ˆå¦‚ 4 = 4:1ï¼‰
  asciiRatio: number     // ASCIIå­—ç¬¦:tokenï¼ˆå¦‚ 1 = 1:1ï¼‰
  description?: string
}

// é»˜è®¤é…ç½®
export const DEFAULT_TOKEN_CONVERSIONS: TokenConversionConfig[] = [
  {
    id: 'default-balanced',
    name: 'é€šç”¨é…ç½®ï¼ˆå¹³è¡¡ï¼‰',
    chineseRatio: 2.5,
    asciiRatio: 1.0,
    description: 'é€‚ç”¨äºå¤§å¤šæ•°æ¨¡å‹çš„å¹³è¡¡é…ç½®'
  },
  {
    id: 'gemini-chinese',
    name: 'Geminiä¸­æ–‡ä¼˜åŒ–',
    chineseRatio: 4.0,
    asciiRatio: 1.0,
    description: 'Geminiæ¨¡å‹å¯¹ä¸­æ–‡çš„tokenæ¢ç®—'
  },
  {
    id: 'claude-optimized',
    name: 'Claudeä¼˜åŒ–',
    chineseRatio: 2.0,
    asciiRatio: 0.8,
    description: 'Claudeæ¨¡å‹çš„tokenæ¢ç®—'
  }
]
```

##### **ä¼°ç®—é€»è¾‘**

```typescript
class TokenEstimator {
  /**
   * æ ¹æ®é…ç½®ä¼°ç®—tokenæ•°
   */
  estimate(text: string, config: TokenConversionConfig): number {
    let chineseCount = 0
    let asciiCount = 0
    
    for (const char of text) {
      const code = char.charCodeAt(0)
      if (code >= 0x4E00 && code <= 0x9FFF) {
        // ä¸­æ–‡å­—ç¬¦èŒƒå›´
        chineseCount++
      } else if (code < 128) {
        // ASCIIå­—ç¬¦
        asciiCount++
      } else {
        // å…¶ä»–å­—ç¬¦ï¼ˆç»Ÿä¸€è®¡å…¥ASCIIï¼‰
        asciiCount++
      }
    }
    
    const tokens = Math.ceil(
      chineseCount / config.chineseRatio +
      asciiCount / config.asciiRatio
    )
    
    return tokens
  }
}
```

##### **UIå®ç°ï¼šè°ƒåº¦å™¨Draweræ–°å¢Tab**

```vue
<template>
  <el-tabs v-model="activeTab">
    <!-- ç°æœ‰tabs... -->
    
    <!-- ğŸ†• Tokenä¼°ç®—é…ç½® -->
    <el-tab-pane label="Tokenä¼°ç®—" name="token-estimation">
      <el-form>
        <!-- æ¨¡å¼é€‰æ‹© -->
        <el-form-item label="ä¼°ç®—æ¨¡å¼">
          <el-select v-model="tokenEstimationMode">
            <el-option 
              v-for="config in availableConfigs"
              :key="config.id"
              :label="config.name"
              :value="config.id"
            >
              <span>{{ config.name }}</span>
              <div class="text-xs text-gray-400">
                ä¸­æ–‡:{{ config.chineseRatio }}, ASCII:{{ config.asciiRatio }}
              </div>
            </el-option>
          </el-select>
          <el-tooltip content="é€‰æ‹©é€‚åˆå½“å‰æ¨¡å‹çš„tokenæ¢ç®—é…ç½®">
            <el-icon><QuestionFilled /></el-icon>
          </el-tooltip>
        </el-form-item>
        
        <!-- é…ç½®ç®¡ç† -->
        <el-divider>é…ç½®ç®¡ç†</el-divider>
        
        <!-- é…ç½®åˆ—è¡¨ -->
        <el-table :data="customConfigs">
          <el-table-column prop="name" label="åç§°" />
          <el-table-column prop="chineseRatio" label="ä¸­æ–‡æ¯”ä¾‹" />
          <el-table-column prop="asciiRatio" label="ASCIIæ¯”ä¾‹" />
          <el-table-column label="æ“ä½œ">
            <template #default="{ row }">
              <el-button @click="editConfig(row)">ç¼–è¾‘</el-button>
              <el-button @click="deleteConfig(row)">åˆ é™¤</el-button>
            </template>
          </el-table-column>
        </el-table>
        
        <el-button @click="showCreateDialog = true">åˆ›å»ºæ–°é…ç½®</el-button>
      </el-form>
    </el-tab-pane>
  </el-tabs>
  
  <!-- åˆ›å»º/ç¼–è¾‘é…ç½®å¯¹è¯æ¡† -->
  <el-dialog v-model="showCreateDialog" title="åˆ›å»ºTokenæ¢ç®—é…ç½®">
    <el-form :model="newConfigForm">
      <el-form-item label="é…ç½®åç§°" required>
        <el-input v-model="newConfigForm.name" />
      </el-form-item>
      <el-form-item label="ä¸­æ–‡å­—ç¬¦:Tokenæ¯”ä¾‹" required>
        <el-input-number v-model="newConfigForm.chineseRatio" :min="0.5" :max="10" :step="0.5" />
        <el-tooltip content="ä¾‹å¦‚ï¼š4è¡¨ç¤º4ä¸ªä¸­æ–‡å­—ç¬¦ = 1ä¸ªtoken">
          <el-icon><QuestionFilled /></el-icon>
        </el-tooltip>
      </el-form-item>
      <el-form-item label="ASCIIå­—ç¬¦:Tokenæ¯”ä¾‹" required>
        <el-input-number v-model="newConfigForm.asciiRatio" :min="0.1" :max="5" :step="0.1" />
      </el-form-item>
      <el-form-item label="æè¿°">
        <el-input v-model="newConfigForm.description" type="textarea" />
      </el-form-item>
    </el-form>
    <template #footer>
      <el-button @click="showCreateDialog = false">å–æ¶ˆ</el-button>
      <el-button type="primary" @click="createConfig">ä¿å­˜</el-button>
    </template>
  </el-dialog>
</template>
```

---

## ğŸ—ï¸ **å®Œæ•´å®ç°è®¡åˆ’**

### **é˜¶æ®µ 1: æ•°æ®åº“å’Œç±»å‹å®šä¹‰ï¼ˆåŸºç¡€ï¼‰**

#### **1.1 åˆ›å»ºæ–°çš„æ•°æ®åº“Schemaç‰ˆæœ¬**

```typescript
// Nimbria/src-electron/services/database-service/schema/versions/v1.2.3.schema.ts

/**
 * Schema v1.2.3
 * å˜æ›´ï¼š
 * 1. æ–°å¢ Llmtranslate_token_conversion_configs è¡¨
 * 2. ä¸º Llmtranslate_batches.config_json æ·»åŠ æ–°å­—æ®µæ”¯æŒ
 */

const TOKEN_CONVERSION_TABLE: TableDefinition = {
  name: 'Llmtranslate_token_conversion_configs',
  sql: `CREATE TABLE IF NOT EXISTS Llmtranslate_token_conversion_configs (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    chinese_ratio REAL NOT NULL,
    ascii_ratio REAL NOT NULL,
    description TEXT
  )`,
  indexes: [
    `CREATE INDEX IF NOT EXISTS idx_token_conversion_name 
      ON Llmtranslate_token_conversion_configs(name)`
  ]
}
```

#### **1.2 æ‰©å±•å‰ç«¯ç±»å‹å®šä¹‰**

```typescript
// Nimbria/Client/GUI/DemoPage/LlmTranslate/types/config.ts

export interface TranslateConfig {
  // ... ç°æœ‰å­—æ®µ ...
  
  // ğŸ†• è¶…æ—¶æ§åˆ¶ï¼ˆä¸‰å±‚æ¶æ„ï¼‰
  taskTotalTimeout?: number        // ä»»åŠ¡æ€»è¶…æ—¶ï¼ˆæ¯«ç§’ï¼Œå…œåº•ï¼‰
  httpTimeout?: number             // HTTPè¶…æ—¶ï¼ˆæ¯«ç§’ï¼Œéæµå¼ï¼‰
  streamFirstTokenTimeout?: number // æµå¼é¦–å­—è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
  streamIdleTimeout?: number       // æµå¼ç©ºé—²è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
  
  // ğŸ†• Tokenä¼°ç®—é…ç½®
  tokenConversionConfigId?: string // ä½¿ç”¨çš„æ¢ç®—é…ç½®ID
  
  // ğŸ†• è°ƒåº¦ç­–ç•¥
  schedulerConfig?: {
    schedulingStrategy: 'timed' | 'event'
    timedInterval?: number         // timedæ¨¡å¼ä¸‹çš„é—´éš”ï¼ˆç§’ï¼‰
    // ... å…¶ä»–é…ç½®
  }
  
  // âœ… ä¿ç•™
  // replyMode?: 'predicted' | 'equivalent'
  // predictedTokens?: number
}
```

```typescript
// Nimbria/Client/GUI/DemoPage/LlmTranslate/types/token-estimation.ts

/**
 * Tokenæ¢ç®—é…ç½®ç±»å‹
 */
export interface TokenConversionConfig {
  id: string
  name: string
  chineseRatio: number
  asciiRatio: number
  description?: string
}

/**
 * é»˜è®¤é…ç½®
 */
export const DEFAULT_TOKEN_CONVERSIONS: TokenConversionConfig[] = [
  // ... å¦‚ä¸Šæ‰€è¿°
]
```

---

### **é˜¶æ®µ 2: åç«¯æœåŠ¡å±‚ï¼ˆæ ¸å¿ƒé€»è¾‘ï¼‰**

#### **2.1 åˆ›å»ºTokenConversionService**

```typescript
// Nimbria/src-electron/services/llm-translate-service/token-conversion-service.ts

/**
 * Tokenæ¢ç®—é…ç½®ç®¡ç†æœåŠ¡
 * 
 * èŒè´£ï¼š
 * - ç®¡ç†æ¢ç®—é…ç½®çš„CRUD
 * - æä¾›tokenä¼°ç®—åŠŸèƒ½
 * - æŒä¹…åŒ–åˆ°æ•°æ®åº“
 */
export class TokenConversionService {
  private db: Database.Database
  
  /**
   * åˆ›å»ºé…ç½®
   */
  async createConfig(config: Omit<TokenConversionConfig, 'id'>): Promise<TokenConversionConfig> {
    const id = uuid()
    
    const stmt = this.db.prepare(`
      INSERT INTO Llmtranslate_token_conversion_configs 
      (id, name, chinese_ratio, ascii_ratio, description)
      VALUES (?, ?, ?, ?, ?)
    `)
    
    stmt.run(
      id,
      config.name,
      config.chineseRatio,
      config.asciiRatio,
      config.description ?? null
    )
    
    return { ...config, id }
  }
  
  /**
   * ä¼°ç®—tokenæ•°
   */
  estimate(text: string, configId: string): number {
    const config = this.getConfig(configId)
    if (!config) {
      throw new Error(`Token conversion config ${configId} not found`)
    }
    
    let chineseCount = 0
    let asciiCount = 0
    
    for (const char of text) {
      const code = char.charCodeAt(0)
      // ä¸­æ–‡å­—ç¬¦èŒƒå›´ï¼ˆCJKç»Ÿä¸€æ±‰å­—ï¼‰
      if ((code >= 0x4E00 && code <= 0x9FFF) || 
          (code >= 0x3400 && code <= 0x4DBF) ||
          (code >= 0x20000 && code <= 0x2A6DF)) {
        chineseCount++
      } else if (code < 128) {
        asciiCount++
      } else {
        // å…¶ä»–Unicodeå­—ç¬¦æŒ‰ASCIIè®¡
        asciiCount++
      }
    }
    
    const tokens = Math.ceil(
      chineseCount / config.chineseRatio +
      asciiCount / config.asciiRatio
    )
    
    console.log(`ğŸ“Š [TokenConversion] ä¼°ç®—: ä¸­æ–‡=${chineseCount}, ASCII=${asciiCount}, tokens=${tokens}`)
    
    return tokens
  }
}
```

#### **2.2 ä¿®æ”¹TranslationExecutorï¼šå®ç°ä¸‰å±‚è¶…æ—¶**

```typescript
// Nimbria/src-electron/services/llm-translate-service/translation-executor.ts

private async executeTask(...) {
  // ... ç°æœ‰ä»£ç  ...
  
  // ğŸ†• ä¸‰å±‚è¶…æ—¶æ§åˆ¶
  const taskTotalTimeout = config.taskTotalTimeout ?? 600000  // é»˜è®¤10åˆ†é’Ÿï¼ˆå…œåº•ï¼‰
  const httpTimeout = config.httpTimeout ?? 120000            // é»˜è®¤2åˆ†é’Ÿï¼ˆéæµå¼ï¼‰
  const streamFirstTokenTimeout = config.streamFirstTokenTimeout ?? 60000  // é»˜è®¤1åˆ†é’Ÿ
  const streamIdleTimeout = config.streamIdleTimeout ?? 60000 // é»˜è®¤1åˆ†é’Ÿ
  
  console.log(`â±ï¸  è¶…æ—¶é…ç½®:`)
  console.log(`   - ä»»åŠ¡æ€»è¶…æ—¶ï¼ˆå…œåº•ï¼‰: ${taskTotalTimeout}ms`)
  console.log(`   - HTTPè¶…æ—¶ï¼ˆéæµå¼ï¼‰: ${httpTimeout}ms`)
  if (enableStreaming) {
    console.log(`   - æµå¼é¦–å­—è¶…æ—¶: ${streamFirstTokenTimeout}ms`)
    console.log(`   - æµå¼ç©ºé—²è¶…æ—¶: ${streamIdleTimeout}ms`)
  }
  
  // ğŸ†• ä»»åŠ¡æ€»è¶…æ—¶ï¼ˆå…œåº•ï¼‰
  const taskTimeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error('TIMEOUT: ä»»åŠ¡æ€»è¶…æ—¶ï¼ˆå…œåº•ï¼‰'))
    }, taskTotalTimeout)
  })
  
  // æ‰§è¡Œç¿»è¯‘ï¼ˆä¸ä»»åŠ¡æ€»è¶…æ—¶ç«é€Ÿï¼‰
  const translationPromise = (async () => {
    if (enableStreaming) {
      // æµå¼ï¼šä¼ é€’é¦–å­—å’Œç©ºé—²è¶…æ—¶ç»™client
      return await client.translateStream(request, {
        // callbacks...
      }, {
        firstTokenTimeout: streamFirstTokenTimeout,
        idleTimeout: streamIdleTimeout
      })
    } else {
      // éæµå¼ï¼šä½¿ç”¨HTTPè¶…æ—¶
      return await client.translate(request, {
        timeout: httpTimeout
      })
    }
  })()
  
  // ç«é€Ÿæ‰§è¡Œ
  const result = await Promise.race([translationPromise, taskTimeoutPromise])
  
  // ... å¤„ç†ç»“æœ ...
}

/**
 * ğŸ†• é”™è¯¯åˆ†ç±»ï¼ˆæ‰©å±•ï¼‰
 */
private classifyError(error: Error): ErrorType {
  const message = error.message
  
  // è¶…æ—¶é”™è¯¯
  if (message.includes('TIMEOUT:')) {
    if (message.includes('ä»»åŠ¡æ€»è¶…æ—¶')) return 'TIMEOUT_TOTAL'
    if (message.includes('HTTPè¯·æ±‚è¶…æ—¶')) return 'TIMEOUT_HTTP'
    if (message.includes('é¦–ä¸ªtokenè¶…æ—¶')) return 'TIMEOUT_FIRST_TOKEN'
    if (message.includes('ç©ºé—²è¶…æ—¶')) return 'TIMEOUT_IDLE'
    return 'TIMEOUT'
  }
  
  // 429é™æµ
  if (message.includes('429') || message.includes('rate limit')) {
    return 'RATE_LIMIT'
  }
  
  // æœåŠ¡å™¨å…³é—­è¿æ¥
  if (message.includes('CONNECTION:')) {
    return 'CONNECTION_CLOSED'
  }
  
  // APIé”™è¯¯
  if (message.includes('API_ERROR:')) {
    return 'API_ERROR'
  }
  
  return 'UNKNOWN'
}
```

#### **2.3 ä¿®æ”¹LlmTranslationClientï¼šå®ç°æµå¼è¶…æ—¶æ§åˆ¶**

```typescript
// Nimbria/src-electron/services/llm-translate-service/llm-translation-client.ts

async translateStream(
  request: TranslationRequest,
  callbacks: TranslationStreamCallbacks,
  timeouts?: {
    firstTokenTimeout?: number
    idleTimeout?: number
  }
): Promise<TranslationResult> {
  const firstTokenTimeout = timeouts?.firstTokenTimeout ?? 60000
  const idleTimeout = timeouts?.idleTimeout ?? 60000
  
  let receivedFirstToken = false
  let lastChunkTime = Date.now()
  
  // ğŸ†• é¦–å­—è¶…æ—¶æ£€æµ‹
  const firstTokenTimer = setTimeout(() => {
    if (!receivedFirstToken) {
      console.error(`âŒ [TranslationClient] ä»»åŠ¡ ${request.taskId} é¦–å­—è¶…æ—¶`)
      this.cancelled = true
      throw new Error('TIMEOUT: ç­‰å¾…é¦–ä¸ªtokenè¶…æ—¶ï¼ˆä¸»åŠ¨å…³é—­ï¼‰')
    }
  }, firstTokenTimeout)
  
  // ğŸ†• ç©ºé—²è¶…æ—¶æ£€æµ‹
  const idleTimer = setInterval(() => {
    if (receivedFirstToken && Date.now() - lastChunkTime > idleTimeout) {
      console.error(`âŒ [TranslationClient] ä»»åŠ¡ ${request.taskId} ç©ºé—²è¶…æ—¶`)
      clearInterval(idleTimer)
      this.cancelled = true
      throw new Error('TIMEOUT: æµå¼å“åº”ç©ºé—²è¶…æ—¶ï¼ˆä¸»åŠ¨å…³é—­ï¼‰')
    }
  }, 1000)  // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
  
  try {
    await client.chatStream(messages, {
      onChunk: (chunk: string) => {
        if (!receivedFirstToken) {
          receivedFirstToken = true
          clearTimeout(firstTokenTimer)
          console.log(`âœ… [TranslationClient] ä»»åŠ¡ ${request.taskId} æ”¶åˆ°é¦–å­—`)
        }
        lastChunkTime = Date.now()
        
        // ... æ­£å¸¸å¤„ç†chunk ...
      }
    })
  } finally {
    clearTimeout(firstTokenTimer)
    clearInterval(idleTimer)
  }
}
```

#### **2.4 ä¿®æ”¹BatchSchedulerï¼šå®ç°schedulingStrategy**

```typescript
// Nimbria/src-electron/services/llm-translate-service/batch-scheduler.ts

export class BatchScheduler extends EventEmitter {
  private schedulingStrategy: 'timed' | 'event'
  private timedInterval?: number
  private timedIntervalTimer?: NodeJS.Timeout
  
  constructor(options: BatchSchedulerOptions) {
    // ... ç°æœ‰ä»£ç  ...
    
    this.schedulingStrategy = options.config.schedulerConfig?.schedulingStrategy ?? 'event'
    this.timedInterval = options.config.schedulerConfig?.timedInterval ?? 2  // é»˜è®¤2ç§’
    
    console.log(`ğŸ¯ [BatchScheduler] è°ƒåº¦ç­–ç•¥: ${this.schedulingStrategy}`)
    if (this.schedulingStrategy === 'timed') {
      console.log(`   â±ï¸  å®šæ—¶é—´éš”: ${this.timedInterval}ç§’`)
    }
  }
  
  start(): void {
    // ... ç°æœ‰ä»£ç  ...
    
    if (this.schedulingStrategy === 'timed') {
      // ğŸ†• å®šæ—¶è°ƒåº¦æ¨¡å¼
      this.startTimedScheduling()
    } else {
      // âœ… äº‹ä»¶é©±åŠ¨æ¨¡å¼ï¼ˆå½“å‰å®ç°ï¼‰
      this.processQueue()
    }
  }
  
  /**
   * ğŸ†• å®šæ—¶è°ƒåº¦æ¨¡å¼
   */
  private startTimedScheduling(): void {
    console.log(`â° [BatchScheduler] å¯åŠ¨å®šæ—¶è°ƒåº¦æ¨¡å¼`)
    
    // ç«‹å³å‘é€ç¬¬ä¸€æ‰¹
    this.processQueue()
    
    // è®¾ç½®å®šæ—¶å™¨
    this.timedIntervalTimer = setInterval(() => {
      if (!this.isRunning || this.isPaused || this.isThrottled) {
        return
      }
      
      console.log(`â° [BatchScheduler] å®šæ—¶è§¦å‘ä»»åŠ¡å‘é€`)
      this.processQueue()
    }, (this.timedInterval ?? 2) * 1000)
  }
  
  /**
   * ä¿®æ”¹äº‹ä»¶ç›‘å¬å™¨ï¼ˆä»…åœ¨eventæ¨¡å¼ä¸‹è§¦å‘processQueueï¼‰
   */
  private handleTaskComplete(data: any): void {
    // ... ç°æœ‰ä»£ç  ...
    
    // åªåœ¨äº‹ä»¶é©±åŠ¨æ¨¡å¼ä¸‹ç«‹å³è§¦å‘ä¸‹ä¸€æ‰¹
    if (this.schedulingStrategy === 'event') {
      void this.processQueue()
    }
    // timedæ¨¡å¼ä¸‹ç”±å®šæ—¶å™¨æ§åˆ¶ï¼Œè¿™é‡Œä¸è§¦å‘
  }
  
  stop(): void {
    // ... ç°æœ‰ä»£ç  ...
    
    // æ¸…ç†å®šæ—¶å™¨
    if (this.timedIntervalTimer) {
      clearInterval(this.timedIntervalTimer)
      this.timedIntervalTimer = undefined
    }
  }
}
```

---

### **é˜¶æ®µ 3: å‰ç«¯UIï¼ˆç”¨æˆ·äº¤äº’ï¼‰**

#### **3.1 æ‰©å±•SchedulerConfigDrawerï¼šæ–°å¢ä¸‰ä¸ªTab**

```vue
<!-- Nimbria/Client/GUI/DemoPage/LlmTranslate/components/SchedulerConfigDrawer.vue -->

<template>
  <el-drawer ...>
    <el-tabs v-model="activeTab">
      <!-- âœ… ç°æœ‰Tabï¼šåŸºç¡€è®¾ç½®ã€æ¨¡å‹é…ç½®ã€è¯·æ±‚æ§åˆ¶ -->
      
      <!-- ğŸ†• Tab 4: è¶…æ—¶æ§åˆ¶ -->
      <el-tab-pane label="è¶…æ—¶æ§åˆ¶" name="timeout">
        <el-form :model="timeoutForm">
          <el-alert type="info" :closable="false">
            <p><strong>ä¸‰å±‚è¶…æ—¶æ¶æ„</strong></p>
            <p>ä¼˜å…ˆçº§ï¼šæœåŠ¡å™¨è¿”å› > æˆ‘ä»¬çš„è¶…æ—¶æ§åˆ¶</p>
          </el-alert>
          
          <!-- ä»»åŠ¡æ€»è¶…æ—¶ï¼ˆå…œåº•ï¼‰ -->
          <el-form-item label="ä»»åŠ¡æ€»è¶…æ—¶ï¼ˆå…œåº•ï¼‰">
            <el-input-number 
              v-model="timeoutForm.taskTotalTimeoutSeconds"
              :min="60" 
              :max="600" 
              :step="30"
            />
            <span class="unit">ç§’</span>
            <el-tooltip>
              <template #content>
                <div style="max-width: 300px;">
                  <strong>å…œåº•æœºåˆ¶</strong><br/>
                  åŒ…æ‹¬æ’é˜Ÿã€æ‰§è¡Œã€é‡è¯•çš„å…¨éƒ¨æ—¶é—´ã€‚<br/>
                  å¯ä»¥è®¾å¾—å¾ˆé•¿ï¼ˆå¦‚10åˆ†é’Ÿï¼‰ã€‚<br/>
                  è¶…æ—¶åæ ‡è®°ä¸ºerrorï¼Œå¯æ‰‹åŠ¨é‡è¯•ã€‚
                </div>
              </template>
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
          
          <!-- éæµå¼HTTPè¶…æ—¶ -->
          <el-form-item label="HTTPè¶…æ—¶ï¼ˆéæµå¼ï¼‰">
            <el-input-number 
              v-model="timeoutForm.httpTimeoutSeconds"
              :min="10" 
              :max="300" 
              :step="10"
            />
            <span class="unit">ç§’</span>
            <el-tooltip>
              <template #content>
                <div style="max-width: 300px;">
                  <strong>éæµå¼æ¨¡å¼ä¸“ç”¨</strong><br/>
                  æ•´ä¸ªHTTPè¯·æ±‚çš„æœ€é•¿ç­‰å¾…æ—¶é—´ã€‚<br/>
                  è¶…æ—¶åä¸»åŠ¨å…³é—­è¿æ¥ï¼Œæ ‡è®°ä¸ºerrorï¼Œå¯é‡è¯•ã€‚
                </div>
              </template>
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
          
          <!-- æµå¼é¦–å­—è¶…æ—¶ -->
          <el-form-item label="æµå¼é¦–å­—è¶…æ—¶">
            <el-input-number 
              v-model="timeoutForm.streamFirstTokenTimeoutSeconds"
              :min="5" 
              :max="180" 
              :step="5"
            />
            <span class="unit">ç§’</span>
            <el-tooltip>
              <template #content>
                <div style="max-width: 300px;">
                  <strong>æµå¼æ¨¡å¼ä¸“ç”¨</strong><br/>
                  ç­‰å¾…é¦–ä¸ªtokençš„æœ€é•¿æ—¶é—´ã€‚<br/>
                  è¶…æ—¶åä¸»åŠ¨å…³é—­è¿æ¥ï¼Œæ ‡è®°ä¸ºerrorï¼Œå¯é‡è¯•ã€‚<br/>
                  âš ï¸ ä»…åœ¨å¯ç”¨æµå¼æ—¶ç”Ÿæ•ˆ
                </div>
              </template>
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
          
          <!-- æµå¼ç©ºé—²è¶…æ—¶ -->
          <el-form-item label="æµå¼ç©ºé—²è¶…æ—¶">
            <el-input-number 
              v-model="timeoutForm.streamIdleTimeoutSeconds"
              :min="5" 
              :max="180" 
              :step="5"
            />
            <span class="unit">ç§’</span>
            <el-tooltip>
              <template #content>
                <div style="max-width: 300px;">
                  <strong>æµå¼æ¨¡å¼ä¸“ç”¨</strong><br/>
                  åç»­tokenä¹‹é—´çš„æœ€é•¿é—´éš”ã€‚<br/>
                  è¶…æ—¶åä¸»åŠ¨å…³é—­è¿æ¥ï¼Œæ ‡è®°ä¸ºerrorï¼Œå¯é‡è¯•ã€‚<br/>
                  âš ï¸ ä»…åœ¨å¯ç”¨æµå¼æ—¶ç”Ÿæ•ˆ
                </div>
              </template>
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
        </el-form>
      </el-tab-pane>
      
      <!-- ğŸ†• Tab 5: è°ƒåº¦ç­–ç•¥ -->
      <el-tab-pane label="è°ƒåº¦ç­–ç•¥" name="strategy">
        <el-form :model="strategyForm">
          <el-form-item label="è°ƒåº¦ç­–ç•¥">
            <el-radio-group v-model="strategyForm.schedulingStrategy">
              <el-radio label="event">
                <strong>äº‹ä»¶é©±åŠ¨</strong>
                <p class="strategy-desc">
                  ä»»åŠ¡å®Œæˆç«‹å³å‘é€ä¸‹ä¸€ä¸ªï¼Œæœ€å¤§åŒ–å¹¶å‘åˆ©ç”¨ç‡ã€‚<br/>
                  <em>é€‚ç”¨äºï¼šæˆç†Ÿã€é«˜å¹¶å‘ã€ç¨³å®šçš„æä¾›å•†ï¼ˆå¦‚OpenAIã€Claudeï¼‰</em>
                </p>
              </el-radio>
              <el-radio label="timed">
                <strong>å®šæ—¶è°ƒåº¦</strong>
                <p class="strategy-desc">
                  å›ºå®šé—´éš”å‘é€ä»»åŠ¡ï¼Œé¿å…ç¬æ—¶é«˜å¹¶å‘ã€‚<br/>
                  <em>é€‚ç”¨äºï¼šä½å¹¶å‘ã€ä¸ç¨³å®šçš„æä¾›å•†ï¼ˆå¦‚å°å‹APIï¼‰</em>
                </p>
              </el-radio>
            </el-radio-group>
          </el-form-item>
          
          <!-- å®šæ—¶é—´éš”ï¼ˆä»…timedæ¨¡å¼ï¼‰ -->
          <el-form-item 
            v-if="strategyForm.schedulingStrategy === 'timed'" 
            label="ä»»åŠ¡å‘é€é—´éš”"
          >
            <el-input-number 
              v-model="strategyForm.timedInterval"
              :min="1" 
              :max="10" 
              :step="0.5"
            />
            <span class="unit">ç§’</span>
            <el-tooltip content="æ¯éš”å¤šå°‘ç§’å‘é€ä¸€æ‰¹ä»»åŠ¡ï¼ˆå—å¹¶å‘æ•°é™åˆ¶ï¼‰">
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
        </el-form>
      </el-tab-pane>
      
      <!-- ğŸ†• Tab 6: Tokenä¼°ç®— -->
      <el-tab-pane label="Tokenä¼°ç®—" name="token-estimation">
        <el-form :model="tokenForm">
          <!-- æ¨¡å¼é€‰æ‹© -->
          <el-form-item label="ä¼°ç®—é…ç½®">
            <el-select 
              v-model="tokenForm.tokenConversionConfigId"
              filterable
              placeholder="é€‰æ‹©tokenæ¢ç®—é…ç½®"
            >
              <el-option 
                v-for="config in tokenConversionConfigs"
                :key="config.id"
                :label="config.name"
                :value="config.id"
              >
                <div class="config-option">
                  <span><strong>{{ config.name }}</strong></span>
                  <div class="text-xs text-gray-400">
                    ä¸­æ–‡:{{ config.chineseRatio }}, ASCII:{{ config.asciiRatio }}
                  </div>
                </div>
              </el-option>
            </el-select>
            <el-tooltip>
              <template #content>
                <div style="max-width: 300px;">
                  é€‰æ‹©é€‚åˆå½“å‰æ¨¡å‹çš„tokenæ¢ç®—é…ç½®ã€‚<br/>
                  ç”¨äºè¿›åº¦æ¡é¢„ä¼°å’Œæˆæœ¬è®¡ç®—ã€‚
                </div>
              </template>
              <el-icon><QuestionFilled /></el-icon>
            </el-tooltip>
          </el-form-item>
          
          <!-- é…ç½®ç®¡ç† -->
          <el-divider>é…ç½®ç®¡ç†</el-divider>
          
          <el-button @click="showTokenConfigDialog = true">åˆ›å»ºæ–°é…ç½®</el-button>
          
          <!-- é…ç½®åˆ—è¡¨ -->
          <el-table :data="customTokenConfigs" style="margin-top: 16px;">
            <el-table-column prop="name" label="åç§°" />
            <el-table-column prop="chineseRatio" label="ä¸­æ–‡æ¯”ä¾‹" width="100" />
            <el-table-column prop="asciiRatio" label="ASCIIæ¯”ä¾‹" width="100" />
            <el-table-column label="æ“ä½œ" width="150">
              <template #default="{ row }">
                <el-button size="small" @click="editTokenConfig(row)">ç¼–è¾‘</el-button>
                <el-button size="small" type="danger" @click="deleteTokenConfig(row)">åˆ é™¤</el-button>
              </template>
            </el-table-column>
          </el-table>
        </el-form>
      </el-tab-pane>
    </el-tabs>
  </el-drawer>
  
  <!-- Tokené…ç½®å¯¹è¯æ¡† -->
  <TokenConfigDialog 
    v-model="showTokenConfigDialog"
    :config="editingTokenConfig"
    @confirm="handleTokenConfigSave"
  />
</template>

<script setup lang="ts">
// ... æ·»åŠ æ–°çš„å“åº”å¼æ•°æ®å’Œæ–¹æ³• ...
</script>
```

#### **3.2 åˆ›å»ºTokenConfigDialogç»„ä»¶**

```vue
<!-- Nimbria/Client/GUI/DemoPage/LlmTranslate/components/TokenConfigDialog.vue -->

<template>
  <el-dialog :model-value="modelValue" title="Tokenæ¢ç®—é…ç½®" @close="$emit('update:modelValue', false)">
    <el-form :model="form" :rules="rules" ref="formRef">
      <el-form-item label="é…ç½®åç§°" prop="name" required>
        <el-input v-model="form.name" placeholder="å¦‚ï¼šGeminiä¸­æ–‡ä¼˜åŒ–" />
      </el-form-item>
      
      <el-form-item label="ä¸­æ–‡å­—ç¬¦:Tokenæ¯”ä¾‹" prop="chineseRatio" required>
        <el-input-number 
          v-model="form.chineseRatio" 
          :min="0.5" 
          :max="10" 
          :step="0.1"
          :precision="1"
        />
        <el-tooltip content="å‡ ä¸ªä¸­æ–‡å­—ç¬¦ = 1ä¸ªtokenã€‚ä¾‹å¦‚ï¼š4 è¡¨ç¤º 4:1">
          <el-icon><QuestionFilled /></el-icon>
        </el-tooltip>
      </el-form-item>
      
      <el-form-item label="ASCIIå­—ç¬¦:Tokenæ¯”ä¾‹" prop="asciiRatio" required>
        <el-input-number 
          v-model="form.asciiRatio" 
          :min="0.1" 
          :max="5" 
          :step="0.1"
          :precision="1"
        />
      </el-form-item>
      
      <el-form-item label="æè¿°">
        <el-input v-model="form.description" type="textarea" :rows="3" />
      </el-form-item>
      
      <!-- æµ‹è¯•ä¼°ç®— -->
      <el-divider>æµ‹è¯•ä¼°ç®—</el-divider>
      <el-input 
        v-model="testText" 
        type="textarea" 
        :rows="3" 
        placeholder="è¾“å…¥æµ‹è¯•æ–‡æœ¬ï¼ŒæŸ¥çœ‹tokenä¼°ç®—ç»“æœ"
      />
      <div v-if="testText" class="test-result">
        <p><strong>ä¼°ç®—ç»“æœï¼š</strong>{{ estimatedTokens }} tokens</p>
        <p class="text-gray-500">
          ä¸­æ–‡å­—ç¬¦ï¼š{{ chineseCount }}ï¼ŒASCIIå­—ç¬¦ï¼š{{ asciiCount }}
        </p>
      </div>
    </el-form>
    
    <template #footer>
      <el-button @click="$emit('update:modelValue', false)">å–æ¶ˆ</el-button>
      <el-button type="primary" @click="handleConfirm">ä¿å­˜</el-button>
    </template>
  </el-dialog>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import type { TokenConversionConfig } from '../types/token-estimation'

const props = defineProps<{
  modelValue: boolean
  config?: TokenConversionConfig | null
}>()

const emit = defineEmits<{
  'update:modelValue': [value: boolean]
  'confirm': [config: Omit<TokenConversionConfig, 'id'>]
}>()

const form = ref({
  name: '',
  chineseRatio: 2.5,
  asciiRatio: 1.0,
  description: ''
})

const testText = ref('')

// å®æ—¶ä¼°ç®—
const estimatedTokens = computed(() => {
  if (!testText.value) return 0
  
  let chinese = 0
  let ascii = 0
  
  for (const char of testText.value) {
    const code = char.charCodeAt(0)
    if ((code >= 0x4E00 && code <= 0x9FFF) || 
        (code >= 0x3400 && code <= 0x4DBF) ||
        (code >= 0x20000 && code <= 0x2A6DF)) {
      chinese++
    } else if (code < 128) {
      ascii++
    } else {
      ascii++
    }
  }
  
  return Math.ceil(chinese / form.value.chineseRatio + ascii / form.value.asciiRatio)
})

const chineseCount = computed(() => {
  // ... è®¡ç®—ä¸­æ–‡å­—ç¬¦æ•° ...
})

const asciiCount = computed(() => {
  // ... è®¡ç®—ASCIIå­—ç¬¦æ•° ...
})

const handleConfirm = () => {
  emit('confirm', { ...form.value })
  emit('update:modelValue', false)
}
</script>
```

---

### **é˜¶æ®µ 4: IPCå’Œæ•°æ®æµï¼ˆè¿æ¥å‰åç«¯ï¼‰**

#### **4.1 æ·»åŠ IPC handlers**

```typescript
// Nimbria/src-electron/ipc/main-renderer/llm-translate-handlers.ts

// ğŸ†• Tokenæ¢ç®—é…ç½®ç›¸å…³
ipcMain.handle('llm-translate:create-token-config', async (_event, args: {
  config: Omit<TokenConversionConfig, 'id'>
}) => {
  try {
    const result = await tokenConversionService.createConfig(args.config)
    return { success: true, data: result }
  } catch (error) {
    return { success: false, error: String(error) }
  }
})

ipcMain.handle('llm-translate:get-token-configs', async () => {
  try {
    const configs = await tokenConversionService.getAllConfigs()
    return { success: true, data: configs }
  } catch (error) {
    return { success: false, error: String(error) }
  }
})

ipcMain.handle('llm-translate:delete-token-config', async (_event, args: { id: string }) => {
  try {
    await tokenConversionService.deleteConfig(args.id)
    return { success: true }
  } catch (error) {
    return { success: false, error: String(error) }
  }
})
```

#### **4.2 æ‰©å±•datasource**

```typescript
// Nimbria/Client/GUI/DemoPage/LlmTranslate/stores/translate.datasource.ts

export class TranslateDatasource {
  // ğŸ†• Tokenæ¢ç®—é…ç½®
  async createTokenConfig(config: Omit<TokenConversionConfig, 'id'>): Promise<TokenConversionConfig> {
    const result = await this.electronAPI.createTokenConfig({ config })
    if (!result.success) {
      throw new Error(result.error || 'åˆ›å»ºé…ç½®å¤±è´¥')
    }
    return result.data
  }
  
  async getTokenConfigs(): Promise<TokenConversionConfig[]> {
    const result = await this.electronAPI.getTokenConfigs()
    if (!result.success) {
      throw new Error(result.error || 'è·å–é…ç½®å¤±è´¥')
    }
    return result.data
  }
  
  async deleteTokenConfig(id: string): Promise<void> {
    const result = await this.electronAPI.deleteTokenConfig({ id })
    if (!result.success) {
      throw new Error(result.error || 'åˆ é™¤é…ç½®å¤±è´¥')
    }
  }
}
```

---

## ğŸ“ **ä»£ç è´¨é‡è¦æ±‚**

### **1. ä½¿ç”¨ `??` è€Œé `||`**

```typescript
// âœ… æ­£ç¡®ï¼šä½¿ç”¨ ?? ä¿ç•™ falsy å€¼
const timeout = config.httpTimeout ?? 120000  // 0 ä¼šè¢«ä¿ç•™
const retry = config.maxRetries ?? 3          // 0 ä¼šè¢«ä¿ç•™

// âŒ é”™è¯¯ï¼šä½¿ç”¨ || ä¼šè¦†ç›– falsy å€¼
const timeout = config.httpTimeout || 120000  // 0 ä¼šè¢«æ›¿æ¢ä¸º 120000
```

### **2. å……åˆ†çš„æ³¨é‡Šå’Œè¯´æ˜**

```typescript
/**
 * ä¸‰å±‚è¶…æ—¶æ¶æ„
 * 
 * Layer 3 (å…œåº•): taskTotalTimeout - åŒ…æ‹¬æ’é˜Ÿã€æ‰§è¡Œã€é‡è¯•çš„å…¨éƒ¨æ—¶é—´
 * Layer 2a (éæµå¼): httpTimeout - HTTPè¯·æ±‚çš„æœ€é•¿ç­‰å¾…æ—¶é—´
 * Layer 2b (æµå¼): streamFirstTokenTimeout + streamIdleTimeout
 * 
 * ä¼˜å…ˆçº§: æœåŠ¡å™¨è¿”å› > æˆ‘ä»¬çš„è¶…æ—¶æ§åˆ¶
 * 
 * âš ï¸ æ³¨æ„ï¼šæµå¼è¶…æ—¶é…ç½®ä»…åœ¨ enableStreaming=true æ—¶ç”Ÿæ•ˆ
 */
const taskTotalTimeout = config.taskTotalTimeout ?? 600000
```

### **3. ç±»å‹å®‰å…¨**

```typescript
// âŒ é¿å… any
function handle(data: any) { ... }

// âœ… ä½¿ç”¨å…·ä½“ç±»å‹
function handle(data: TranslateConfig) { ... }

// âœ… ä½¿ç”¨è”åˆç±»å‹
type ErrorType = 
  | 'TIMEOUT_TOTAL' 
  | 'TIMEOUT_HTTP' 
  | 'TIMEOUT_FIRST_TOKEN' 
  | 'TIMEOUT_IDLE'
  | 'RATE_LIMIT'
  | 'API_ERROR'
  | 'CONNECTION_CLOSED'
  | 'UNKNOWN'
```

---

## ğŸ§ª **æµ‹è¯•è®¡åˆ’**

### **æµ‹è¯•åœºæ™¯**

| åœºæ™¯ | é…ç½® | é¢„æœŸç»“æœ |
|------|------|---------|
| **è¶…æ—¶æµ‹è¯•1** | éæµå¼ï¼ŒhttpTimeout=10sï¼Œæ¨¡æ‹Ÿæ…¢API | 10ç§’åæŠ¥é”™"HTTPè¯·æ±‚è¶…æ—¶ï¼ˆä¸»åŠ¨å…³é—­ï¼‰" |
| **è¶…æ—¶æµ‹è¯•2** | æµå¼ï¼ŒfirstTokenTimeout=5sï¼Œæ¨¡æ‹Ÿæ— å“åº” | 5ç§’åæŠ¥é”™"é¦–ä¸ªtokenè¶…æ—¶ï¼ˆä¸»åŠ¨å…³é—­ï¼‰" |
| **è¶…æ—¶æµ‹è¯•3** | æµå¼ï¼ŒidleTimeout=10sï¼Œæ¨¡æ‹Ÿä¸­é€”å¡é¡¿ | 10ç§’åæŠ¥é”™"æµå¼å“åº”ç©ºé—²è¶…æ—¶ï¼ˆä¸»åŠ¨å…³é—­ï¼‰" |
| **è¶…æ—¶æµ‹è¯•4** | taskTotalTimeout=30sï¼Œæ¨¡æ‹Ÿé•¿æ—¶é—´æ’é˜Ÿ | 30ç§’åæŠ¥é”™"ä»»åŠ¡æ€»è¶…æ—¶ï¼ˆå…œåº•ï¼‰" |
| **ç­–ç•¥æµ‹è¯•1** | schedulingStrategy='event'ï¼Œå¹¶å‘=3 | ä»»åŠ¡å®Œæˆç«‹å³å‘é€ä¸‹ä¸€ä¸ª |
| **ç­–ç•¥æµ‹è¯•2** | schedulingStrategy='timed'ï¼Œinterval=2s | æ¯2ç§’å‘é€ä¸€æ‰¹ä»»åŠ¡ |
| **Tokenæµ‹è¯•1** | gemini-chineseé…ç½®ï¼ˆ4:1ï¼‰ï¼Œçº¯ä¸­æ–‡æ–‡æœ¬ | 100å­—=25 tokens |
| **Tokenæµ‹è¯•2** | æ··åˆæ–‡æœ¬ï¼Œè‡ªå®šä¹‰é…ç½® | æŒ‰é…ç½®æ¯”ä¾‹æ­£ç¡®è®¡ç®— |
| **æ‰‹åŠ¨é‡è¯•æµ‹è¯•** | ä»»åŠ¡è¶…æ—¶åï¼Œç‚¹å‡»é‡è¯•æŒ‰é’® | ä»»åŠ¡é‡æ–°å‘é€ï¼Œå…è®¸æ‰‹åŠ¨é‡è¯• |

---

âœ… **ä¿®æ”¹å®Œæˆï¼æ‰€æœ‰æ‰¹æ³¨å·²å¤„ç†ã€‚**

## ğŸ¯ **ä¿®æ”¹æ€»ç»“**

### **ä¿®æ”¹å†…å®¹**

1. âœ… **åˆ é™¤æ‰€æœ‰ `//` æ‰¹æ³¨è¡Œ** - å…± 3 å¤„å·²åˆ é™¤
2. âœ… **ä»»åŠ¡æ€»è¶…æ—¶æ”¹ä¸º"å¯æ‰‹åŠ¨é‡è¯•"** - æ›´æ–°äº†è¡¨æ ¼å’Œ UI tooltip
3. âœ… **Tokenç³»ç»Ÿæ”¹ä¸ºä»…åˆ regression** - ä¿ç•™äº† predicted å’Œ equivalent
4. âœ… **ç®€åŒ–æ•°æ®åº“è¡¨** - åˆ é™¤äº† target_modelsã€created_atã€updated_at
5. âœ… **æ›´æ–°æ‰€æœ‰ä»£ç ç¤ºä¾‹** - ç±»å‹å®šä¹‰ã€SQLã€UIã€æœåŠ¡å±‚éƒ½å·²åŒæ­¥

### **å…³é”®å˜æ›´**

| é¡¹ç›® | åŸæ¥ | ç°åœ¨ |
|------|------|------|
| **é”™è¯¯é‡è¯•** | ä¸å¯é‡è¯• | å¯æ‰‹åŠ¨é‡è¯• |
| **Tokenæ¨¡å¼** | åˆ  predicted/equivalent/regression | åˆ  regressionï¼Œä¿ç•™å…¶ä»– |
| **æ•°æ®åº“å­—æ®µ** | 12ä¸ªå­—æ®µ | 5ä¸ªå­—æ®µï¼ˆç²¾ç®€ï¼‰ |
| **é…ç½®å­—æ®µ** | targetModels, createdAt, updatedAt | description |
| **UIè¡¨å•** | æ¨¡å‹é€‰æ‹©ã€æ—¶é—´æˆ³ | ç®€åŒ–ä¸ºä»…é…ç½®æ¯”ä¾‹å’Œæè¿° |

è¿™ä¸ªè®¡åˆ’ç°åœ¨**å®Œå…¨åŸºäºåŸæœ‰ç³»ç»Ÿçš„ä¼˜åŒ–**ï¼Œæ²¡æœ‰"ç©ºæ°”ç‚‰ç¶"ï¼âœ¨