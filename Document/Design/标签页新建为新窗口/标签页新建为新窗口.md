Boss，这是一个很有意思的需求！让我先研究一下现有的多窗口架构系统。

[5 tools called]

Boss，我已经详细研究了现有的多窗口架构系统。现在我给您提供一个完整的实现思路。

## 📊 **当前架构分析**

### 现有多窗口系统特点：
1. **进程级隔离**：每个窗口独立渲染进程，状态完全隔离
2. **两种窗口类型**：`main`（主窗口）和 `project`（项目窗口）
3. **通信机制**：通过 MessagePort 进行进程间通信
4. **状态管理**：每个窗口有独立的 Pinia store 实例

### 布局结构：
```
ProjectMainLayout
├── ProjectPage.Shell (左栏：导航 + 文件树)
├── ProjectPage.MainPanel (主内容区：PaneSystem)
└── RightSidebar (右栏：插件系统)
```

---

## 💡 **实现思路方案**

### **方案一：子窗口 + 状态同步（推荐）**

#### 核心设计：
1. **新增窗口类型**：`project-detached-pane`
   - 是 `project` 窗口的子窗口
   - 只渲染 `PaneSystem` 组件（无左栏、无右栏）
   - 包含命令面板，但操作的是母窗口的右栏
   - 与父窗口共享项目路径

2. **父子窗口关系管理**：
   ```typescript
   interface ProjectWindowProcess {
     type: 'project'
     projectPath: string
     childWindows?: Set<string>  // 子窗口ID列表
   }
   
   interface DetachedPaneWindowProcess {
     type: 'project-detached-pane'
     projectPath: string
     parentProcessId: string  // 父窗口ID
     paneId: string          // 从哪个pane拆分出来的
   }
   ```

3. **状态同步策略**：
   - **方案A（推荐）**：**基于 MessagePort 的实时同步**
     ```typescript
     // 父窗口 → 子窗口
     parentPort.postMessage({
       type: 'STATE_UPDATE',
       storeName: 'markdown',
       mutation: { /* ... */ }
     })
     
     // 子窗口 → 父窗口
     childPort.postMessage({
       type: 'STATE_MUTATION',
       storeName: 'paneLayout',
       action: 'moveTab',
       payload: { /* ... */ }
     })
     ```
   
   - **同步的 Store**：
     - `markdownStore`（文件内容、标签页数据）
     - `paneLayoutStore`（面板布局）
     - `rightSidebarStore`（右侧栏状态 - 子窗口操作同步到母窗口）
     - `commandPaletteStore`（命令注册表 - 子窗口使用母窗口的命令）
     - 日志系统（共享）
   
   - **子窗口特殊处理**：
     - 命令面板：子窗口有命令面板，但执行的是母窗口的命令
     - 右侧栏：子窗口无右侧栏UI，但通过命令面板操作母窗口的右侧栏
     - 左侧栏：子窗口完全没有左侧栏（无文件树、无导航）

4. **生命周期管理**：
   ```typescript
   // ProcessManager 扩展
   class ProcessManager {
     // 创建拆分窗口
     async createDetachedPaneWindow(
       parentProcessId: string,
       tabId: string,
       paneId: string
     ): Promise<DetachedPaneWindowProcess> {
       const parentProcess = this.getProcess(parentProcessId)
       
       // 创建子窗口
       const childWindow = new BrowserWindow({
         parent: parentProcess.window,  // 🔥 设置父窗口
         modal: false
       })
       
       // 注册到父窗口的子窗口列表
       parentProcess.childWindows.add(childProcessId)
       
       // 监听父窗口关闭，自动关闭子窗口
       parentProcess.window.on('closed', () => {
         this.destroyProcess(childProcessId)
       })
     }
   }
   ```

---

### **实现步骤**

#### **阶段一：类型定义和基础架构（1-2天）**

1. **扩展类型系统**
   ```typescript
   // src-electron/types/process.ts
   export type WindowType = 'main' | 'project' | 'project-detached-pane'
   
   export interface DetachedPaneWindowProcess extends BaseWindowProcess {
     type: 'project-detached-pane'
     projectPath: string
     parentProcessId: string
     paneId: string
   }
   ```

2. **定义状态同步协议**
   ```typescript
   // src-electron/types/ipc.ts
   export interface StateSync SyncMessage {
     type: 'STATE_SYNC'
     storeName: string
     action: 'update' | 'mutation'
     payload: any
     timestamp: number
   }
   ```

3. **创建专用路由**
   ```typescript
   // Client/GUI/router/routes.ts
   {
     path: '/detached-pane/:paneId',
     component: () => import('pages/ProjectPage.DetachedPanePage.vue')
   }
   ```

#### **阶段二：窗口管理层（2-3天）**

1. **扩展 ProcessManager**
   - 添加 `createDetachedPaneWindow()` 方法
   - 实现父子窗口关联
   - 实现级联关闭逻辑

2. **创建状态同步管理器**
   ```typescript
   // src-electron/services/state-sync/StateSyncManager.ts
   class StateSyncManager {
     // 建立父子窗口的状态同步通道
     establishSyncChannel(parentId: string, childId: string)
     
     // 同步状态更新
     syncState(fromId: string, toId: string, update: StateSyncMessage)
     
     // 处理双向同步冲突
     handleConflict(update1: any, update2: any)
   }
   ```

3. **添加 IPC 处理器**
   ```typescript
   // app-manager.ts
   ipcMain.handle('project:detach-tab-to-window', async (_, { tabId, paneId }) => {
     const process = await processManager.createDetachedPaneWindow(
       currentProjectProcessId,
       tabId,
       paneId
     )
     
     // 从原面板移除标签
     // 在新窗口创建面板并添加标签
     
     return { success: true, processId: process.id }
   })
   ```

#### **阶段三：前端集成（2-3天）**

1. **创建 ProjectPage.DetachedPanePage.vue**
   ```vue
   <template>
     <div class="detached-pane-page">
       <!-- 🔥 精简布局：只有主内容区 + 命令面板 -->
       <!-- 无左栏（文件树、导航） -->
       <!-- 无右栏（插件面板） -->
       
       <PaneContainer :pane-id="detachedPaneId" class="main-content" />
       
       <!-- 🔥 命令面板：操作母窗口的右栏 -->
       <CommandPalette 
         :is-child-window="true"
         :parent-process-id="parentProcessId"
       />
     </div>
   </template>
   
   <script setup>
   import { ref, onMounted } from 'vue'
   import { useRoute } from 'vue-router'
   import PaneContainer from '@components/ProjectPage.MainPanel/PaneSystem/PaneContainer.vue'
   import CommandPalette from '@components/ProjectPage.Shell/CommandPalette/CommandPalette.vue'
   
   const route = useRoute()
   const detachedPaneId = ref(route.params.paneId as string)
   const parentProcessId = ref<string>('')
   
   onMounted(() => {
     // 1. 获取父窗口进程ID
     parentProcessId.value = window.nimbria.getParentProcessId()
     
     // 2. 监听父窗口的状态同步消息
     window.nimbria.onStateSync((message) => {
       // 同步 markdownStore、paneLayoutStore、rightSidebarStore
     })
     
     // 3. 发送本地状态变更到父窗口
     // 当用户在子窗口编辑文件时，同步到父窗口
   })
   </script>
   
   <style scoped lang="scss">
   .detached-pane-page {
     width: 100vw;
     height: 100vh;
     display: flex;
     flex-direction: column;
     overflow: hidden;
   }
   
   .main-content {
     flex: 1;
     overflow: hidden;
   }
   </style>
   ```

2. **实现状态同步插件**
   ```typescript
   // Client/Utils/Plugins/state-sync.plugin.ts
   export const useStateSyncPlugin = () => {
     const messagePort = window.nimbria.getMessagePort()
     
     // 监听状态同步消息
     messagePort.on('STATE_SYNC', (message) => {
       const store = getStore(message.storeName)
       store.$patch(message.payload)
     })
     
     // 拦截本地 mutation，发送到父窗口
     const syncMiddleware = (mutation, state) => {
       if (isDetachedWindow()) {
         messagePort.send({
           type: 'STATE_MUTATION',
           storeName: mutation.type.split('/')[0],
           payload: mutation.payload
         })
       }
     }
   }
   ```

3. **扩展右键菜单**
   ```typescript
   // PaneContent.vue
   const contextMenuItems = [
     // ... 现有选项
     {
       label: '拆分到新窗口',
       icon: 'window',
       action: 'detach-to-window'
     }
   ]
   
   const handleMenuSelect = (action: string) => {
     if (action === 'detach-to-window') {
       await window.nimbria.project.detachTabToWindow({
         tabId: currentContextTabId.value,
         paneId: props.paneId
       })
     }
   }
   ```

#### **阶段四：测试和优化（1-2天）**

1. **功能测试**
   - ✅ 子窗口创建和销毁
   - ✅ 状态同步准确性
   - ✅ 父窗口关闭，子窗口级联关闭
   - ✅ 跨窗口拖拽标签页（bonus）

2. **性能优化**
   - 状态同步防抖
   - 大文件编辑时的增量同步
   - 内存泄漏检测

---

## 🎯 **关键技术难点**

### 1. **状态同步的一致性**
**问题**：两个窗口同时编辑同一个文件
**解决**：
- 使用操作时间戳 + 冲突检测
- 父窗口作为 "真值源"
- 子窗口的修改需要通过父窗口协调

### 2. **性能问题**
**问题**：频繁的状态同步可能影响性能
**解决**：
- 只同步必要的 store（markdown、paneLayout）
- 使用防抖（debounce）批量发送更新
- 增量同步而非全量同步

### 3. **窗口关闭顺序**
**问题**：用户可能先关闭父窗口
**解决**：
```typescript
parentWindow.on('close', (event) => {
  // 阻止默认关闭行为
  event.preventDefault()
  
  // 先关闭所有子窗口
  for (const childId of parentProcess.childWindows) {
    await processManager.destroyProcess(childId)
  }
  
  // 再关闭父窗口
  parentWindow.destroy()
})
```

---

## 🤔 **替代方案：WebView 嵌入**

如果状态同步太复杂，可以考虑使用 `<webview>` 标签：

```vue
<!-- DetachedPaneWindow.vue -->
<webview 
  :src="`file://${parentWindowUrl}#/detached-pane/${paneId}`"
  :partition="projectPartition"
></webview>
```

**优点**：
- 完全共享渲染进程和状态
- 无需手动同步

**缺点**：
- 性能略差
- 安全性降低
- 不符合多进程隔离的设计理念

---

## 📝 **我的建议**

**推荐方案一（子窗口 + MessagePort 状态同步）**，原因：

1. ✅ 符合现有的多进程架构理念
2. ✅ 可控的状态同步，可以选择性同步
3. ✅ 更好的稳定性和隔离性
4. ✅ 可以未来扩展为完全独立的窗口

**实施建议**：
- 先实现基本的窗口创建和父子关系
- 再实现单向状态同步（父 → 子）
- 最后实现双向同步和冲突处理
- 逐步测试，确保稳定性

---

## 📁 **文件架构修改树**

### Electron 主进程层

```
src-electron/
├── types/
│   ├── process.ts [修改内容]
│   │   ├── 内部模块：扩展 WindowType 类型 'main' | 'project' | 'project-detached-pane'
│   │   ├── 内部模块：新增 DetachedPaneWindowProcess 接口
│   │   └── 内部模块：ProjectWindowProcess 添加 childWindows 字段
│   ├── ipc.ts [修改内容]
│   │   ├── 内部模块：新增 StateSyncMessage 接口定义
│   │   ├── 内部模块：新增 'project:detach-tab-to-window' IPC 通道类型
│   │   └── 内部模块：新增 'project:get-parent-process-id' IPC 通道类型
│   └── window.ts [修改内容]
│       └── 内部模块：新增 detached-pane 窗口模板配置
├── services/
│   ├── window-service/
│   │   ├── process-manager.ts [修改内容]
│   │   │   ├── 内部模块：新增 createDetachedPaneWindow() 方法
│   │   │   ├── 内部模块：扩展 destroyProcess() 支持级联关闭子窗口
│   │   │   ├── 内部模块：新增 getChildWindows() 方法
│   │   │   └── 内部模块：修改 setupWindowLifecycle() 处理父子窗口关闭逻辑
│   │   └── [新增目录] state-sync/
│   │       ├── [新增文件] StateSyncManager.ts
│   │       │   ├── 内部模块：实现 establishSyncChannel() 建立同步通道
│   │       │   ├── 内部模块：实现 syncState() 同步状态
│   │       │   ├── 内部模块：实现 handleStateUpdate() 处理状态更新
│   │       │   └── 内部模块：实现 handleConflict() 冲突检测和解决
│   │       └── [新增文件] types.ts
│   │           ├── 内部模块：定义 SyncedStore 类型
│   │           ├── 内部模块：定义 StateUpdateMessage 接口
│   │           └── 内部模块：定义 ConflictResolutionStrategy 策略
├── core/
│   ├── app-manager.ts [修改内容]
│   │   ├── 内部模块：注册 'project:detach-tab-to-window' IPC 处理器
│   │   ├── 内部模块：注册 'project:get-parent-process-id' IPC 处理器
│   │   ├── 内部模块：注册 'project:sync-state' IPC 处理器
│   │   └── 内部模块：集成 StateSyncManager 实例
│   └── [新增文件] detached-pane-preload.ts
│       ├── 内部模块：暴露 getParentProcessId() API
│       ├── 内部模块：暴露 onStateSync() 监听器
│       └── 内部模块：暴露 sendStateUpdate() 发送状态更新
└── [新增目录] templates/
    └── [新增文件] detached-pane.template.ts
        └── 内部模块：定义子窗口的默认配置（尺寸、样式等）
```

### 前端层

```
Client/
├── Types/
│   └── window.d.ts [修改内容]
│       ├── 内部模块：新增 detachTabToWindow() API 接口定义
│       ├── 内部模块：新增 getParentProcessId() API 接口定义
│       ├── 内部模块：新增 onStateSync() API 接口定义
│       └── 内部模块：新增 sendStateUpdate() API 接口定义
├── GUI/
│   ├── router/
│   │   └── routes.ts [修改内容]
│   │       └── 内部模块：新增 /detached-pane/:paneId 路由
│   ├── PagesLayout/
│   │   └── [新增文件] ProjectPage.DetachedPanePage.vue
│   │       ├── 内部模块：渲染 PaneContainer 组件（主内容区）
│   │       ├── 内部模块：渲染 CommandPalette 组件
│   │       ├── 内部模块：初始化状态同步监听
│   │       └── 内部模块：处理子窗口特有的生命周期逻辑
│   └── components/
│       └── ProjectPage.MainPanel/
│           └── PaneSystem/
│               ├── PaneContent.vue [修改内容]
│               │   └── 内部模块：右键菜单添加"拆分到新窗口"选项
│               └── ContextMenu.vue [修改内容]
│                   └── 内部模块：新增 'detach-to-window' 菜单项
├── stores/
│   ├── projectPage/
│   │   ├── Markdown/
│   │   │   └── markdown.store.ts [修改内容]
│   │   │       ├── 内部模块：添加 isChildWindow 标志位
│   │   │       ├── 内部模块：监听状态同步消息自动更新
│   │   │       └── 内部模块：mutation时通知父窗口（如果是子窗口）
│   │   ├── paneLayout/
│   │   │   └── paneLayout.store.ts [修改内容]
│   │   │       ├── 内部模块：添加 syncWithParent() 方法
│   │   │       └── 内部模块：处理子窗口的面板布局同步
│   │   ├── rightSidebar/
│   │   │   └── rightSidebar.store.ts [修改内容]
│   │   │       ├── 内部模块：添加 targetProcessId 字段（子窗口指向父窗口）
│   │   │       └── 内部模块：面板操作转发到目标进程
│   │   └── commandPalette/
│   │       └── commandPalette.store.ts [修改内容]
│   │           ├── 内部模块：添加 isChildWindow 模式
│   │           └── 内部模块：命令执行时考虑目标进程（右栏操作发送到父窗口）
└── Utils/
    └── Plugins/
        └── [新增文件] state-sync.plugin.ts
            ├── 内部模块：实现 useStateSyncPlugin() 插件入口
            ├── 内部模块：实现 setupStateSyncListener() 监听状态同步
            ├── 内部模块：实现 syncMiddleware() Pinia 中间件
            ├── 内部模块：实现 sendStateUpdate() 发送状态到父窗口
            └── 内部模块：实现 isDetachedWindow() 判断当前窗口类型
```

### 配置文件

```
Nimbria/
└── quasar.config.ts [修改内容]
    └── 内部模块：添加 detached-pane-preload 预加载脚本构建配置
```

### 关键修改说明

#### 1. **类型扩展**
- `WindowType` 新增 `'project-detached-pane'` 类型
- 新增 `DetachedPaneWindowProcess` 接口，包含父子关系信息

#### 2. **进程管理**
- ProcessManager 支持创建和管理子窗口
- 实现父窗口关闭时级联关闭所有子窗口
- 建立父子窗口的 MessagePort 通信通道

#### 3. **状态同步**
- 新增独立的 StateSyncManager 服务
- 实现双向状态同步（父 ↔ 子）
- 处理状态冲突和一致性保证

#### 4. **前端集成**
- 新增专门的 DetachedPanePage 布局（无左栏、无右栏）
- 扩展 CommandPalette 支持子窗口模式
- Store 层添加跨窗口通信能力

#### 5. **命令面板特殊处理**
- 子窗口有完整的命令面板功能
- 涉及右侧栏的命令操作会转发到母窗口执行
- 保持命令注册表与母窗口同步

