好的boss，我完全理解了！你要的是**JiuZhang那样简单实用的方案**，而不是之前设计文档里那套复杂的多进程架构。让我基于现有Nimbria架构，给你一个简洁的实现方案。

## 🎯 **简化设计方案 - 参考JiuZhang模式**

### 📊 **核心思路对比**

| 维度 | ❌ 原设计（过度复杂） | ✅ 新方案（简单实用） |
|------|-------------------|-------------------|
| 窗口类型 | 新增`project-detached-pane`类型 | 复用`project`类型，添加`minimal`模式 |
| 状态同步 | MessagePort双向同步 | URL参数 + 简单IPC |
| 数据传递 | StateSyncManager | JSON序列化 + URL |
| 通信机制 | MessageChannel | IPC invoke/send |
| 复杂度 | 🔴 高（新增多个服务） | 🟢 低（复用现有架构） |

---

## 🏗️ **实现架构**

### **1. 后端层（src-electron）**

#### **窗口创建逻辑** - 复用并扩展现有系统

```typescript
// src-electron/core/app-manager.ts（在现有代码中添加）

// 新增IPC处理器
ipcMain.handle('project:detach-tab-to-window', async (event, payload: {
  tabId: string;
  tabData: any;  // 标签页数据（标题、内容路径等）
  projectPath: string;
}) => {
  try {
    const transferId = `transfer-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    
    // 记录源窗口映射（用于握手关闭）
    transferMap.set(transferId, {
      sourceWebContentsId: event.sender.id,
      tabId: payload.tabId
    });
    
    // 创建新窗口（复用现有的createProjectWindow）
    const detachedWindow = await createDetachedWindow({
      projectPath: payload.projectPath,
      transferId,
      tabData: payload.tabData,
      ui: 'minimal'  // 关键：minimal模式
    });
    
    return { success: true, windowId: detachedWindow.id };
  } catch (error) {
    return { error: { code: 'DETACH_FAILED', message: error.message } };
  }
});

// 子窗口就绪握手（与JiuZhang相同）
ipcMain.on('project:detached-ready', (_event, data: { transferId: string }) => {
  const rec = transferMap.get(data.transferId);
  if (rec) {
    const sourceWindow = webContents.fromId(rec.sourceWebContentsId);
    sourceWindow?.send('project:close-source-tab', { 
      transferId: data.transferId, 
      tabId: rec.tabId 
    });
    transferMap.delete(data.transferId);
  }
});

// 创建分离窗口的函数
async function createDetachedWindow(config: {
  projectPath: string;
  transferId: string;
  tabData: any;
  ui: 'minimal';
}) {
  const detachedWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    titleBarStyle: 'hidden',
    webPreferences: {
      contextIsolation: true,
      preload: path.resolve(/* 复用project-preload */)
    }
  });
  
  // 设置窗口标题
  detachedWindow.setTitle(config.tabData.title || '分离窗口');
  
  // 加载URL（关键：通过参数传递状态）
  const params = new URLSearchParams({
    newWindow: 'true',
    ui: config.ui,
    transferId: config.transferId,
    projectPath: config.projectPath,
    tabData: encodeURIComponent(JSON.stringify(config.tabData))
  });
  
  if (process.env.DEV) {
    await detachedWindow.loadURL(
      `${process.env.APP_URL}/#/project-detached?${params}`
    );
  } else {
    await detachedWindow.loadFile('index.html', { 
      hash: `/project-detached?${params}` 
    });
  }
  
  return detachedWindow;
}
```

---

### **2. 预加载层（src-electron/core）**

#### **复用project-preload.ts** - 只需确保API已暴露

```typescript
// src-electron/core/project-preload.ts（确认已有）
contextBridge.exposeInMainWorld('nimbria', {
  // 现有API...
  
  // 确保有这些API（可能已存在）
  project: {
    detachTabToWindow: (data) => ipcRenderer.invoke('project:detach-tab-to-window', data),
    // ...其他API
  },
  
  // 事件监听
  on: (channel: string, callback: Function) => {
    ipcRenderer.on(channel, (_event, ...args) => callback(...args));
  },
  
  send: (channel: string, ...args: any[]) => {
    ipcRenderer.send(channel, ...args);
  }
});
```

---

### **3. 前端层（Client）**

#### **3.1 路由配置**

```typescript
// Client/GUI/router/routes.ts

export default [
  // 现有路由...
  
  {
    path: '/project-detached',
    component: () => import('pages/ProjectPage.DetachedPage.vue'),
    meta: { requiresProject: true }
  }
]
```

#### **3.2 分离窗口页面组件**

```vue
<!-- Client/GUI/PagesLayout/ProjectPage.DetachedPage.vue -->
<template>
  <div class="detached-page">
    <!-- 只渲染MainPanel，无左栏、无右栏 -->
    <MainPanel 
      :is-detached-mode="true"
      :initial-tab="detachedTab"
      class="full-content"
    />
    
    <!-- 命令面板（复用现有组件，但标记为子窗口模式） -->
    <CommandPalette 
      v-if="showCommandPalette"
      :is-child-window="true"
      :parent-context="parentContext"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute } from 'vue-router'
import MainPanel from '@components/ProjectPage.MainPanel/MainPanel.vue'
import CommandPalette from '@components/ProjectPage.Shell/CommandPalette/CommandPalette.vue'

const route = useRoute()
const detachedTab = ref<any>(null)
const showCommandPalette = ref(false)
const parentContext = ref({
  projectPath: '',
  transferId: ''
})

onMounted(() => {
  // 1. 解析URL参数
  const params = route.query
  const isNewWindow = params.newWindow === 'true'
  const uiMode = params.ui || 'full'
  const transferId = params.transferId as string
  const tabDataStr = params.tabData as string
  
  if (!isNewWindow || uiMode !== 'minimal') {
    console.error('Invalid detached window parameters')
    return
  }
  
  // 2. 解析标签页数据
  try {
    const tabData = JSON.parse(decodeURIComponent(tabDataStr))
    detachedTab.value = tabData
    
    // 设置窗口标题
    document.title = tabData.title || '分离窗口'
    
    // 3. 保存父窗口上下文
    parentContext.value = {
      projectPath: params.projectPath as string,
      transferId
    }
    
    // 4. 发送就绪事件（触发握手）
    setTimeout(() => {
      window.nimbria?.send?.('project:detached-ready', { transferId })
      console.log('✅ 分离窗口初始化完成，已发送就绪信号')
    }, 1000)
    
  } catch (error) {
    console.error('❌ 解析标签页数据失败:', error)
  }
  
  // 5. 初始化项目上下文（复用现有逻辑）
  // 这里可以调用现有的项目初始化逻辑
})

// 快捷键：打开命令面板
const handleKeydown = (e: KeyboardEvent) => {
  if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'P') {
    e.preventDefault()
    showCommandPalette.value = !showCommandPalette.value
  }
}

onMounted(() => {
  window.addEventListener('keydown', handleKeydown)
})

onUnmounted(() => {
  window.removeEventListener('keydown', handleKeydown)
})
</script>

<style scoped lang="scss">
.detached-page {
  width: 100vw;
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: var(--bg-primary);
  overflow: hidden;
}

.full-content {
  flex: 1;
  overflow: hidden;
}
</style>
```

#### **3.3 MainPanel组件适配**

```vue
<!-- Client/GUI/components/ProjectPage.MainPanel/MainPanel.vue -->
<script setup lang="ts">
// 新增props
const props = defineProps<{
  isDetachedMode?: boolean  // 是否为分离窗口模式
  initialTab?: any          // 初始标签页数据
}>()

// 在onMounted中处理initialTab
onMounted(() => {
  if (props.isDetachedMode && props.initialTab) {
    // 初始化时只加载这一个标签页
    paneStore.createPaneWithTab(props.initialTab)
  } else {
    // 正常模式：加载所有标签页
    loadAllTabs()
  }
})
</script>
```

#### **3.4 右键菜单扩展**

```vue
<!-- Client/GUI/components/ProjectPage.MainPanel/PaneSystem/ContextMenu.vue -->
<template>
  <div v-if="visible" class="context-menu">
    <!-- 现有菜单项... -->
    
    <div class="menu-divider"></div>
    
    <!-- 新增：窗口操作分组 -->
    <div class="menu-group-label">窗口</div>
    <div class="menu-item" @click="detachToNewWindow">
      <el-icon><CopyDocument /></el-icon>
      <span>拆分到新窗口</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { CopyDocument } from '@element-plus/icons-vue'

// 拆分到新窗口
const detachToNewWindow = async () => {
  if (!currentContextTab.value) return
  
  console.log('[ContextMenu] 拆分到新窗口:', currentContextTab.value)
  
  try {
    const tabData = {
      id: currentContextTab.value.id,
      title: currentContextTab.value.title,
      filePath: currentContextTab.value.filePath,
      // ...其他必要数据
    }
    
    const result = await window.nimbria.project.detachTabToWindow({
      tabId: currentContextTab.value.id,
      tabData: JSON.parse(JSON.stringify(tabData)), // 深拷贝
      projectPath: currentProjectPath.value
    })
    
    if (result.success) {
      console.log('✅ 新窗口创建成功')
      // 不立即关闭标签，等待握手完成
    } else {
      console.error('❌ 创建失败:', result.error)
    }
  } catch (error) {
    console.error('❌ 拆分失败:', error)
  } finally {
    closeContextMenu()
  }
}

// 监听关闭源标签事件
onMounted(() => {
  window.nimbria?.on?.('project:close-source-tab', (data: { tabId: string }) => {
    console.log('📨 收到关闭源标签事件:', data)
    paneStore.closeTab(data.tabId)
  })
})
</script>

<style scoped lang="scss">
.menu-group-label {
  padding: 4px 12px;
  font-size: 12px;
  color: var(--text-tertiary);
  font-weight: 500;
}

.menu-divider {
  height: 1px;
  background: var(--border-color);
  margin: 4px 0;
}
</style>
```

#### **3.5 命令面板子窗口模式**

```vue
<!-- Client/GUI/components/ProjectPage.Shell/CommandPalette/CommandPalette.vue -->
<script setup lang="ts">
const props = defineProps<{
  isChildWindow?: boolean     // 是否为子窗口模式
  parentContext?: {           // 父窗口上下文
    projectPath: string
    transferId: string
  }
}>()

// 命令执行时的特殊处理
const executeCommand = async (command: Command) => {
  if (props.isChildWindow) {
    // 子窗口模式：涉及右栏的操作转发到父窗口
    if (command.id.startsWith('rightSidebar.')) {
      console.log('[子窗口] 转发命令到父窗口:', command.id)
      // 通过IPC通知父窗口执行命令
      await window.nimbria.project.executeCommandInParent?.({
        commandId: command.id,
        projectPath: props.parentContext?.projectPath
      })
      return
    }
  }
  
  // 正常执行命令
  await command.action()
}
</script>
```

---

## 📁 **文件架构修改树**

```
Nimbria/
├── src-electron/
│   └── core/
│       └── app-manager.ts [修改内容]
│           ├── 内部模块：新增 'project:detach-tab-to-window' IPC处理器
│           ├── 内部模块：新增 'project:detached-ready' 握手处理
│           ├── 内部模块：新增 createDetachedWindow() 函数
│           └── 内部模块：添加 transferMap 管理
│
├── Client/
│   ├── GUI/
│   │   ├── router/
│   │   │   └── routes.ts [修改内容]
│   │   │       └── 内部模块：新增 /project-detached 路由
│   │   ├── PagesLayout/
│   │   │   └── [新增文件] ProjectPage.DetachedPage.vue
│   │   │       ├── 内部模块：渲染MainPanel（无左右栏）
│   │   │       ├── 内部模块：渲染CommandPalette（子窗口模式）
│   │   │       ├── 内部模块：解析URL参数初始化
│   │   │       └── 内部模块：发送detached-ready握手
│   │   └── components/
│   │       ├── ProjectPage.MainPanel/
│   │       │   └── MainPanel.vue [修改内容]
│   │       │       ├── 内部模块：新增 isDetachedMode prop
│   │       │       ├── 内部模块：新增 initialTab prop
│   │       │       └── 内部模块：分离模式初始化逻辑
│   │       ├── ProjectPage.MainPanel/PaneSystem/
│   │       │   └── ContextMenu.vue [修改内容]
│   │       │       ├── 内部模块：新增"窗口"菜单分组
│   │       │       ├── 内部模块：新增 detachToNewWindow() 方法
│   │       │       └── 内部模块：监听 close-source-tab 事件
│   │       └── ProjectPage.Shell/CommandPalette/
│   │           └── CommandPalette.vue [修改内容]
│   │               ├── 内部模块：新增 isChildWindow prop
│   │               ├── 内部模块：新增 parentContext prop
│   │               └── 内部模块：子窗口模式命令转发逻辑
│   └── Types/
│       └── window.d.ts [修改内容]
│           └── 内部模块：新增 detachTabToWindow() API定义
```

---

## 🔄 **完整工作流程**

```
用户操作: 右键标签页 → "拆分到新窗口"
    ↓
ContextMenu.vue: detachToNewWindow()
    ├─ 生成transferId
    ├─ 准备tabData（深拷贝）
    └─ 调用 window.nimbria.project.detachTabToWindow()
        ↓
Preload: ipcRenderer.invoke('project:detach-tab-to-window')
        ↓
Electron Main: ipcMain.handle('project:detach-tab-to-window')
        ├─ 保存 transferMap[transferId] = { sourceWebContentsId, tabId }
        └─ createDetachedWindow()
            ├─ 创建新BrowserWindow
            ├─ 设置窗口标题
            └─ 加载URL: /#/project-detached?newWindow=true&ui=minimal&tabData=...
                ↓
新窗口: ProjectPage.DetachedPage.vue onMounted()
        ├─ 解析URL参数
        ├─ 初始化MainPanel（只显示该标签页）
        ├─ 初始化CommandPalette（子窗口模式）
        └─ 发送 'project:detached-ready' 事件
            ↓
Electron Main: ipcMain.on('project:detached-ready')
        ├─ 查找transferMap[transferId]
        ├─ 获取源窗口webContents
        └─ 发送 'project:close-source-tab' 到源窗口
            ↓
源窗口: ContextMenu.vue监听器
        └─ paneStore.closeTab(tabId) ✅
```

---

## ✅ **优势对比**

| 特性 | 原复杂方案 | 新简化方案 |
|------|----------|----------|
| 新增文件数 | 🔴 15+ | 🟢 1个新文件 |
| 修改文件数 | 🔴 20+ | 🟢 4个文件 |
| 新增IPC通道 | 🔴 5+ | 🟢 2个 |
| 状态同步复杂度 | 🔴 MessagePort双向同步 | 🟢 无需同步 |
| 开发时间 | 🔴 7-8天 | 🟢 2-3天 |
| 维护成本 | 🔴 高 | 🟢 低 |
| Bug风险 | 🔴 高 | 🟢 低 |

---

## 📝 **实施步骤**

### **阶段一：后端IPC（0.5天）**
1. 在`app-manager.ts`添加`detach-tab-to-window`和`detached-ready`处理器
2. 实现`createDetachedWindow`函数
3. 测试窗口创建和URL参数传递

### **阶段二：前端核心（1天）**
1. 创建`ProjectPage.DetachedPage.vue`
2. 添加路由配置
3. MainPanel添加`isDetachedMode`支持
4. 测试分离窗口渲染

### **阶段三：交互集成（0.5天）**
1. 右键菜单添加"拆分到新窗口"选项
2. 实现握手关闭源标签逻辑
3. 测试完整流程

### **阶段四：命令面板适配（可选，0.5天）**
1. CommandPalette添加子窗口模式
2. 实现命令转发（如果需要）

---

Boss，这就是参考JiuZhang的**简单实用方案**！核心思路：
- ✅ **复用现有架构**，不引入新的窗口类型
- ✅ **URL参数传递状态**，避免复杂的状态同步
- ✅ **简单IPC握手**，而非MessageChannel
- ✅ **最小改动**，只新增1个页面组件，修改4个文件

