# 📋 Markdown 自动保存系统总体设计

## 一、系统设计目标

### 核心功能
1. **智能防抖保存**：编辑停止 2 秒后自动保存
2. **批量保存**：支持保存所有未保存标签页
3. **保存状态管理**：实时显示保存进度和状态
4. **错误恢复**：保存失败时自动重试，支持本地缓存
5. **性能优化**：避免高频 I/O，支持队列化保存

### 设计原则
- **渐进增强**：基础功能优先，高级特性可选
- **用户可控**：支持开启/关闭自动保存
- **数据安全**：原子性写入 + 备份机制
- **类型安全**：全链路 TypeScript 支持

---

## 二、架构分层设计

```
┌─────────────────────────────────────────────────────┐
│           前端层 (Client/)                          │
│  ┌─────────────────────────────────────────────┐   │
│  │ GUI/components/                             │   │
│  │  └── AutoSaveIndicator.vue (保存状态指示器) │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │ stores/projectPage/Markdown/                │   │
│  │  ├── markdown.store.ts (状态管理)           │   │
│  │  ├── markdown.autosave.ts (自动保存逻辑) ⭐ │   │
│  │  └── types.ts (类型扩展)                    │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │ types/window.d.ts (API 类型定义扩展)        │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
                        ↕ IPC
┌─────────────────────────────────────────────────────┐
│          Preload 层 (src-electron/core/)            │
│  └── project-preload.ts (暴露保存 API)              │
└─────────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────────┐
│          主进程层 (src-electron/)                    │
│  ┌─────────────────────────────────────────────┐   │
│  │ services/markdown-service/ ⭐新增           │   │
│  │  ├── markdown-scanner.ts (文件树扫描)       │   │
│  │  ├── markdown-reader.ts (文件读取)          │   │
│  │  ├── markdown-writer.ts (文件写入) ⭐       │   │
│  │  ├── markdown-backup.ts (备份管理) ⭐       │   │
│  │  ├── markdown-queue.ts (保存队列) ⭐        │   │
│  │  └── types.ts (类型定义)                    │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │ ipc/main-renderer/                          │   │
│  │  ├── channel-definitions.ts (通道定义扩展)  │   │
│  │  └── ipc-handlers.ts (IPC 处理器注册)       │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
```

---

## 三、核心模块设计

### 模块1：前端自动保存控制器

**文件**：`Client/stores/projectPage/Markdown/markdown.autosave.ts`

**职责**：
- 防抖定时器管理
- 自动保存策略控制
- 保存队列协调
- 错误重试逻辑

**核心逻辑**：
```typescript
class AutoSaveController {
  private timers: Map<string, NodeJS.Timeout>
  private saveQueue: Set<string>
  private retryCount: Map<string, number>
  
  // 编辑触发防抖
  scheduleAutoSave(tabId: string, delay: number)
  
  // 执行保存
  executeSave(tabId: string): Promise<SaveResult>
  
  // 批量保存
  saveAll(): Promise<BatchSaveResult>
  
  // 重试逻辑
  retrySave(tabId: string, maxRetries: number)
}
```

---

### 模块2：后端保存队列管理器

**文件**：`src-electron/services/markdown-service/markdown-queue.ts`

**职责**：
- 管理保存请求队列
- 避免同时写入同一文件
- 合并连续的保存请求
- 优先级调度

**核心逻辑**：
```typescript
class MarkdownSaveQueue {
  private queue: Map<string, SaveTask>
  private processing: Set<string>
  
  // 添加保存任务
  enqueue(task: SaveTask): Promise<void>
  
  // 处理队列
  processQueue(): Promise<void>
  
  // 合并重复任务
  mergeTasks(path: string): void
}
```

---

### 模块3：备份管理器

**文件**：`src-electron/services/markdown-service/markdown-backup.ts`

**职责**：
- 保存前自动备份
- 管理备份历史
- 清理过期备份
- 恢复备份文件

**核心逻辑**：
```typescript
class MarkdownBackup {
  // 创建备份
  createBackup(filePath: string, content: string): Promise<string>
  
  // 列出历史版本
  listBackups(filePath: string): Promise<BackupInfo[]>
  
  // 恢复备份
  restoreBackup(backupPath: string): Promise<void>
  
  // 清理旧备份
  cleanupOldBackups(filePath: string, keepCount: number)
}
```

---

## 四、数据流设计

### 保存流程时序图

```
用户编辑 
  → Store.updateContent() 
  → AutoSaveController.scheduleAutoSave()
  → [等待 2 秒防抖]
  → AutoSaveController.executeSave()
  → IPC: markdown:writeFile
  → MarkdownQueue.enqueue()
  → [检查队列]
  → MarkdownBackup.createBackup() (可选)
  → MarkdownWriter.writeFile()
  → [原子性写入]
  → 返回结果
  → 更新前端状态 (isDirty = false)
```

---

## 五、文件架构修改树

```
Nimbria/
├── Client/
│   ├── stores/
│   │   └── projectPage/
│   │       └── Markdown/
│   │           ├── markdown.store.ts [修改内容]
│   │           │   ├── 内部模块：集成 AutoSaveController
│   │           │   ├── 内部模块：新增 autoSaveEnabled 配置状态
│   │           │   ├── 内部模块：新增 saveProgress 进度状态
│   │           │   └── 内部模块：新增 batchSaveAllTabs 方法
│   │           ├── [新增文件] markdown.autosave.ts
│   │           │   ├── 内部模块：AutoSaveController 类定义
│   │           │   ├── 内部模块：scheduleAutoSave 防抖调度逻辑
│   │           │   ├── 内部模块：executeSave 保存执行逻辑
│   │           │   ├── 内部模块：retrySave 错误重试机制
│   │           │   └── 内部模块：saveAll 批量保存逻辑
│   │           ├── types.ts [修改内容]
│   │           │   ├── 内部模块：扩展 MarkdownTab 接口（新增 isSaving, saveError 字段）
│   │           │   ├── 内部模块：新增 AutoSaveConfig 接口定义
│   │           │   ├── 内部模块：新增 SaveProgress 接口定义
│   │           │   └── 内部模块：新增 SaveResult 类型定义
│   │           └── index.ts [修改内容]
│   │               └── 内部模块：导出 markdown.autosave.ts 模块
│   ├── GUI/
│   │   └── components/
│   │       └── ProjectPage.MainPanel/
│   │           ├── [新增目录] AutoSave/
│   │           │   ├── [新增文件] AutoSaveIndicator.vue
│   │           │   │   ├── 内部模块：保存状态实时显示组件
│   │           │   │   ├── 内部模块：保存进度条渲染
│   │           │   │   ├── 内部模块：错误提示 UI
│   │           │   │   └── 内部模块：自动保存开关控件
│   │           │   └── [新增文件] SaveStatusBadge.vue
│   │           │       ├── 内部模块：单个标签页保存状态徽章
│   │           │       └── 内部模块：isDirty / isSaving 状态指示
│   │           └── Markdown/
│   │               ├── MarkdownEditor.vue [修改内容]
│   │               │   ├── 内部模块：集成 AutoSaveController.scheduleAutoSave()
│   │               │   ├── 内部模块：Vditor input 事件触发自动保存
│   │               │   └── 内部模块：显示保存状态提示
│   │               └── MarkdownTab.vue [修改内容]
│   │                   └── 内部模块：显示 AutoSaveIndicator 组件
│   └── types/
│       └── core/
│           └── window.d.ts [修改内容]
│               ├── 内部模块：扩展 window.nimbria.markdown 接口
│               ├── 内部模块：新增 writeFile 方法类型定义
│               ├── 内部模块：新增 batchWriteFiles 方法类型定义
│               └── 内部模块：新增 createBackup 方法类型定义
├── src-electron/
│   ├── services/
│   │   └── [新增目录] markdown-service/
│   │       ├── [新增文件] markdown-scanner.ts
│   │       │   ├── 内部模块：scanMarkdownTree 递归扫描文件树
│   │       │   ├── 内部模块：buildFileTreeNode 构建树节点
│   │       │   ├── 内部模块：filterMarkdownFiles 过滤 .md 文件
│   │       │   └── 内部模块：generateFileId 生成唯一 ID
│   │       ├── [新增文件] markdown-reader.ts
│   │       │   ├── 内部模块：readMarkdownFile 读取单个文件
│   │       │   ├── 内部模块：parseFrontMatter 解析元数据
│   │       │   ├── 内部模块：detectEncoding 检测文件编码
│   │       │   └── 内部模块：batchReadFiles 批量读取
│   │       ├── [新增文件] markdown-writer.ts
│   │       │   ├── 内部模块：writeMarkdownFile 原子性写入
│   │       │   ├── 内部模块：batchWriteFiles 批量写入事务
│   │       │   ├── 内部模块：verifyWrite 写入验证
│   │       │   └── 内部模块：rollbackWrite 写入回滚
│   │       ├── [新增文件] markdown-queue.ts
│   │       │   ├── 内部模块：MarkdownSaveQueue 类定义
│   │       │   ├── 内部模块：enqueue 添加保存任务到队列
│   │       │   ├── 内部模块：processQueue 处理队列逻辑
│   │       │   ├── 内部模块：mergeTasks 合并重复任务
│   │       │   ├── 内部模块：prioritySchedule 优先级调度
│   │       │   └── 内部模块：acquireLock / releaseLock 文件锁管理
│   │       ├── [新增文件] markdown-backup.ts
│   │       │   ├── 内部模块：MarkdownBackup 类定义
│   │       │   ├── 内部模块：createBackup 创建备份副本
│   │       │   ├── 内部模块：listBackups 列出历史版本
│   │       │   ├── 内部模块：restoreBackup 恢复备份
│   │       │   ├── 内部模块：cleanupOldBackups 清理过期备份
│   │       │   └── 内部模块：getBackupPath 计算备份路径
│   │       ├── [新增文件] types.ts
│   │       │   ├── 内部模块：MarkdownFile 接口定义
│   │       │   ├── 内部模块：MarkdownTreeOptions 接口定义
│   │       │   ├── 内部模块：SaveTask 接口定义
│   │       │   ├── 内部模块：SaveResult 接口定义
│   │       │   ├── 内部模块：BackupInfo 接口定义
│   │       │   └── 内部模块：FileOperationResult 接口定义
│   │       └── [新增文件] index.ts
│   │           ├── 内部模块：导出所有 markdown-service 模块
│   │           └── 内部模块：初始化 MarkdownService 单例
│   ├── ipc/
│   │   └── main-renderer/
│   │       ├── channel-definitions.ts [修改内容]
│   │       │   ├── 内部模块：新增 MARKDOWN_SCAN_TREE 通道
│   │       │   ├── 内部模块：新增 MARKDOWN_READ_FILE 通道
│   │       │   ├── 内部模块：新增 MARKDOWN_WRITE_FILE 通道
│   │       │   ├── 内部模块：新增 MARKDOWN_BATCH_WRITE 通道
│   │       │   ├── 内部模块：新增 MARKDOWN_CREATE_BACKUP 通道
│   │       │   └── 内部模块：新增 MARKDOWN_LIST_BACKUPS 通道
│   │       ├── ipc-handlers.ts [修改内容]
│   │       │   ├── 内部模块：注册 markdown:scanTree handler
│   │       │   ├── 内部模块：注册 markdown:readFile handler
│   │       │   ├── 内部模块：注册 markdown:writeFile handler
│   │       │   ├── 内部模块：注册 markdown:batchWrite handler
│   │       │   ├── 内部模块：注册 markdown:createBackup handler
│   │       │   └── 内部模块：集成 MarkdownSaveQueue 到 handler
│   │       └── types.ts [修改内容]
│   │           ├── 内部模块：扩展 IPCRequest 类型（新增 markdown 相关请求）
│   │           └── 内部模块：扩展 IPCResponse 类型（新增 markdown 相关响应）
│   └── core/
│       ├── app-manager.ts [修改内容]
│       │   ├── 内部模块：初始化 MarkdownService 实例
│       │   └── 内部模块：应用退出时清理保存队列
│       └── project-preload.ts [修改内容]
│           ├── 内部模块：暴露 markdown.scanTree API
│           ├── 内部模块：暴露 markdown.readFile API
│           ├── 内部模块：暴露 markdown.writeFile API
│           ├── 内部模块：暴露 markdown.batchWriteFiles API
│           ├── 内部模块：暴露 markdown.createBackup API
│           └── 内部模块：暴露 markdown.listBackups API
└── package.json [修改内容]
    └── 内部模块：新增依赖 chokidar (文件监视)、fast-glob (文件扫描)

配置文件修改:
├── quasar.config.ts [修改内容]
│   └── 内部模块：无修改（路径别名已存在）
└── tsconfig.json [修改内容]
    └── 内部模块：无修改（类型配置已覆盖）
```

---

## 六、关键技术设计

### 1. 防抖策略

```typescript
// markdown.autosave.ts

export class AutoSaveController {
  private timers = new Map<string, NodeJS.Timeout>()
  private readonly DEFAULT_DELAY = 2000 // 2秒
  
  scheduleAutoSave(tabId: string, delay = this.DEFAULT_DELAY) {
    // 清除旧定时器
    if (this.timers.has(tabId)) {
      clearTimeout(this.timers.get(tabId)!)
    }
    
    // 设置新定时器
    const timer = setTimeout(() => {
      this.executeSave(tabId)
      this.timers.delete(tabId)
    }, delay)
    
    this.timers.set(tabId, timer)
  }
}
```

---

### 2. 保存队列管理

```typescript
// markdown-queue.ts

export class MarkdownSaveQueue {
  private queue = new Map<string, SaveTask>()
  private processing = new Set<string>()
  private locks = new Map<string, boolean>()
  
  async enqueue(task: SaveTask): Promise<SaveResult> {
    // 检查是否正在处理同一文件
    if (this.processing.has(task.filePath)) {
      // 合并任务（使用最新内容）
      this.queue.set(task.filePath, task)
      return { success: true, queued: true }
    }
    
    // 立即处理
    this.processing.add(task.filePath)
    
    try {
      const result = await this.processTask(task)
      return result
    } finally {
      this.processing.delete(task.filePath)
      
      // 检查是否有合并的任务
      if (this.queue.has(task.filePath)) {
        const nextTask = this.queue.get(task.filePath)!
        this.queue.delete(task.filePath)
        await this.enqueue(nextTask)
      }
    }
  }
}
```

---

### 3. 原子性写入

```typescript
// markdown-writer.ts

export class MarkdownWriter {
  async writeMarkdownFile(
    filePath: string,
    content: string,
    options?: WriteOptions
  ): Promise<FileOperationResult> {
    const absolutePath = path.resolve(filePath)
    const tempPath = `${absolutePath}.tmp.${Date.now()}`
    const backupPath = options?.createBackup 
      ? `${absolutePath}.bak.${Date.now()}`
      : null
    
    try {
      // 步骤1：备份原文件（可选）
      if (backupPath && await fs.pathExists(absolutePath)) {
        await fs.copy(absolutePath, backupPath)
      }
      
      // 步骤2：写入临时文件
      await fs.writeFile(tempPath, content, 'utf-8')
      
      // 步骤3：验证写入
      const written = await fs.readFile(tempPath, 'utf-8')
      if (written !== content) {
        throw new Error('Write verification failed')
      }
      
      // 步骤4：原子性重命名
      await fs.rename(tempPath, absolutePath)
      
      return { success: true }
      
    } catch (error) {
      // 回滚：删除临时文件
      await fs.remove(tempPath).catch(() => {})
      
      // 恢复备份
      if (backupPath && await fs.pathExists(backupPath)) {
        await fs.copy(backupPath, absolutePath)
        await fs.remove(backupPath)
      }
      
      return { success: false, error: String(error) }
    }
  }
}
```

---

### 4. 备份管理

```typescript
// markdown-backup.ts

export class MarkdownBackup {
  private readonly BACKUP_DIR = '.nimbria-backups'
  private readonly MAX_BACKUPS = 10
  
  async createBackup(filePath: string): Promise<string> {
    const dir = path.dirname(filePath)
    const fileName = path.basename(filePath)
    const backupDir = path.join(dir, this.BACKUP_DIR)
    
    await fs.ensureDir(backupDir)
    
    const timestamp = Date.now()
    const backupFileName = `${fileName}.${timestamp}.bak`
    const backupPath = path.join(backupDir, backupFileName)
    
    await fs.copy(filePath, backupPath)
    
    // 清理旧备份
    await this.cleanupOldBackups(filePath)
    
    return backupPath
  }
  
  async cleanupOldBackups(filePath: string) {
    const backups = await this.listBackups(filePath)
    
    // 按时间倒序排序
    backups.sort((a, b) => b.timestamp - a.timestamp)
    
    // 删除超出数量的备份
    for (const backup of backups.slice(this.MAX_BACKUPS)) {
      await fs.remove(backup.path)
    }
  }
}
```

---

### 5. 错误重试机制

```typescript
// markdown.autosave.ts

export class AutoSaveController {
  private retryCount = new Map<string, number>()
  private readonly MAX_RETRIES = 3
  private readonly RETRY_DELAY = 1000 // 1秒
  
  async executeSave(tabId: string): Promise<SaveResult> {
    const tab = this.getTab(tabId)
    if (!tab || !tab.isDirty) {
      return { success: true, skipped: true }
    }
    
    try {
      const result = await window.nimbria.markdown.writeFile(
        tab.filePath,
        tab.content
      )
      
      if (result.success) {
        // 重置重试计数
        this.retryCount.delete(tabId)
        return { success: true }
      } else {
        throw new Error(result.error)
      }
      
    } catch (error) {
      // 自动重试
      const retries = this.retryCount.get(tabId) || 0
      
      if (retries < this.MAX_RETRIES) {
        this.retryCount.set(tabId, retries + 1)
        
        // 指数退避
        const delay = this.RETRY_DELAY * Math.pow(2, retries)
        
        setTimeout(() => {
          this.executeSave(tabId)
        }, delay)
        
        return { 
          success: false, 
          error: String(error),
          retrying: true,
          retryCount: retries + 1
        }
      } else {
        // 重试耗尽
        this.retryCount.delete(tabId)
        
        return { 
          success: false, 
          error: String(error),
          retryExhausted: true
        }
      }
    }
  }
}
```

---

## 七、配置与用户控制

### 前端配置 Store

```typescript
// markdown.store.ts

export const useMarkdownStore = defineStore('projectPage-markdown', () => {
  // 自动保存配置
  const autoSaveConfig = ref<AutoSaveConfig>({
    enabled: true,           // 是否启用
    delay: 2000,             // 防抖延迟（毫秒）
    createBackup: true,      // 是否创建备份
    maxRetries: 3,           // 最大重试次数
    batchSaveOnClose: true   // 关闭时批量保存
  })
  
  // 保存状态
  const saveProgress = ref<SaveProgress>({
    total: 0,      // 总任务数
    completed: 0,  // 已完成数
    failed: 0,     // 失败数
    inProgress: [] // 进行中的任务
  })
  
  // 切换自动保存
  function toggleAutoSave(enabled: boolean) {
    autoSaveConfig.value.enabled = enabled
    
    // 保存到本地存储
    localStorage.setItem('markdown-autosave-enabled', String(enabled))
  }
  
  return {
    autoSaveConfig,
    saveProgress,
    toggleAutoSave
  }
})
```

---

## 八、UI 组件设计

### 保存状态指示器

```vue
<!-- AutoSaveIndicator.vue -->

<template>
  <div class="autosave-indicator">
    <!-- 自动保存开关 -->
    <q-toggle
      v-model="markdownStore.autoSaveConfig.enabled"
      label="自动保存"
      dense
    />
    
    <!-- 保存状态显示 -->
    <div class="save-status">
      <template v-if="isSaving">
        <q-spinner size="16px" />
        <span>正在保存...</span>
      </template>
      
      <template v-else-if="hasUnsaved">
        <q-icon name="circle" color="orange" size="12px" />
        <span>有未保存修改</span>
      </template>
      
      <template v-else>
        <q-icon name="check_circle" color="positive" size="16px" />
        <span>已保存</span>
      </template>
    </div>
    
    <!-- 批量保存按钮 -->
    <q-btn
      v-if="hasUnsaved"
      icon="save_all"
      label="全部保存"
      size="sm"
      @click="saveAll"
      :loading="isBatchSaving"
    />
  </div>
</template>
```

---

## 九、实现优先级

### P0（必须实现）
1. ✅ 基础文件读写（markdown-reader/writer）
2. ✅ IPC 通道定义与注册
3. ✅ Preload API 暴露
4. ✅ 前端 Store 集成
5. ✅ 防抖自动保存逻辑

### P1（推荐实现）
6. ✅ 保存队列管理（避免并发冲突）
7. ✅ 原子性写入保护
8. ✅ 错误重试机制
9. ✅ 保存状态 UI 指示

### P2（可选实现）
10. ⚠️ 备份历史管理
11. ⚠️ 批量保存优化
12. ⚠️ 保存性能监控

---

## 十、开发时间估算

| 阶段 | 任务 | 预计时间 |
|-----|------|---------|
| 阶段1 | 类型定义 + 通道定义 | 1-2 小时 |
| 阶段2 | 后端服务实现（reader/writer/queue） | 4-5 小时 |
| 阶段3 | IPC 桥接 + Preload 暴露 | 2-3 小时 |
| 阶段4 | 前端 Store 改造 + AutoSaveController | 3-4 小时 |
| 阶段5 | UI 组件开发（指示器、状态显示） | 2-3 小时 |
| 阶段6 | 测试 + 调试 | 2-3 小时 |
| **总计** | | **14-20 小时** |

