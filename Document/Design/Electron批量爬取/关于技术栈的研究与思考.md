啊！那给你**TypeScript/Node.js**的方案：

## 方案1：现成的npm包（直接用）

### **① Mozilla Readability（最推荐）**

```bash
npm install @mozilla/readability jsdom
```

```typescript
import { Readability } from '@mozilla/readability';
import { JSDOM } from 'jsdom';
import axios from 'axios';

async function extractContent(url: string) {
  const { data: html } = await axios.get(url);
  const dom = new JSDOM(html, { url });
  const reader = new Readability(dom.window.document);
  const article = reader.parse();
  
  return {
    title: article?.title || '',
    content: article?.textContent || '',
    excerpt: article?.excerpt || ''
  };
}

// 使用
const result = await extractContent('https://xxx.com/chapter1.html');
console.log(result.title);
console.log(result.content);
```

### **② Cheerio（jQuery语法，超好用）**

```bash
npm install cheerio axios
```

```typescript
import * as cheerio from 'cheerio';
import axios from 'axios';

interface Chapter {
  title: string;
  url: string;
}

class UniversalNovelCrawler {
  async getChapters(bookUrl: string): Promise<Chapter[]> {
    const { data: html } = await axios.get(bookUrl);
    const $ = cheerio.load(html);
    
    // 智能提取：找链接最多的容器
    let maxLinks = 0;
    let bestContainer: cheerio.Cheerio<any> | null = null;
    
    $('div, ul, ol, table').each((_, elem) => {
      const links = $(elem).find('a').length;
      if (links > maxLinks && links > 10) {
        maxLinks = links;
        bestContainer = $(elem);
      }
    });
    
    const chapters: Chapter[] = [];
    
    if (bestContainer) {
      bestContainer.find('a').each((_, link) => {
        const $link = $(link);
        const title = $link.text().trim();
        const href = $link.attr('href');
        
        if (href && this.isChapterLink(title, href)) {
          chapters.push({
            title,
            url: new URL(href, bookUrl).href
          });
        }
      });
    }
    
    return chapters;
  }
  
  async getContent(chapterUrl: string) {
    const { data: html } = await axios.get(chapterUrl);
    const $ = cheerio.load(html);
    
    // 方法1: 用Readability（最准确）
    // 方法2: 找文字最多的div
    let maxText = '';
    let maxLength = 0;
    
    $('div, article, section').each((_, elem) => {
      const $elem = $(elem);
      // 移除脚本、样式
      $elem.find('script, style, nav, header, footer').remove();
      
      const text = $elem.text().trim();
      if (text.length > maxLength) {
        maxLength = text.length;
        maxText = text;
      }
    });
    
    return {
      title: $('h1').first().text().trim(),
      content: maxText
    };
  }
  
  private isChapterLink(title: string, url: string): boolean {
    if (!title || title.length < 2) return false;
    
    const blacklist = ['首页', '书架', '投票', '打赏', '目录', '上一章', '下一章'];
    return !blacklist.some(kw => title.includes(kw) || url.includes(kw));
  }
}

// 使用
const crawler = new UniversalNovelCrawler();
const chapters = await crawler.getChapters('https://www.hjwzw.com/Book/45536');
console.log(`找到 ${chapters.length} 章`);

for (const ch of chapters.slice(0, 3)) {
  const content = await crawler.getContent(ch.url);
  console.log(content);
}
```

### **③ Playwright（浏览器自动化）**

```bash
npm install playwright
```

```typescript
import { chromium } from 'playwright';

async function smartExtract(url: string) {
  const browser = await chromium.launch({ headless: true });
  const page = await browser.newPage();
  
  await page.goto(url, { waitUntil: 'networkidle' });
  
  // 找文字最多的元素
  const content = await page.evaluate(() => {
    let maxText = '';
    let maxLength = 0;
    
    document.querySelectorAll('div, article').forEach(elem => {
      const text = elem.textContent?.trim() || '';
      if (text.length > maxLength) {
        maxLength = text.length;
        maxText = text;
      }
    });
    
    return {
      title: document.querySelector('h1')?.textContent?.trim() || '',
      content: maxText
    };
  });
  
  await browser.close();
  return content;
}
```

## 方案2：完整的TypeScript智能爬虫

```typescript
// novel-crawler.ts

import * as cheerio from 'cheerio';
import { Readability } from '@mozilla/readability';
import { JSDOM } from 'jsdom';
import axios, { AxiosInstance } from 'axios';
import iconv from 'iconv-lite';

interface Chapter {
  title: string;
  url: string;
}

interface Content {
  title: string;
  content: string;
  url: string;
}

interface CrawlerConfig {
  delay?: number;
  encoding?: string;
  userAgent?: string;
}

export class SmartNovelCrawler {
  private axios: AxiosInstance;
  private config: CrawlerConfig;
  
  constructor(config: CrawlerConfig = {}) {
    this.config = {
      delay: 1000,
      encoding: 'utf-8',
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      ...config
    };
    
    this.axios = axios.create({
      headers: { 'User-Agent': this.config.userAgent },
      responseType: 'arraybuffer', // 用于处理编码
      timeout: 10000
    });
  }
  
  /**
   * 智能获取章节列表
   */
  async getChapters(bookUrl: string): Promise<Chapter[]> {
    const html = await this.fetchHtml(bookUrl);
    const $ = cheerio.load(html);
    
    // 策略1: 找链接密度最高的容器
    const chapters = this.extractByLinkDensity($, bookUrl);
    if (chapters.length > 10) {
      return this.deduplicateChapters(chapters);
    }
    
    // 策略2: 通过章节命名模式
    const patternChapters = this.extractByPattern($, bookUrl);
    if (patternChapters.length > 0) {
      return this.deduplicateChapters(patternChapters);
    }
    
    return [];
  }
  
  /**
   * 智能提取正文（多策略）
   */
  async getContent(chapterUrl: string): Promise<Content> {
    const html = await this.fetchHtml(chapterUrl);
    
    // 策略1: Mozilla Readability（最准）
    try {
      const content = this.extract
      
---
**完美！在Electron中这更简单！** 可以利用真实的浏览器环境，完全模拟真人行为。

## 方案1：使用Electron的BrowserWindow（最佳）

```typescript
// src-electron/services/NovelCrawler.ts

import { BrowserWindow } from 'electron';

interface Chapter {
  title: string;
  url: string;
}

interface Content {
  title: string;
  content: string;
}

export class ElectronNovelCrawler {
  private crawlerWindow: BrowserWindow | null = null;
  
  /**
   * 创建一个隐藏的爬虫窗口（或显示出来模拟真人）
   */
  private async ensureCrawlerWindow(showWindow = false): Promise<BrowserWindow> {
    if (this.crawlerWindow && !this.crawlerWindow.isDestroyed()) {
      return this.crawlerWindow;
    }
    
    this.crawlerWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      show: showWindow, // false=后台爬取，true=可见（更像真人）
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        javascript: true,
        // 使用主进程的session，保留Cookie
        session: undefined // 默认使用默认session
      }
    });
    
    return this.crawlerWindow;
  }
  
  /**
   * 智能提取章节列表
   */
  async getChapters(bookUrl: string, showWindow = false): Promise<Chapter[]> {
    const win = await this.ensureCrawlerWindow(showWindow);
    
    await win.loadURL(bookUrl);
    
    // 等待页面加载完成
    await this.sleep(2000); // 模拟真人浏览
    
    // 在页面中执行JS，智能提取章节
    const chapters = await win.webContents.executeJavaScript(`
      (function() {
        // 策略1: 找链接最多的容器
        function findChapterContainer() {
          let maxLinks = 0;
          let bestContainer = null;
          
          const containers = document.querySelectorAll('div, ul, ol, table, section');
          
          containers.forEach(container => {
            const links = container.querySelectorAll('a');
            if (links.length > maxLinks && links.length > 10) {
              maxLinks = links.length;
              bestContainer = container;
            }
          });
          
          return bestContainer;
        }
        
        // 策略2: 通过章节命名模式识别
        function extractByPattern() {
          const allLinks = Array.from(document.querySelectorAll('a'));
          const patterns = [
            /第\\s*[0-9零一二三四五六七八九十百千万]+\\s*[章节回]/,
            /Chapter\\s*\\d+/,
            /^\\d+[\\.、\\s]/,
          ];
          
          return allLinks.filter(link => {
            const text = link.textContent?.trim() || '';
            return patterns.some(p => p.test(text));
          });
        }
        
        // 先尝试容器方式
        let container = findChapterContainer();
        let links = container ? Array.from(container.querySelectorAll('a')) : [];
        
        // 如果失败，用模式匹配
        if (links.length < 5) {
          links = extractByPattern();
        }
        
        // 过滤和提取
        const blacklist = ['首页', '书架', '投票', '打赏', '目录', '上一章', '下一章', '返回'];
        
        return links
          .filter(link => {
            const text = link.textContent?.trim() || '';
            const href = link.href || '';
            
            if (!text || text.length < 2 || text.length > 100) return false;
            
            return !blacklist.some(kw => 
              text.includes(kw) || href.includes(kw)
            );
          })
          .map(link => ({
            title: link.textContent?.trim() || '',
            url: link.href
          }));
      })();
    `);
    
    return chapters;
  }
  
  /**
   * 智能提取正文内容
   */
  async getContent(chapterUrl: string, showWindow = false): Promise<Content> {
    const win = await this.ensureCrawlerWindow(showWindow);
    
    await win.loadURL(chapterUrl);
    
    // 模拟真人阅读时间
    await this.sleep(1500);
    
    // 在页面中执行智能提取
    const content = await win.webContents.executeJavaScript(`
      (function() {
        // 移除干扰元素
        const removeSelectors = ['script', 'style', 'nav', 'header', 'footer', 'aside', 'iframe'];
        removeSelectors.forEach(sel => {
          document.querySelectorAll(sel).forEach(el => el.remove());
        });
        
        // 提取标题
        const titleElem = document.querySelector('h1') || 
                         document.querySelector('h2') ||
                         document.querySelector('.title');
        const title = titleElem?.textContent?.trim() || '未知标题';
        
        // 策略1: 找文字最多的容器
        function findMainContent() {
          let maxLength = 0;
          let bestElement = null;
          
          const candidates = document.querySelectorAll('div, article, section');
          
          candidates.forEach(elem => {
            const text = elem.textContent?.trim() || '';
            
            // 计算文本密度
            const tagCount = elem.querySelectorAll('*').length || 1;
            const density = text.length / tagCount;
            
            // 综合评分
            const score = text.length * 0.7 + density * 0.3;
            
            if (text.length > 500 && score > maxLength) {
              maxLength = score;
              bestElement = elem;
            }
          });
          
          return bestElement;
        }
        
        const mainElem = findMainContent();
        
        if (!mainElem) {
          return { title, content: '' };
        }
        
        // 提取段落
        const paragraphs = Array.from(mainElem.querySelectorAll('p'))
          .map(p => p.textContent?.trim())
          .filter(text => text && text.length > 0);
        
        // 如果没有p标签，按br分割
        let content = paragraphs.join('\\n\\n');
        
        if (!content || content.length < 100) {
          content = mainElem.innerHTML
            .replace(/<br\\s*\\/?>/gi, '\\n')
            .replace(/<[^>]+>/g, '')
            .trim();
        }
        
        // 清理广告等
        const adPatterns = [
          /請記住本站域名.*?黃金屋/g,
          /快捷鍵.*$/g,
          /www\\..*?\\.com/g,
        ];
        
        adPatterns.forEach(pattern => {
          content = content.replace(pattern, '');
        });
        
        return {
          title,
          content: content.trim()
        };
      })();
    `);
    
    return content;
  }
  
  /**
   * 爬取整本书
   */
  async crawlBook(
    bookUrl: string, 
    options: {
      maxChapters?: number;
      showWindow?: boolean;
      onProgress?: (current: number, total: number, chapter: string) => void;
    } = {}
  ): Promise<Content[]> {
    const { maxChapters, showWindow = false, onProgress } = options;
    
    console.log('📚 开始爬取:', bookUrl);
    
    // 1. 获取章节列表
    const chapters = await this.getChapters(bookUrl, showWindow);
    console.log(`✅ 找到 ${chapters.length} 章`);
    
    const targetChapters = maxChapters 
      ? chapters.slice(0, maxChapters) 
      : chapters;
    
    // 2. 逐章爬取
    const results: Content[] = [];
    
    for (let i = 0; i < targetChapters.length; i++) {
      const chapter = targetChapters[i];
      
      console.log(`⏬ [${i + 1}/${targetChapters.length}] ${chapter.title}`);
      onProgress?.(i + 1, targetChapters.length, chapter.title);
      
      try {
        const content = await this.getContent(chapter.url, showWindow);
        results.push({ ...content, url: chapter.url });
        
        // 随机延迟，模拟真人（重要！）
        await this.sleep(1000 + Math.random() * 2000);
      } catch (error) {
        console.error(`❌ 爬取失败: ${chapter.title}`, error);
        results.push({
          title: chapter.title,
          content: '',
          url: chapter.url
        });
      }
    }
    
    return results;
  }
  
  /**
   * 模拟真人行为：随机滚动页面
   */
  async simulateHumanBehavior(win: BrowserWindow) {
    await win.webContents.executeJavaScript(`
      (function() {
        // 随机滚动
        const scrollTimes = Math.floor(Math.random() * 3) + 1;
        let scrolled = 0;
        
        const interval = setInterval(() => {
          window.scrollBy(0, 300 + Math.random() * 200);
          scrolled++;
          
          if (scrolled >= scrollTimes) {
            clearInterval(interval);
          }
        }, 500 + Math.random() * 500);
      })();
    `);
  }
  
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  /**
   * 清理资源
   */
  destroy() {
    if (this.crawlerWindow && !this.crawlerWindow.isDestroyed()) {
      this.crawlerWindow.close();
      this.crawlerWindow = null;
    }
  }
}
```

## 方案2：在主进程暴露IPC接口

```typescript
// src-electron/ipc/novel-crawler.ts

import { ipcMain } from 'electron';
import { ElectronNovelCrawler } from '../services/NovelCrawler';

const crawler = new ElectronNovelCrawler();

export function registerNovelCrawlerHandlers() {
  // 获取章节列表
  ipcMain.handle('novel:get-chapters', async (_, bookUrl: string) => {
    return await crawler.getChapters(bookUrl);
  });
  
  // 获取单章内容
  ipcMain.handle('novel:get-content', async (_, chapterUrl: string) => {
    return await crawler.getContent(chapterUrl);
  });
  
  // 爬取整本书
  ipcMain.handle('novel:crawl-book', async (event, bookUrl: string, options: any) => {
    return await crawler.crawlBook(bookUrl, {
      ...options,
      onProgress: (current, total, chapter) => {
        // 发送进度到渲染进程
        event.sender.send('novel:progress', { current, total, chapter });
      }
    });
  });
}
```

## 方案3：在渲染进程使用

```typescript
// Nimbria/Client/Service/NovelCrawlerService.ts

export class NovelCrawlerService {
  /**
   * 获取章节列表
   */
  async getChapters(bookUrl: string) {
    return await window.electronAPI.invoke('novel:get-chapters', bookUrl);
  }
  
  /**
   * 获取单章内容
   */
  async getContent(chapterUrl: string) {
    return await window.electronAPI.invoke('novel:get-content', chapterUrl);
  }
  
  /**
   * 爬取整本书（带进度回调）
   */
  async crawlBook(
    bookUrl: string,
    options: {
      maxChapters?: number;
      onProgress?: (current: number, total: number, chapter: string) => void;
    } = {}
  ) {
    // 监听进度
    if (options.onProgress) {
      window.electronAPI.on('novel:progress', (data: any) => {
        options.onProgress?.(data.current, data.total, data.chapter);
      });
    }
    
    const result = await window.electronAPI.invoke('novel:crawl-book', bookUrl, options);
    
    // 清理监听
    window.electronAPI.removeAllListeners('novel:progress');
    
    return result;
  }
}
```

## 在Vue组件中使用

```vue
<template>
  <div class="novel-crawler">
    <q-input 
      v-model="bookUrl" 
      label="小说目录页URL"
      hint="输入任何小说网站的书籍页"
    />
    
    <q-btn 
      @click="startCrawl" 
      :loading="crawling"
      label="开始爬取"
    />
    
    <q-linear-progress 
      v-if="crawling"
      :value="progress"
      color="primary"
    />
    
    <div class="chapter-list">
      <div v-for="ch in chapters" :key="ch.url">
        {{ ch.title }}
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { NovelCrawlerService } from 'src/Client/Service/NovelCrawlerService';

const crawler = new NovelCrawlerService();

const bookUrl = ref('https://www.hjwzw.com/Book/45536');
const crawling = ref(false);
const progress = ref(0);
const chapters = ref([]);

async function startCrawl() {
  crawling.value = true;
  
  try {
    const results = await crawler.crawlBook(bookUrl.value, {
      maxChapters: 10,
      onProgress: (current, total, chapter) => {
        progress.value = current / total;
        console.log(`进度: ${current}/${total} - ${chapter}`);
      }
    });
    
    chapters.value = results;
    console.log('爬取完成！', results);
  } finally {
    crawling.value = false;
  }
}
</script>
```

## 高级功能：反爬虫对策

```typescript
// 增强版：模拟真人行为

class AdvancedElectronCrawler extends ElectronNovelCrawler {
  /**
   * 模拟真人点击链接（而不是直接loadURL）
   */
  async clickLink(linkSelector: string) {
    await this.crawlerWindow?.webContents.executeJavaScript(`
      document.querySelector('${linkSelector}').click();
    `);
  }
  
  /**
   * 随机鼠标移动
   */
  async randomMouseMove() {
    await this.crawlerWindow?.webContents.executeJavaScript(`
      const event = new MouseEvent('mousemove', {
        clientX: Math.random() * window.innerWidth,
        clientY: Math.random() * window.innerHeight
      });
      document.dispatchEvent(event);
    `);
  }
  
  /**
   * 复用用户的真实浏览窗口的Cookie
   */
  async shareSessionWith(mainWindow: BrowserWindow) {
    const mainSession = mainWindow.webContents.session;
    this.crawlerWindow = new BrowserWindow({
      webPreferences: {
        session: mainSession // 共享Cookie!
      }
    });
  }
}
```

## 核心优势：

1. ✅ **保留真实Cookie** - 使用同一个session
2. ✅ **完全模拟真人** - 可以显示窗口，模拟点击、滚动
3. ✅ **无需配置** - 智能提取算法自动适配
4. ✅ **TypeScript原生** - 无需Python或其他语言
5. ✅ **利用Electron能力** - executeJavaScript直接操作DOM

