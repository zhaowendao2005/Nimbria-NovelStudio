å•Šï¼é‚£ç»™ä½ **TypeScript/Node.js**çš„æ–¹æ¡ˆï¼š

## æ–¹æ¡ˆ1ï¼šç°æˆçš„npmåŒ…ï¼ˆç›´æ¥ç”¨ï¼‰

### **â‘  Mozilla Readabilityï¼ˆæœ€æ¨èï¼‰**

```bash
npm install @mozilla/readability jsdom
```

```typescript
import { Readability } from '@mozilla/readability';
import { JSDOM } from 'jsdom';
import axios from 'axios';

async function extractContent(url: string) {
  const { data: html } = await axios.get(url);
  const dom = new JSDOM(html, { url });
  const reader = new Readability(dom.window.document);
  const article = reader.parse();
  
  return {
    title: article?.title || '',
    content: article?.textContent || '',
    excerpt: article?.excerpt || ''
  };
}

// ä½¿ç”¨
const result = await extractContent('https://xxx.com/chapter1.html');
console.log(result.title);
console.log(result.content);
```

### **â‘¡ Cheerioï¼ˆjQueryè¯­æ³•ï¼Œè¶…å¥½ç”¨ï¼‰**

```bash
npm install cheerio axios
```

```typescript
import * as cheerio from 'cheerio';
import axios from 'axios';

interface Chapter {
  title: string;
  url: string;
}

class UniversalNovelCrawler {
  async getChapters(bookUrl: string): Promise<Chapter[]> {
    const { data: html } = await axios.get(bookUrl);
    const $ = cheerio.load(html);
    
    // æ™ºèƒ½æå–ï¼šæ‰¾é“¾æ¥æœ€å¤šçš„å®¹å™¨
    let maxLinks = 0;
    let bestContainer: cheerio.Cheerio<any> | null = null;
    
    $('div, ul, ol, table').each((_, elem) => {
      const links = $(elem).find('a').length;
      if (links > maxLinks && links > 10) {
        maxLinks = links;
        bestContainer = $(elem);
      }
    });
    
    const chapters: Chapter[] = [];
    
    if (bestContainer) {
      bestContainer.find('a').each((_, link) => {
        const $link = $(link);
        const title = $link.text().trim();
        const href = $link.attr('href');
        
        if (href && this.isChapterLink(title, href)) {
          chapters.push({
            title,
            url: new URL(href, bookUrl).href
          });
        }
      });
    }
    
    return chapters;
  }
  
  async getContent(chapterUrl: string) {
    const { data: html } = await axios.get(chapterUrl);
    const $ = cheerio.load(html);
    
    // æ–¹æ³•1: ç”¨Readabilityï¼ˆæœ€å‡†ç¡®ï¼‰
    // æ–¹æ³•2: æ‰¾æ–‡å­—æœ€å¤šçš„div
    let maxText = '';
    let maxLength = 0;
    
    $('div, article, section').each((_, elem) => {
      const $elem = $(elem);
      // ç§»é™¤è„šæœ¬ã€æ ·å¼
      $elem.find('script, style, nav, header, footer').remove();
      
      const text = $elem.text().trim();
      if (text.length > maxLength) {
        maxLength = text.length;
        maxText = text;
      }
    });
    
    return {
      title: $('h1').first().text().trim(),
      content: maxText
    };
  }
  
  private isChapterLink(title: string, url: string): boolean {
    if (!title || title.length < 2) return false;
    
    const blacklist = ['é¦–é¡µ', 'ä¹¦æ¶', 'æŠ•ç¥¨', 'æ‰“èµ', 'ç›®å½•', 'ä¸Šä¸€ç« ', 'ä¸‹ä¸€ç« '];
    return !blacklist.some(kw => title.includes(kw) || url.includes(kw));
  }
}

// ä½¿ç”¨
const crawler = new UniversalNovelCrawler();
const chapters = await crawler.getChapters('https://www.hjwzw.com/Book/45536');
console.log(`æ‰¾åˆ° ${chapters.length} ç« `);

for (const ch of chapters.slice(0, 3)) {
  const content = await crawler.getContent(ch.url);
  console.log(content);
}
```

### **â‘¢ Playwrightï¼ˆæµè§ˆå™¨è‡ªåŠ¨åŒ–ï¼‰**

```bash
npm install playwright
```

```typescript
import { chromium } from 'playwright';

async function smartExtract(url: string) {
  const browser = await chromium.launch({ headless: true });
  const page = await browser.newPage();
  
  await page.goto(url, { waitUntil: 'networkidle' });
  
  // æ‰¾æ–‡å­—æœ€å¤šçš„å…ƒç´ 
  const content = await page.evaluate(() => {
    let maxText = '';
    let maxLength = 0;
    
    document.querySelectorAll('div, article').forEach(elem => {
      const text = elem.textContent?.trim() || '';
      if (text.length > maxLength) {
        maxLength = text.length;
        maxText = text;
      }
    });
    
    return {
      title: document.querySelector('h1')?.textContent?.trim() || '',
      content: maxText
    };
  });
  
  await browser.close();
  return content;
}
```

## æ–¹æ¡ˆ2ï¼šå®Œæ•´çš„TypeScriptæ™ºèƒ½çˆ¬è™«

```typescript
// novel-crawler.ts

import * as cheerio from 'cheerio';
import { Readability } from '@mozilla/readability';
import { JSDOM } from 'jsdom';
import axios, { AxiosInstance } from 'axios';
import iconv from 'iconv-lite';

interface Chapter {
  title: string;
  url: string;
}

interface Content {
  title: string;
  content: string;
  url: string;
}

interface CrawlerConfig {
  delay?: number;
  encoding?: string;
  userAgent?: string;
}

export class SmartNovelCrawler {
  private axios: AxiosInstance;
  private config: CrawlerConfig;
  
  constructor(config: CrawlerConfig = {}) {
    this.config = {
      delay: 1000,
      encoding: 'utf-8',
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      ...config
    };
    
    this.axios = axios.create({
      headers: { 'User-Agent': this.config.userAgent },
      responseType: 'arraybuffer', // ç”¨äºå¤„ç†ç¼–ç 
      timeout: 10000
    });
  }
  
  /**
   * æ™ºèƒ½è·å–ç« èŠ‚åˆ—è¡¨
   */
  async getChapters(bookUrl: string): Promise<Chapter[]> {
    const html = await this.fetchHtml(bookUrl);
    const $ = cheerio.load(html);
    
    // ç­–ç•¥1: æ‰¾é“¾æ¥å¯†åº¦æœ€é«˜çš„å®¹å™¨
    const chapters = this.extractByLinkDensity($, bookUrl);
    if (chapters.length > 10) {
      return this.deduplicateChapters(chapters);
    }
    
    // ç­–ç•¥2: é€šè¿‡ç« èŠ‚å‘½åæ¨¡å¼
    const patternChapters = this.extractByPattern($, bookUrl);
    if (patternChapters.length > 0) {
      return this.deduplicateChapters(patternChapters);
    }
    
    return [];
  }
  
  /**
   * æ™ºèƒ½æå–æ­£æ–‡ï¼ˆå¤šç­–ç•¥ï¼‰
   */
  async getContent(chapterUrl: string): Promise<Content> {
    const html = await this.fetchHtml(chapterUrl);
    
    // ç­–ç•¥1: Mozilla Readabilityï¼ˆæœ€å‡†ï¼‰
    try {
      const content = this.extract
      
---
**å®Œç¾ï¼åœ¨Electronä¸­è¿™æ›´ç®€å•ï¼** å¯ä»¥åˆ©ç”¨çœŸå®çš„æµè§ˆå™¨ç¯å¢ƒï¼Œå®Œå…¨æ¨¡æ‹ŸçœŸäººè¡Œä¸ºã€‚

## æ–¹æ¡ˆ1ï¼šä½¿ç”¨Electronçš„BrowserWindowï¼ˆæœ€ä½³ï¼‰

```typescript
// src-electron/services/NovelCrawler.ts

import { BrowserWindow } from 'electron';

interface Chapter {
  title: string;
  url: string;
}

interface Content {
  title: string;
  content: string;
}

export class ElectronNovelCrawler {
  private crawlerWindow: BrowserWindow | null = null;
  
  /**
   * åˆ›å»ºä¸€ä¸ªéšè—çš„çˆ¬è™«çª—å£ï¼ˆæˆ–æ˜¾ç¤ºå‡ºæ¥æ¨¡æ‹ŸçœŸäººï¼‰
   */
  private async ensureCrawlerWindow(showWindow = false): Promise<BrowserWindow> {
    if (this.crawlerWindow && !this.crawlerWindow.isDestroyed()) {
      return this.crawlerWindow;
    }
    
    this.crawlerWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      show: showWindow, // false=åå°çˆ¬å–ï¼Œtrue=å¯è§ï¼ˆæ›´åƒçœŸäººï¼‰
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        javascript: true,
        // ä½¿ç”¨ä¸»è¿›ç¨‹çš„sessionï¼Œä¿ç•™Cookie
        session: undefined // é»˜è®¤ä½¿ç”¨é»˜è®¤session
      }
    });
    
    return this.crawlerWindow;
  }
  
  /**
   * æ™ºèƒ½æå–ç« èŠ‚åˆ—è¡¨
   */
  async getChapters(bookUrl: string, showWindow = false): Promise<Chapter[]> {
    const win = await this.ensureCrawlerWindow(showWindow);
    
    await win.loadURL(bookUrl);
    
    // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
    await this.sleep(2000); // æ¨¡æ‹ŸçœŸäººæµè§ˆ
    
    // åœ¨é¡µé¢ä¸­æ‰§è¡ŒJSï¼Œæ™ºèƒ½æå–ç« èŠ‚
    const chapters = await win.webContents.executeJavaScript(`
      (function() {
        // ç­–ç•¥1: æ‰¾é“¾æ¥æœ€å¤šçš„å®¹å™¨
        function findChapterContainer() {
          let maxLinks = 0;
          let bestContainer = null;
          
          const containers = document.querySelectorAll('div, ul, ol, table, section');
          
          containers.forEach(container => {
            const links = container.querySelectorAll('a');
            if (links.length > maxLinks && links.length > 10) {
              maxLinks = links.length;
              bestContainer = container;
            }
          });
          
          return bestContainer;
        }
        
        // ç­–ç•¥2: é€šè¿‡ç« èŠ‚å‘½åæ¨¡å¼è¯†åˆ«
        function extractByPattern() {
          const allLinks = Array.from(document.querySelectorAll('a'));
          const patterns = [
            /ç¬¬\\s*[0-9é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒä¸‡]+\\s*[ç« èŠ‚å›]/,
            /Chapter\\s*\\d+/,
            /^\\d+[\\.ã€\\s]/,
          ];
          
          return allLinks.filter(link => {
            const text = link.textContent?.trim() || '';
            return patterns.some(p => p.test(text));
          });
        }
        
        // å…ˆå°è¯•å®¹å™¨æ–¹å¼
        let container = findChapterContainer();
        let links = container ? Array.from(container.querySelectorAll('a')) : [];
        
        // å¦‚æœå¤±è´¥ï¼Œç”¨æ¨¡å¼åŒ¹é…
        if (links.length < 5) {
          links = extractByPattern();
        }
        
        // è¿‡æ»¤å’Œæå–
        const blacklist = ['é¦–é¡µ', 'ä¹¦æ¶', 'æŠ•ç¥¨', 'æ‰“èµ', 'ç›®å½•', 'ä¸Šä¸€ç« ', 'ä¸‹ä¸€ç« ', 'è¿”å›'];
        
        return links
          .filter(link => {
            const text = link.textContent?.trim() || '';
            const href = link.href || '';
            
            if (!text || text.length < 2 || text.length > 100) return false;
            
            return !blacklist.some(kw => 
              text.includes(kw) || href.includes(kw)
            );
          })
          .map(link => ({
            title: link.textContent?.trim() || '',
            url: link.href
          }));
      })();
    `);
    
    return chapters;
  }
  
  /**
   * æ™ºèƒ½æå–æ­£æ–‡å†…å®¹
   */
  async getContent(chapterUrl: string, showWindow = false): Promise<Content> {
    const win = await this.ensureCrawlerWindow(showWindow);
    
    await win.loadURL(chapterUrl);
    
    // æ¨¡æ‹ŸçœŸäººé˜…è¯»æ—¶é—´
    await this.sleep(1500);
    
    // åœ¨é¡µé¢ä¸­æ‰§è¡Œæ™ºèƒ½æå–
    const content = await win.webContents.executeJavaScript(`
      (function() {
        // ç§»é™¤å¹²æ‰°å…ƒç´ 
        const removeSelectors = ['script', 'style', 'nav', 'header', 'footer', 'aside', 'iframe'];
        removeSelectors.forEach(sel => {
          document.querySelectorAll(sel).forEach(el => el.remove());
        });
        
        // æå–æ ‡é¢˜
        const titleElem = document.querySelector('h1') || 
                         document.querySelector('h2') ||
                         document.querySelector('.title');
        const title = titleElem?.textContent?.trim() || 'æœªçŸ¥æ ‡é¢˜';
        
        // ç­–ç•¥1: æ‰¾æ–‡å­—æœ€å¤šçš„å®¹å™¨
        function findMainContent() {
          let maxLength = 0;
          let bestElement = null;
          
          const candidates = document.querySelectorAll('div, article, section');
          
          candidates.forEach(elem => {
            const text = elem.textContent?.trim() || '';
            
            // è®¡ç®—æ–‡æœ¬å¯†åº¦
            const tagCount = elem.querySelectorAll('*').length || 1;
            const density = text.length / tagCount;
            
            // ç»¼åˆè¯„åˆ†
            const score = text.length * 0.7 + density * 0.3;
            
            if (text.length > 500 && score > maxLength) {
              maxLength = score;
              bestElement = elem;
            }
          });
          
          return bestElement;
        }
        
        const mainElem = findMainContent();
        
        if (!mainElem) {
          return { title, content: '' };
        }
        
        // æå–æ®µè½
        const paragraphs = Array.from(mainElem.querySelectorAll('p'))
          .map(p => p.textContent?.trim())
          .filter(text => text && text.length > 0);
        
        // å¦‚æœæ²¡æœ‰pæ ‡ç­¾ï¼ŒæŒ‰bråˆ†å‰²
        let content = paragraphs.join('\\n\\n');
        
        if (!content || content.length < 100) {
          content = mainElem.innerHTML
            .replace(/<br\\s*\\/?>/gi, '\\n')
            .replace(/<[^>]+>/g, '')
            .trim();
        }
        
        // æ¸…ç†å¹¿å‘Šç­‰
        const adPatterns = [
          /è«‹è¨˜ä½æœ¬ç«™åŸŸå.*?é»ƒé‡‘å±‹/g,
          /å¿«æ·éµ.*$/g,
          /www\\..*?\\.com/g,
        ];
        
        adPatterns.forEach(pattern => {
          content = content.replace(pattern, '');
        });
        
        return {
          title,
          content: content.trim()
        };
      })();
    `);
    
    return content;
  }
  
  /**
   * çˆ¬å–æ•´æœ¬ä¹¦
   */
  async crawlBook(
    bookUrl: string, 
    options: {
      maxChapters?: number;
      showWindow?: boolean;
      onProgress?: (current: number, total: number, chapter: string) => void;
    } = {}
  ): Promise<Content[]> {
    const { maxChapters, showWindow = false, onProgress } = options;
    
    console.log('ğŸ“š å¼€å§‹çˆ¬å–:', bookUrl);
    
    // 1. è·å–ç« èŠ‚åˆ—è¡¨
    const chapters = await this.getChapters(bookUrl, showWindow);
    console.log(`âœ… æ‰¾åˆ° ${chapters.length} ç« `);
    
    const targetChapters = maxChapters 
      ? chapters.slice(0, maxChapters) 
      : chapters;
    
    // 2. é€ç« çˆ¬å–
    const results: Content[] = [];
    
    for (let i = 0; i < targetChapters.length; i++) {
      const chapter = targetChapters[i];
      
      console.log(`â¬ [${i + 1}/${targetChapters.length}] ${chapter.title}`);
      onProgress?.(i + 1, targetChapters.length, chapter.title);
      
      try {
        const content = await this.getContent(chapter.url, showWindow);
        results.push({ ...content, url: chapter.url });
        
        // éšæœºå»¶è¿Ÿï¼Œæ¨¡æ‹ŸçœŸäººï¼ˆé‡è¦ï¼ï¼‰
        await this.sleep(1000 + Math.random() * 2000);
      } catch (error) {
        console.error(`âŒ çˆ¬å–å¤±è´¥: ${chapter.title}`, error);
        results.push({
          title: chapter.title,
          content: '',
          url: chapter.url
        });
      }
    }
    
    return results;
  }
  
  /**
   * æ¨¡æ‹ŸçœŸäººè¡Œä¸ºï¼šéšæœºæ»šåŠ¨é¡µé¢
   */
  async simulateHumanBehavior(win: BrowserWindow) {
    await win.webContents.executeJavaScript(`
      (function() {
        // éšæœºæ»šåŠ¨
        const scrollTimes = Math.floor(Math.random() * 3) + 1;
        let scrolled = 0;
        
        const interval = setInterval(() => {
          window.scrollBy(0, 300 + Math.random() * 200);
          scrolled++;
          
          if (scrolled >= scrollTimes) {
            clearInterval(interval);
          }
        }, 500 + Math.random() * 500);
      })();
    `);
  }
  
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  /**
   * æ¸…ç†èµ„æº
   */
  destroy() {
    if (this.crawlerWindow && !this.crawlerWindow.isDestroyed()) {
      this.crawlerWindow.close();
      this.crawlerWindow = null;
    }
  }
}
```

## æ–¹æ¡ˆ2ï¼šåœ¨ä¸»è¿›ç¨‹æš´éœ²IPCæ¥å£

```typescript
// src-electron/ipc/novel-crawler.ts

import { ipcMain } from 'electron';
import { ElectronNovelCrawler } from '../services/NovelCrawler';

const crawler = new ElectronNovelCrawler();

export function registerNovelCrawlerHandlers() {
  // è·å–ç« èŠ‚åˆ—è¡¨
  ipcMain.handle('novel:get-chapters', async (_, bookUrl: string) => {
    return await crawler.getChapters(bookUrl);
  });
  
  // è·å–å•ç« å†…å®¹
  ipcMain.handle('novel:get-content', async (_, chapterUrl: string) => {
    return await crawler.getContent(chapterUrl);
  });
  
  // çˆ¬å–æ•´æœ¬ä¹¦
  ipcMain.handle('novel:crawl-book', async (event, bookUrl: string, options: any) => {
    return await crawler.crawlBook(bookUrl, {
      ...options,
      onProgress: (current, total, chapter) => {
        // å‘é€è¿›åº¦åˆ°æ¸²æŸ“è¿›ç¨‹
        event.sender.send('novel:progress', { current, total, chapter });
      }
    });
  });
}
```

## æ–¹æ¡ˆ3ï¼šåœ¨æ¸²æŸ“è¿›ç¨‹ä½¿ç”¨

```typescript
// Nimbria/Client/Service/NovelCrawlerService.ts

export class NovelCrawlerService {
  /**
   * è·å–ç« èŠ‚åˆ—è¡¨
   */
  async getChapters(bookUrl: string) {
    return await window.electronAPI.invoke('novel:get-chapters', bookUrl);
  }
  
  /**
   * è·å–å•ç« å†…å®¹
   */
  async getContent(chapterUrl: string) {
    return await window.electronAPI.invoke('novel:get-content', chapterUrl);
  }
  
  /**
   * çˆ¬å–æ•´æœ¬ä¹¦ï¼ˆå¸¦è¿›åº¦å›è°ƒï¼‰
   */
  async crawlBook(
    bookUrl: string,
    options: {
      maxChapters?: number;
      onProgress?: (current: number, total: number, chapter: string) => void;
    } = {}
  ) {
    // ç›‘å¬è¿›åº¦
    if (options.onProgress) {
      window.electronAPI.on('novel:progress', (data: any) => {
        options.onProgress?.(data.current, data.total, data.chapter);
      });
    }
    
    const result = await window.electronAPI.invoke('novel:crawl-book', bookUrl, options);
    
    // æ¸…ç†ç›‘å¬
    window.electronAPI.removeAllListeners('novel:progress');
    
    return result;
  }
}
```

## åœ¨Vueç»„ä»¶ä¸­ä½¿ç”¨

```vue
<template>
  <div class="novel-crawler">
    <q-input 
      v-model="bookUrl" 
      label="å°è¯´ç›®å½•é¡µURL"
      hint="è¾“å…¥ä»»ä½•å°è¯´ç½‘ç«™çš„ä¹¦ç±é¡µ"
    />
    
    <q-btn 
      @click="startCrawl" 
      :loading="crawling"
      label="å¼€å§‹çˆ¬å–"
    />
    
    <q-linear-progress 
      v-if="crawling"
      :value="progress"
      color="primary"
    />
    
    <div class="chapter-list">
      <div v-for="ch in chapters" :key="ch.url">
        {{ ch.title }}
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { NovelCrawlerService } from 'src/Client/Service/NovelCrawlerService';

const crawler = new NovelCrawlerService();

const bookUrl = ref('https://www.hjwzw.com/Book/45536');
const crawling = ref(false);
const progress = ref(0);
const chapters = ref([]);

async function startCrawl() {
  crawling.value = true;
  
  try {
    const results = await crawler.crawlBook(bookUrl.value, {
      maxChapters: 10,
      onProgress: (current, total, chapter) => {
        progress.value = current / total;
        console.log(`è¿›åº¦: ${current}/${total} - ${chapter}`);
      }
    });
    
    chapters.value = results;
    console.log('çˆ¬å–å®Œæˆï¼', results);
  } finally {
    crawling.value = false;
  }
}
</script>
```

## é«˜çº§åŠŸèƒ½ï¼šåçˆ¬è™«å¯¹ç­–

```typescript
// å¢å¼ºç‰ˆï¼šæ¨¡æ‹ŸçœŸäººè¡Œä¸º

class AdvancedElectronCrawler extends ElectronNovelCrawler {
  /**
   * æ¨¡æ‹ŸçœŸäººç‚¹å‡»é“¾æ¥ï¼ˆè€Œä¸æ˜¯ç›´æ¥loadURLï¼‰
   */
  async clickLink(linkSelector: string) {
    await this.crawlerWindow?.webContents.executeJavaScript(`
      document.querySelector('${linkSelector}').click();
    `);
  }
  
  /**
   * éšæœºé¼ æ ‡ç§»åŠ¨
   */
  async randomMouseMove() {
    await this.crawlerWindow?.webContents.executeJavaScript(`
      const event = new MouseEvent('mousemove', {
        clientX: Math.random() * window.innerWidth,
        clientY: Math.random() * window.innerHeight
      });
      document.dispatchEvent(event);
    `);
  }
  
  /**
   * å¤ç”¨ç”¨æˆ·çš„çœŸå®æµè§ˆçª—å£çš„Cookie
   */
  async shareSessionWith(mainWindow: BrowserWindow) {
    const mainSession = mainWindow.webContents.session;
    this.crawlerWindow = new BrowserWindow({
      webPreferences: {
        session: mainSession // å…±äº«Cookie!
      }
    });
  }
}
```

## æ ¸å¿ƒä¼˜åŠ¿ï¼š

1. âœ… **ä¿ç•™çœŸå®Cookie** - ä½¿ç”¨åŒä¸€ä¸ªsession
2. âœ… **å®Œå…¨æ¨¡æ‹ŸçœŸäºº** - å¯ä»¥æ˜¾ç¤ºçª—å£ï¼Œæ¨¡æ‹Ÿç‚¹å‡»ã€æ»šåŠ¨
3. âœ… **æ— éœ€é…ç½®** - æ™ºèƒ½æå–ç®—æ³•è‡ªåŠ¨é€‚é…
4. âœ… **TypeScriptåŸç”Ÿ** - æ— éœ€Pythonæˆ–å…¶ä»–è¯­è¨€
5. âœ… **åˆ©ç”¨Electronèƒ½åŠ›** - executeJavaScriptç›´æ¥æ“ä½œDOM

