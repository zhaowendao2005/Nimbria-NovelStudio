å¥½çš„Bossï¼æˆ‘åŸºäºè€è®¡åˆ’ + æ–¹æ¡ˆ1çš„å…ƒç´ é€‰å–å™¨åŠ¨æ€åŒ–ï¼Œé‡æ–°æ•´ç†ä¸€ä»½é«˜ä¿¡æ¯å¯†åº¦çš„å®Œæ•´è®¡åˆ’ï¼š

---

# ğŸ“‹ è·å–é“¾æ¥èŠ‚ç‚¹ - å®Œæ•´å®æ–½è®¡åˆ’ï¼ˆæ•´åˆé€‰å–å™¨åŠ¨æ€åŒ–ï¼‰

## ğŸ¯ æ ¸å¿ƒæ”¹åŠ¨æ¦‚è§ˆ

```
1. æ‰©å±•å…ƒç´ é€‰å–å™¨ â†’ æ”¯æŒèŠ‚ç‚¹ç±»å‹å‚æ•°ï¼ŒåŠ¨æ€æ˜¾ç¤ºé¢„è§ˆ
2. æ–°å¢ GetLinksNode ç»„ä»¶ â†’ å¤ç”¨ GetTextNode æ ·å¼
3. æ–°å¢ get-links é…ç½®è¡¨å• â†’ åœ¨ NodeConfigContent.vue
4. æ–°å¢ GetLinksExecutor â†’ åç«¯çˆ¬å–é€»è¾‘
5. æ³¨å†ŒèŠ‚ç‚¹åˆ° VueFlow + é»˜è®¤èŠ‚ç‚¹
```

---

## ğŸ“ Part 1: å…ƒç´ é€‰å–å™¨åŠ¨æ€åŒ–ï¼ˆæ ¸å¿ƒæ‰©å±•ï¼‰

### **1.1 ä¿®æ”¹ IPC Handler**

```typescript
// src-electron/ipc/main-renderer/search-scraper-handlers.ts
ipcMain.handle('search-scraper:start-element-picker', async (
  _event,
  { tabId, nodeType = 'get-text' }  // ğŸ”¥ æ–°å¢ nodeType å‚æ•°
) => {
  const browserViewManager = getBrowserViewManager()
  const window = BrowserWindow.getFocusedWindow()
  
  browserViewManager.startElementPicker(tabId, window, nodeType)  // ğŸ”¥ ä¼ é€’
})
```

### **1.2 ä¿®æ”¹ BrowserViewManager**

```typescript
// browser-view-manager.ts

// ä¿®æ”¹æ–¹æ³•ç­¾å
public startElementPicker(
  tabId: string, 
  window: BrowserWindow,
  nodeType: 'get-text' | 'get-links' = 'get-text'  // ğŸ”¥ æ–°å¢å‚æ•°
): void {
  // ... CDP é€šé“æ³¨å…¥ä»£ç ä¸å˜ ...
  
  const pickerScript = this.getElementPickerScript(tabId, window, nodeType)  // ğŸ”¥ ä¼ é€’
  // ...
}

// ä¿®æ”¹è„šæœ¬ç”Ÿæˆæ–¹æ³•
private getElementPickerScript(
  tabId: string, 
  window: BrowserWindow,
  nodeType: string  // ğŸ”¥ æ–°å¢å‚æ•°
): string {
  return `
    (function() {
      const NODE_TYPE = '${nodeType}';  // ğŸ”¥ æ³¨å…¥å¸¸é‡
      
      // ... ç°æœ‰çš„çŠ¶æ€ç®¡ç†ã€DOMå…ƒç´ åˆ›å»ºã€å·¥å…·å‡½æ•° ...
      
      // ğŸ”¥ æ–°å¢ï¼šèŠ‚ç‚¹ä¸“å±é¢„è§ˆæå–
      function getNodeSpecificPreview(element) {
        if (NODE_TYPE === 'get-links') {
          const allLinks = Array.from(element.querySelectorAll('a'))
            .filter(a => a.href && a.textContent?.trim());
          
          return {
            type: 'links',
            data: allLinks.slice(0, 5).map(a => ({
              title: a.textContent.trim().substring(0, 30),
              url: a.href
            })),
            totalCount: allLinks.length
          };
        } 
        else if (NODE_TYPE === 'get-text') {
          const text = element.textContent || '';
          return {
            type: 'text',
            data: text.trim().substring(0, 200),
            totalLength: text.length
          };
        }
        return null;
      }
      
      // ğŸ”¥ ä¿®æ”¹ updateDetailBox - æ·»åŠ é¢„è§ˆåŒºåŸŸ
      function updateDetailBox(element) {
        const summary = getElementSummary(element);
        const path = getHierarchyPath(element);
        const preview = getNodeSpecificPreview(element);  // ğŸ”¥ è°ƒç”¨
        
        cachedSelector = getSelector(element);
        cachedElementInfo = {
          selector: cachedSelector,
          tagName: summary.tagName,
          id: summary.id || undefined,
          classList: summary.classList,
          textContent: summary.textPreview,
          preview: preview,  // ğŸ”¥ ç¼“å­˜é¢„è§ˆ
          timestamp: Date.now()
        };
        
        // åŸºç¡€ä¿¡æ¯HTMLï¼ˆå±‚çº§è·¯å¾„ã€é€‰æ‹©å™¨ç­‰ï¼‰
        let html = \`
          <div style="...">
            <div style="color: #409EFF;">ğŸ“ å±‚çº§è·¯å¾„</div>
            <div>\${path.join(' > ')}</div>
          </div>
          <div style="...">
            <div style="color: #409EFF;">ğŸ¯ CSSé€‰æ‹©å™¨</div>
            <div>\${cachedSelector}</div>
          </div>
          <div>æ ‡ç­¾: <\${summary.tagName}></div>
        \`;
        
        // ğŸ”¥ æ ¹æ®èŠ‚ç‚¹ç±»å‹æ¸²æŸ“é¢„è§ˆåŒº
        if (preview?.type === 'links') {
          html += \`
            <div style="margin: 8px 0; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">
              <div style="color: #409EFF; font-weight: bold;">ğŸ”— é“¾æ¥é¢„è§ˆ</div>
              <div style="color: #909399; font-size: 11px;">
                æ€»è®¡ \${preview.totalCount} ä¸ªé“¾æ¥ï¼Œé¢„è§ˆå‰5ä¸ª
              </div>
              <div style="max-height: 120px; overflow: auto; margin-top: 4px;">
                \${preview.data.map((link, i) => \`
                  <div style="margin: 4px 0; padding: 4px; background: rgba(255,255,255,0.05); border-radius: 3px;">
                    <div style="color: #67C23A; font-size: 11px; font-weight: bold;">
                      \${i + 1}. \${link.title}
                    </div>
                    <div style="color: #909399; font-size: 10px; word-break: break-all;">
                      \${link.url}
                    </div>
                  </div>
                \`).join('')}
              </div>
            </div>
          \`;
        } 
        else if (preview?.type === 'text') {
          html += \`
            <div style="margin: 8px 0; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">
              <div style="color: #409EFF; font-weight: bold;">ğŸ“ æ–‡æœ¬é¢„è§ˆ</div>
              <div style="color: #909399; font-size: 11px;">æ€»è®¡ \${preview.totalLength} å­—ç¬¦</div>
              <div style="color: #ddd; padding: 6px; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 11px; max-height: 100px; overflow: auto; margin-top: 4px;">
                \${preview.data}
              </div>
            </div>
          \`;
        }
        
        // ç¡®è®¤æŒ‰é’®
        html += \`
          <div style="margin-top: 12px;">
            <button id="__nimbria-confirm-btn" style="...">
              âœ… ç¡®è®¤é€‰æ‹©æ­¤å…ƒç´ 
            </button>
          </div>
        \`;
        
        detailBox.innerHTML = html;
        
        // ç»‘å®šæŒ‰é’®äº‹ä»¶
        setTimeout(() => {
          const btn = document.getElementById('__nimbria-confirm-btn');
          if (btn) btn.onclick = (e) => { e.stopPropagation(); confirmSelection(); };
        }, 0);
      }
      
      // ... å…¶ä»–ä»£ç ä¿æŒä¸å˜ ...
    })();
  `;
}
```

### **1.3 ä¿®æ”¹ Preload ç±»å‹**

```typescript
// src-electron/core/project-preload.ts
searchScraper: {
  startElementPicker: (tabId: string, nodeType?: 'get-text' | 'get-links') => 
    ipcRenderer.invoke('search-scraper:start-element-picker', { tabId, nodeType }),
  // ... å…¶ä»–æ–¹æ³•ä¸å˜ ...
}
```

---

## ğŸ“ Part 2: ç±»å‹å®šä¹‰

### **2.1 å‰ç«¯ç±»å‹**

```typescript
// AdvancedMode/types.ts

export interface GetLinksNodeConfig {
  containerSelector?: string
  filterKeywords?: string
}

export interface GetLinksNodeData extends WorkflowNodeData {
  config: GetLinksNodeConfig
}

export interface GetLinksNodeOutput {
  links: Array<{ title: string; url: string }>
  count: number
  sourceUrl: string
}
```

### **2.2 åç«¯ç±»å‹**

```typescript
// workflow-executor/types.ts

export interface GetLinksOutput {
  links: Array<{ title: string; url: string }>
  count: number
  url: string
  engine: ScraperEngine
  duration?: number
}
```

---

## ğŸ“ Part 3: å‰ç«¯ç»„ä»¶

### **3.1 èŠ‚ç‚¹ç»„ä»¶ GetLinksNode.vue**

```vue
<!-- AdvancedMode/Nodes/GetLinksNode.vue -->
<template>
  <div class="custom-node get-links-node">
    <div class="node-header node-drag-handle">
      <el-icon><Link /></el-icon>
      <span>è·å–é“¾æ¥</span>
    </div>
    <div class="node-body">
      <div class="node-info">
        <div class="info-row">
          <span class="label">å®¹å™¨:</span>
          <span class="value">{{ data.config?.containerSelector || 'æœªè®¾ç½®' }}</span>
        </div>
        <div v-if="linkCount !== null" class="info-row">
          <span class="label">é“¾æ¥æ•°:</span>
          <el-tag size="small" type="success">{{ linkCount }}</el-tag>
        </div>
      </div>
      <div class="click-hint">åŒå‡»èŠ‚ç‚¹æ‰“å¼€é…ç½®</div>
    </div>
    <Handle type="target" :position="Position.Left" />
    <Handle type="source" :position="Position.Right" />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { Handle, Position } from '@vue-flow/core'
import type { NodeProps } from '@vue-flow/core'
import { Link } from '@element-plus/icons-vue'

const props = defineProps<NodeProps>()
const linkCount = computed(() => props.data.output?.count ?? null)
</script>

<style scoped lang="scss">
// å®Œå…¨å¤ç”¨ GetTextNode æ ·å¼ï¼ˆçœç•¥ï¼‰
</style>
```

### **3.2 é…ç½®è¡¨å•ï¼ˆåœ¨ NodeConfigContent.vue ä¸­æ·»åŠ ï¼‰**

```vue
<!-- åœ¨ <template v-if="props.node?.type === 'get-text'"> åæ·»åŠ  -->

<template v-else-if="props.node?.type === 'get-links'">
  <!-- é…ç½®åŒº -->
  <div class="config-section">
    <div class="section-title">
      <el-icon><Setting /></el-icon>
      <span>èŠ‚ç‚¹é…ç½®</span>
    </div>
    
    <el-form :model="linksFormData" label-width="100px">
      <el-form-item label="å®¹å™¨é€‰æ‹©å™¨">
        <el-input v-model="linksFormData.containerSelector" placeholder="å¦‚: .chapter-list">
          <template #append>
            <el-button @click="handlePickLinksContainer" :type="isLinksPickerActive ? 'primary' : ''">
              <el-icon><Aim /></el-icon>
              {{ isLinksPickerActive ? 'é€‰æ‹©ä¸­' : 'é€‰å–' }}
            </el-button>
          </template>
        </el-input>
      </el-form-item>
      
      <el-form-item label="è¿‡æ»¤å…³é”®è¯">
        <el-input v-model="linksFormData.filterKeywords" type="textarea" :rows="2" 
                  placeholder="é¦–é¡µ, ä¹¦æ¶, æŠ•ç¥¨, æ‰“èµ" />
      </el-form-item>
      
      <el-form-item>
        <el-button type="primary" @click="handleTestExecute" :loading="isExecuting">
          <el-icon><VideoPlay /></el-icon>
          æµ‹è¯•æ‰§è¡Œ
        </el-button>
      </el-form-item>
    </el-form>
  </div>
  
  <!-- æ‰§è¡Œç»“æœåŒºï¼ˆæ˜¾ç¤ºé“¾æ¥è¡¨æ ¼ï¼‰ -->
  <div v-if="hasOutput" class="output-section">
    <!-- å…ƒæ•°æ®å¡ç‰‡ -->
    <el-card shadow="never" class="metadata-card">
      <div class="meta-row">é“¾æ¥æ€»æ•°: <el-tag>{{ filteredLinks.length }}</el-tag></div>
    </el-card>
    
    <!-- ğŸ”¥ é“¾æ¥è¡¨æ ¼ï¼ˆæ”¯æŒåˆ é™¤è¡Œï¼‰ -->
    <el-table :data="filteredLinks" stripe size="small" max-height="400">
      <el-table-column type="index" label="åºå·" width="60" />
      <el-table-column prop="title" label="æ ‡é¢˜" min-width="200" />
      <el-table-column prop="url" label="é“¾æ¥" min-width="300">
        <template #default="{ row }">
          <el-link :href="row.url" target="_blank">{{ row.url }}</el-link>
        </template>
      </el-table-column>
      <!-- ğŸ”¥ æ–°å¢ï¼šæ“ä½œåˆ— -->
      <el-table-column label="æ“ä½œ" width="80" align="center">
        <template #default="{ $index }">
          <el-button
            link
            type="danger"
            size="small"
            @click="handleDeleteLink($index)"
          >
            åˆ é™¤
          </el-button>
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>
```

**Script éƒ¨åˆ†ï¼š**

```typescript
// åœ¨ <script setup> ä¸­æ·»åŠ 

const linksFormData = ref({
  containerSelector: '',
  filterKeywords: 'é¦–é¡µ, ä¹¦æ¶, æŠ•ç¥¨, æ‰“èµ'
})

const isLinksPickerActive = ref(false)

// ğŸ”¥ æ–°å¢ï¼šæœ¬åœ°è¿‡æ»¤åçš„é“¾æ¥æ•°æ®ï¼ˆç”¨äºæ”¯æŒåˆ é™¤åŠŸèƒ½ï¼‰
const filteredLinks = ref<Array<{ title: string; url: string }>>([])

// ç›‘å¬èŠ‚ç‚¹å˜åŒ–
watch(() => props.node, (newNode) => {
  if (newNode?.type === 'get-links') {
    linksFormData.value = {
      containerSelector: newNode.data.config?.containerSelector || '',
      filterKeywords: newNode.data.config?.filterKeywords || 'é¦–é¡µ, ä¹¦æ¶, æŠ•ç¥¨, æ‰“èµ'
    }
  }
}, { immediate: true })

// ğŸ”¥ ç›‘å¬æ‰§è¡Œç»“æœï¼ŒåŒæ­¥åˆ°æœ¬åœ°åˆ—è¡¨
watch(() => outputData.value?.output?.links, (newLinks) => {
  if (newLinks) {
    filteredLinks.value = JSON.parse(JSON.stringify(newLinks))  // æ·±æ‹·è´
  }
}, { deep: true })

// é€‰å–å®¹å™¨
const handlePickLinksContainer = async () => {
  if (isLinksPickerActive.value) {
    await window.nimbria.searchScraper.stopElementPicker(props.tabId)
    isLinksPickerActive.value = false
    return
  }
  
  const handler = (data: ElementSelectedData) => {
    if (data.tabId !== props.tabId) return
    linksFormData.value.containerSelector = data.element.selector
    emit('update-node', { config: linksFormData.value })
    isLinksPickerActive.value = false
  }
  
  window.nimbria.searchScraper.onElementSelected(handler)
  await window.nimbria.searchScraper.startElementPicker(props.tabId, 'get-links')
  isLinksPickerActive.value = true
}

// ğŸ”¥ æ–°å¢ï¼šåˆ é™¤é“¾æ¥è¡Œ
const handleDeleteLink = (index: number) => {
  filteredLinks.value.splice(index, 1)
  ElMessage({
    type: 'success' as const,
    message: 'å·²åˆ é™¤è¯¥é“¾æ¥'
  })
}
```

---

## ğŸ“ Part 4: åç«¯æ‰§è¡Œå™¨

```typescript
// workflow-executor/executors/get-links-executor.ts

import type { BrowserViewManager } from '../../search-scraper-service/browser-view-manager'
import type { NodeExecutor, WorkflowNode, WorkflowExecutionContext, NodeExecutionResult, GetLinksOutput } from '../types'

export class GetLinksExecutor implements NodeExecutor {
  constructor(private browserViewManager: BrowserViewManager) {}

  async execute(node: WorkflowNode, context: WorkflowExecutionContext): Promise<NodeExecutionResult> {
    const startTime = Date.now()
    const { containerSelector = 'body', filterKeywords = 'é¦–é¡µ, ä¹¦æ¶, æŠ•ç¥¨, æ‰“èµ' } = node.data.config || {}

    try {
      // @ts-expect-error - privateå±æ€§è®¿é—®
      const viewInstance = this.browserViewManager.views.get(context.tabId)
      if (!viewInstance) throw new Error(`BrowserView for tab ${context.tabId} not found`)

      const result = await viewInstance.view.webContents.executeJavaScript(`
        (function() {
          const container = document.querySelector('${containerSelector}');
          if (!container) return { links: [], count: 0, sourceUrl: window.location.href };
          
          const blacklist = '${filterKeywords}'.split(',').map(k => k.trim()).filter(k => k);
          const anchors = Array.from(container.querySelectorAll('a'));
          
          const links = anchors
            .filter(a => {
              const text = (a.textContent || '').trim();
              const href = a.href || '';
              return text && href && !blacklist.some(kw => text.includes(kw) || href.includes(kw));
            })
            .map(a => ({
              title: (a.textContent || '').trim(),
              url: a.href
            }));
          
          return { links, count: links.length, sourceUrl: window.location.href };
        })();
      `)

      const duration = Date.now() - startTime
      return {
        nodeId: node.id,
        success: true,
        output: { ...result, engine: 'browserview' as const },
        executedAt: Date.now(),
        engine: 'browserview',
        duration
      }
    } catch (error) {
      return {
        nodeId: node.id,
        success: false,
        error: error instanceof Error ? error.message : String(error),
        executedAt: Date.now(),
        engine: 'browserview',
        duration: Date.now() - startTime
      }
    }
  }
}
```

---

## ğŸ“ Part 5: æ³¨å†Œä¸é›†æˆ

### **5.1 æ³¨å†Œ IPC Handler**

```typescript
// workflow-handlers.ts
import { GetLinksExecutor } from '../../services/workflow-executor/executors/get-links-executor'

// åœ¨ switch ä¸­æ·»åŠ 
case 'get-links': {
  const executor = new GetLinksExecutor(browserViewManager)
  return await executor.execute(request.node, request.context, request.input)
}
```

### **5.2 æ³¨å†Œ VueFlow èŠ‚ç‚¹**

```vue
<!-- WorkflowCanvas.vue -->
<template #node-get-links="props">
  <GetLinksNode v-bind="props" />
        </template>

<script setup>
import GetLinksNode from './Nodes/GetLinksNode.vue'
</script>
```

### **5.3 æ·»åŠ é»˜è®¤èŠ‚ç‚¹**

```typescript
// workflow.store.ts - initializeInstance
nodes: [
  { /* get-text èŠ‚ç‚¹ */ },
  {
    id: nanoid(),
    type: 'get-links',
    position: { x: 400, y: 100 },
    dragHandle: '.node-drag-handle',
    data: {
      label: 'è·å–é“¾æ¥',
      config: { containerSelector: '', filterKeywords: 'é¦–é¡µ, ä¹¦æ¶, æŠ•ç¥¨, æ‰“èµ' }
    }
  }
]
```

---

## âœ… æ ¸å¿ƒäº®ç‚¹

1. **å…ƒç´ é€‰å–å™¨åŠ¨æ€åŒ–** - æ‚¬åœ3ç§’æ˜¾ç¤ºèŠ‚ç‚¹ä¸“å±é¢„è§ˆï¼ˆlinksæ˜¾ç¤ºå‰5ä¸ªé“¾æ¥ï¼Œtextæ˜¾ç¤ºå‰200å­—ï¼‰
2. **é›¶é‡å¤ä»£ç ** - é…ç½®è¡¨å•å¤ç”¨GetTextç»“æ„ï¼Œæ ·å¼å…±äº«
3. **æç®€æ‰§è¡Œå™¨** - 80è¡Œä»£ç ï¼Œçº¯BrowserViewæ–¹æ¡ˆ
4. **æ‰€è§å³æ‰€å¾—** - é€‰å–æ—¶é¢„è§ˆå®é™…çˆ¬å–å†…å®¹

Bossï¼Œä¿¡æ¯å¯†åº¦å¤Ÿé«˜å—ï¼ŸğŸ¯