好的Boss！我基于老计划 + 方案1的元素选取器动态化，重新整理一份高信息密度的完整计划：

---

# 📋 获取链接节点 - 完整实施计划（整合选取器动态化）

## 🎯 核心改动概览

```
1. 扩展元素选取器 → 支持节点类型参数，动态显示预览
2. 新增 GetLinksNode 组件 → 复用 GetTextNode 样式
3. 新增 get-links 配置表单 → 在 NodeConfigContent.vue
4. 新增 GetLinksExecutor → 后端爬取逻辑
5. 注册节点到 VueFlow + 默认节点
```

---

## 📍 Part 1: 元素选取器动态化（核心扩展）

### **1.1 修改 IPC Handler**

```typescript
// src-electron/ipc/main-renderer/search-scraper-handlers.ts
ipcMain.handle('search-scraper:start-element-picker', async (
  _event,
  { tabId, nodeType = 'get-text' }  // 🔥 新增 nodeType 参数
) => {
  const browserViewManager = getBrowserViewManager()
  const window = BrowserWindow.getFocusedWindow()
  
  browserViewManager.startElementPicker(tabId, window, nodeType)  // 🔥 传递
})
```

### **1.2 修改 BrowserViewManager**

```typescript
// browser-view-manager.ts

// 修改方法签名
public startElementPicker(
  tabId: string, 
  window: BrowserWindow,
  nodeType: 'get-text' | 'get-links' = 'get-text'  // 🔥 新增参数
): void {
  // ... CDP 通道注入代码不变 ...
  
  const pickerScript = this.getElementPickerScript(tabId, window, nodeType)  // 🔥 传递
  // ...
}

// 修改脚本生成方法
private getElementPickerScript(
  tabId: string, 
  window: BrowserWindow,
  nodeType: string  // 🔥 新增参数
): string {
  return `
    (function() {
      const NODE_TYPE = '${nodeType}';  // 🔥 注入常量
      
      // ... 现有的状态管理、DOM元素创建、工具函数 ...
      
      // 🔥 新增：节点专属预览提取
      function getNodeSpecificPreview(element) {
        if (NODE_TYPE === 'get-links') {
          const allLinks = Array.from(element.querySelectorAll('a'))
            .filter(a => a.href && a.textContent?.trim());
          
          return {
            type: 'links',
            data: allLinks.slice(0, 5).map(a => ({
              title: a.textContent.trim().substring(0, 30),
              url: a.href
            })),
            totalCount: allLinks.length
          };
        } 
        else if (NODE_TYPE === 'get-text') {
          const text = element.textContent || '';
          return {
            type: 'text',
            data: text.trim().substring(0, 200),
            totalLength: text.length
          };
        }
        return null;
      }
      
      // 🔥 修改 updateDetailBox - 添加预览区域
      function updateDetailBox(element) {
        const summary = getElementSummary(element);
        const path = getHierarchyPath(element);
        const preview = getNodeSpecificPreview(element);  // 🔥 调用
        
        cachedSelector = getSelector(element);
        cachedElementInfo = {
          selector: cachedSelector,
          tagName: summary.tagName,
          id: summary.id || undefined,
          classList: summary.classList,
          textContent: summary.textPreview,
          preview: preview,  // 🔥 缓存预览
          timestamp: Date.now()
        };
        
        // 基础信息HTML（层级路径、选择器等）
        let html = \`
          <div style="...">
            <div style="color: #409EFF;">📍 层级路径</div>
            <div>\${path.join(' > ')}</div>
          </div>
          <div style="...">
            <div style="color: #409EFF;">🎯 CSS选择器</div>
            <div>\${cachedSelector}</div>
          </div>
          <div>标签: <\${summary.tagName}></div>
        \`;
        
        // 🔥 根据节点类型渲染预览区
        if (preview?.type === 'links') {
          html += \`
            <div style="margin: 8px 0; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">
              <div style="color: #409EFF; font-weight: bold;">🔗 链接预览</div>
              <div style="color: #909399; font-size: 11px;">
                总计 \${preview.totalCount} 个链接，预览前5个
              </div>
              <div style="max-height: 120px; overflow: auto; margin-top: 4px;">
                \${preview.data.map((link, i) => \`
                  <div style="margin: 4px 0; padding: 4px; background: rgba(255,255,255,0.05); border-radius: 3px;">
                    <div style="color: #67C23A; font-size: 11px; font-weight: bold;">
                      \${i + 1}. \${link.title}
                    </div>
                    <div style="color: #909399; font-size: 10px; word-break: break-all;">
                      \${link.url}
                    </div>
                  </div>
                \`).join('')}
              </div>
            </div>
          \`;
        } 
        else if (preview?.type === 'text') {
          html += \`
            <div style="margin: 8px 0; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">
              <div style="color: #409EFF; font-weight: bold;">📝 文本预览</div>
              <div style="color: #909399; font-size: 11px;">总计 \${preview.totalLength} 字符</div>
              <div style="color: #ddd; padding: 6px; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 11px; max-height: 100px; overflow: auto; margin-top: 4px;">
                \${preview.data}
              </div>
            </div>
          \`;
        }
        
        // 确认按钮
        html += \`
          <div style="margin-top: 12px;">
            <button id="__nimbria-confirm-btn" style="...">
              ✅ 确认选择此元素
            </button>
          </div>
        \`;
        
        detailBox.innerHTML = html;
        
        // 绑定按钮事件
        setTimeout(() => {
          const btn = document.getElementById('__nimbria-confirm-btn');
          if (btn) btn.onclick = (e) => { e.stopPropagation(); confirmSelection(); };
        }, 0);
      }
      
      // ... 其他代码保持不变 ...
    })();
  `;
}
```

### **1.3 修改 Preload 类型**

```typescript
// src-electron/core/project-preload.ts
searchScraper: {
  startElementPicker: (tabId: string, nodeType?: 'get-text' | 'get-links') => 
    ipcRenderer.invoke('search-scraper:start-element-picker', { tabId, nodeType }),
  // ... 其他方法不变 ...
}
```

---

## 📍 Part 2: 类型定义

### **2.1 前端类型**

```typescript
// AdvancedMode/types.ts

export interface GetLinksNodeConfig {
  containerSelector?: string
  filterKeywords?: string
}

export interface GetLinksNodeData extends WorkflowNodeData {
  config: GetLinksNodeConfig
}

export interface GetLinksNodeOutput {
  links: Array<{ title: string; url: string }>
  count: number
  sourceUrl: string
}
```

### **2.2 后端类型**

```typescript
// workflow-executor/types.ts

export interface GetLinksOutput {
  links: Array<{ title: string; url: string }>
  count: number
  url: string
  engine: ScraperEngine
  duration?: number
}
```

---

## 📍 Part 3: 前端组件

### **3.1 节点组件 GetLinksNode.vue**

```vue
<!-- AdvancedMode/Nodes/GetLinksNode.vue -->
<template>
  <div class="custom-node get-links-node">
    <div class="node-header node-drag-handle">
      <el-icon><Link /></el-icon>
      <span>获取链接</span>
    </div>
    <div class="node-body">
      <div class="node-info">
        <div class="info-row">
          <span class="label">容器:</span>
          <span class="value">{{ data.config?.containerSelector || '未设置' }}</span>
        </div>
        <div v-if="linkCount !== null" class="info-row">
          <span class="label">链接数:</span>
          <el-tag size="small" type="success">{{ linkCount }}</el-tag>
        </div>
      </div>
      <div class="click-hint">双击节点打开配置</div>
    </div>
    <Handle type="target" :position="Position.Left" />
    <Handle type="source" :position="Position.Right" />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { Handle, Position } from '@vue-flow/core'
import type { NodeProps } from '@vue-flow/core'
import { Link } from '@element-plus/icons-vue'

const props = defineProps<NodeProps>()
const linkCount = computed(() => props.data.output?.count ?? null)
</script>

<style scoped lang="scss">
// 完全复用 GetTextNode 样式（省略）
</style>
```

### **3.2 配置表单（在 NodeConfigContent.vue 中添加）**

```vue
<!-- 在 <template v-if="props.node?.type === 'get-text'"> 后添加 -->

<template v-else-if="props.node?.type === 'get-links'">
  <!-- 配置区 -->
  <div class="config-section">
    <div class="section-title">
      <el-icon><Setting /></el-icon>
      <span>节点配置</span>
    </div>
    
    <el-form :model="linksFormData" label-width="100px">
      <el-form-item label="容器选择器">
        <el-input v-model="linksFormData.containerSelector" placeholder="如: .chapter-list">
          <template #append>
            <el-button @click="handlePickLinksContainer" :type="isLinksPickerActive ? 'primary' : ''">
              <el-icon><Aim /></el-icon>
              {{ isLinksPickerActive ? '选择中' : '选取' }}
            </el-button>
          </template>
        </el-input>
      </el-form-item>
      
      <el-form-item label="过滤关键词">
        <el-input v-model="linksFormData.filterKeywords" type="textarea" :rows="2" 
                  placeholder="首页, 书架, 投票, 打赏" />
      </el-form-item>
      
      <el-form-item>
        <el-button type="primary" @click="handleTestExecute" :loading="isExecuting">
          <el-icon><VideoPlay /></el-icon>
          测试执行
        </el-button>
      </el-form-item>
    </el-form>
  </div>
  
  <!-- 执行结果区（显示链接表格） -->
  <div v-if="hasOutput" class="output-section">
    <!-- 元数据卡片 -->
    <el-card shadow="never" class="metadata-card">
      <div class="meta-row">链接总数: <el-tag>{{ filteredLinks.length }}</el-tag></div>
    </el-card>
    
    <!-- 🔥 链接表格（支持删除行） -->
    <el-table :data="filteredLinks" stripe size="small" max-height="400">
      <el-table-column type="index" label="序号" width="60" />
      <el-table-column prop="title" label="标题" min-width="200" />
      <el-table-column prop="url" label="链接" min-width="300">
        <template #default="{ row }">
          <el-link :href="row.url" target="_blank">{{ row.url }}</el-link>
        </template>
      </el-table-column>
      <!-- 🔥 新增：操作列 -->
      <el-table-column label="操作" width="80" align="center">
        <template #default="{ $index }">
          <el-button
            link
            type="danger"
            size="small"
            @click="handleDeleteLink($index)"
          >
            删除
          </el-button>
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>
```

**Script 部分：**

```typescript
// 在 <script setup> 中添加

const linksFormData = ref({
  containerSelector: '',
  filterKeywords: '首页, 书架, 投票, 打赏'
})

const isLinksPickerActive = ref(false)

// 🔥 新增：本地过滤后的链接数据（用于支持删除功能）
const filteredLinks = ref<Array<{ title: string; url: string }>>([])

// 监听节点变化
watch(() => props.node, (newNode) => {
  if (newNode?.type === 'get-links') {
    linksFormData.value = {
      containerSelector: newNode.data.config?.containerSelector || '',
      filterKeywords: newNode.data.config?.filterKeywords || '首页, 书架, 投票, 打赏'
    }
  }
}, { immediate: true })

// 🔥 监听执行结果，同步到本地列表
watch(() => outputData.value?.output?.links, (newLinks) => {
  if (newLinks) {
    filteredLinks.value = JSON.parse(JSON.stringify(newLinks))  // 深拷贝
  }
}, { deep: true })

// 选取容器
const handlePickLinksContainer = async () => {
  if (isLinksPickerActive.value) {
    await window.nimbria.searchScraper.stopElementPicker(props.tabId)
    isLinksPickerActive.value = false
    return
  }
  
  const handler = (data: ElementSelectedData) => {
    if (data.tabId !== props.tabId) return
    linksFormData.value.containerSelector = data.element.selector
    emit('update-node', { config: linksFormData.value })
    isLinksPickerActive.value = false
  }
  
  window.nimbria.searchScraper.onElementSelected(handler)
  await window.nimbria.searchScraper.startElementPicker(props.tabId, 'get-links')
  isLinksPickerActive.value = true
}

// 🔥 新增：删除链接行
const handleDeleteLink = (index: number) => {
  filteredLinks.value.splice(index, 1)
  ElMessage({
    type: 'success' as const,
    message: '已删除该链接'
  })
}
```

---

## 📍 Part 4: 后端执行器

```typescript
// workflow-executor/executors/get-links-executor.ts

import type { BrowserViewManager } from '../../search-scraper-service/browser-view-manager'
import type { NodeExecutor, WorkflowNode, WorkflowExecutionContext, NodeExecutionResult, GetLinksOutput } from '../types'

export class GetLinksExecutor implements NodeExecutor {
  constructor(private browserViewManager: BrowserViewManager) {}

  async execute(node: WorkflowNode, context: WorkflowExecutionContext): Promise<NodeExecutionResult> {
    const startTime = Date.now()
    const { containerSelector = 'body', filterKeywords = '首页, 书架, 投票, 打赏' } = node.data.config || {}

    try {
      // @ts-expect-error - private属性访问
      const viewInstance = this.browserViewManager.views.get(context.tabId)
      if (!viewInstance) throw new Error(`BrowserView for tab ${context.tabId} not found`)

      const result = await viewInstance.view.webContents.executeJavaScript(`
        (function() {
          const container = document.querySelector('${containerSelector}');
          if (!container) return { links: [], count: 0, sourceUrl: window.location.href };
          
          const blacklist = '${filterKeywords}'.split(',').map(k => k.trim()).filter(k => k);
          const anchors = Array.from(container.querySelectorAll('a'));
          
          const links = anchors
            .filter(a => {
              const text = (a.textContent || '').trim();
              const href = a.href || '';
              return text && href && !blacklist.some(kw => text.includes(kw) || href.includes(kw));
            })
            .map(a => ({
              title: (a.textContent || '').trim(),
              url: a.href
            }));
          
          return { links, count: links.length, sourceUrl: window.location.href };
        })();
      `)

      const duration = Date.now() - startTime
      return {
        nodeId: node.id,
        success: true,
        output: { ...result, engine: 'browserview' as const },
        executedAt: Date.now(),
        engine: 'browserview',
        duration
      }
    } catch (error) {
      return {
        nodeId: node.id,
        success: false,
        error: error instanceof Error ? error.message : String(error),
        executedAt: Date.now(),
        engine: 'browserview',
        duration: Date.now() - startTime
      }
    }
  }
}
```

---

## 📍 Part 5: 注册与集成

### **5.1 注册 IPC Handler**

```typescript
// workflow-handlers.ts
import { GetLinksExecutor } from '../../services/workflow-executor/executors/get-links-executor'

// 在 switch 中添加
case 'get-links': {
  const executor = new GetLinksExecutor(browserViewManager)
  return await executor.execute(request.node, request.context, request.input)
}
```

### **5.2 注册 VueFlow 节点**

```vue
<!-- WorkflowCanvas.vue -->
<template #node-get-links="props">
  <GetLinksNode v-bind="props" />
        </template>

<script setup>
import GetLinksNode from './Nodes/GetLinksNode.vue'
</script>
```

### **5.3 添加默认节点**

```typescript
// workflow.store.ts - initializeInstance
nodes: [
  { /* get-text 节点 */ },
  {
    id: nanoid(),
    type: 'get-links',
    position: { x: 400, y: 100 },
    dragHandle: '.node-drag-handle',
    data: {
      label: '获取链接',
      config: { containerSelector: '', filterKeywords: '首页, 书架, 投票, 打赏' }
    }
  }
]
```

---

## ✅ 核心亮点

1. **元素选取器动态化** - 悬停3秒显示节点专属预览（links显示前5个链接，text显示前200字）
2. **零重复代码** - 配置表单复用GetText结构，样式共享
3. **极简执行器** - 80行代码，纯BrowserView方案
4. **所见即所得** - 选取时预览实际爬取内容

Boss，信息密度够高吗？🎯