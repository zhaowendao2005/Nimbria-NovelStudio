# 🚀 轻量模式实现方案

## 📋 目录
1. [架构概览](#架构概览)
2. [前端设计](#前端设计)
3. [后端设计](#后端设计)
4. [IPC 通信设计](#ipc-通信设计)
5. [类型定义](#类型定义)
6. [实现步骤](#实现步骤)
7. [测试计划](#测试计划)

---

## 🏗️ 架构概览

### 两种模式对比

| 特性 | 全浏览器模式 | 轻量模式 |
|------|------------|---------|
| **章节列表获取** | BrowserView（现有） | BrowserView（现有） |
| **内容选择器获取** | 手动或半自动 | 自动从首个章节学习 |
| **章节内容爬取** | 逐个加载 BrowserView | Cheerio 并行请求 |
| **速度** | 慢（串行） | 快（并行） |
| **适用场景** | 动态内容、反爬强 | 静态内容、结构规范 |
| **资源消耗** | 高（浏览器实例） | 低（HTTP 请求） |

### 核心流程图

```
┌─────────────────────────────────────────────────┐
│                  用户触发爬取                    │
└──────────────────┬──────────────────────────────┘
                   │
         ┌─────────▼─────────┐
         │  检查爬取模式      │
         └─────────┬─────────┘
                   │
        ┌──────────┴──────────┐
        │                     │
        ▼                     ▼
┌───────────────┐     ┌──────────────────┐
│ 全浏览器模式   │     │   轻量模式        │
└───────────────┘     └──────────────────┘
        │                     │
        │                     ▼
        │             ┌──────────────────┐
        │             │ 1. 获取章节列表   │
        │             │   (BrowserView)  │
        │             └────────┬─────────┘
        │                      │
        │                      ▼
        │             ┌──────────────────┐
        │             │ 2. 学习选择器     │
        │             │   (加载首章)     │
        │             └────────┬─────────┘
        │                      │
        │                      ▼
        │             ┌──────────────────┐
        │             │ 3. 并行爬取       │
        │             │   (Cheerio)      │
        │             └────────┬─────────┘
        │                      │
        └──────────────────────┴─────────┐
                                         │
                                         ▼
                               ┌──────────────────┐
                               │   爬取完成        │
                               └──────────────────┘
```

---

## 🎨 前端设计

### 1. Store 状态管理

#### 新增状态字段

**文件**: `Nimbria/Client/stores/search-and-scraper/types.ts`

```typescript
/**
 * 爬取模式类型
 */
export type ScrapeMode = 'browser' | 'light'

/**
 * 轻量模式配置
 */
export interface LightModeConfig {
  /** 并行请求数 */
  parallelCount: number
  /** 请求超时时间（秒） */
  requestTimeout: number
  /** 内容选择器（自动学习） */
  contentSelector?: string
  /** 是否已学习选择器 */
  selectorLearned: boolean
}

/**
 * 爬取配置（扩展现有）
 */
export interface ScrapeConfig {
  /** 爬取模式 */
  mode: ScrapeMode
  /** 轻量模式配置 */
  lightMode: LightModeConfig
  // ... 现有字段
}
```

#### Store 方法扩展

**文件**: `Nimbria/Client/stores/search-and-scraper/search-and-scraper-store.ts`

```typescript
export const useSearchAndScraperStore = defineStore('searchAndScraper', () => {
  // ... 现有状态
  
  /**
   * 更新爬取模式
   */
  const updateScrapeMode = (tabId: string, mode: ScrapeMode): void => {
    const instance = instances.value.get(tabId)
    if (!instance) return
    
    instance.scrapeConfig.mode = mode
    console.log(`[Store] Tab ${tabId} 爬取模式更新为: ${mode}`)
  }
  
  /**
   * 更新轻量模式配置
   */
  const updateLightModeConfig = (tabId: string, config: Partial<LightModeConfig>): void => {
    const instance = instances.value.get(tabId)
    if (!instance) return
    
    instance.scrapeConfig.lightMode = {
      ...instance.scrapeConfig.lightMode,
      ...config
    }
  }
  
  /**
   * 设置内容选择器（学习完成）
   */
  const setContentSelector = (tabId: string, selector: string): void => {
    updateLightModeConfig(tabId, {
      contentSelector: selector,
      selectorLearned: true
    })
    console.log(`[Store] Tab ${tabId} 已学习选择器: ${selector}`)
  }
  
  return {
    // ... 现有方法
    updateScrapeMode,
    updateLightModeConfig,
    setContentSelector
  }
})
```

### 2. 前端爬取逻辑修改

**文件**: `Nimbria/Client/GUI/components/.../NovelScraperPanel.vue`

#### 修改 `handleScrapeChapters` 方法

```typescript
const handleScrapeChapters = async (): Promise<void> => {
  if (!instance) return
  
  // 1. 确定要爬取的章节
  let chaptersToScrape = matchedChapters.value
  const listComponent = chapterListRef.value
  if (listComponent?.selectMode) {
    const selectedChapters = listComponent.getSelectedChapters()
    if (selectedChapters.length === 0) {
      ElMessage.warning({ message: '请先选择要爬取的章节' })
      return
    }
    chaptersToScrape = selectedChapters
  }
  
  // 2. 根据模式选择爬取策略
  const scrapeMode = instance.scrapeConfig.mode
  
  if (scrapeMode === 'browser') {
    // 🔵 全浏览器模式（现有逻辑）
    await scrapeBrowserMode(chaptersToScrape)
  } else {
    // 🟡 轻量模式（新增）
    await scrapeLightMode(chaptersToScrape)
  }
}

/**
 * 全浏览器模式爬取（现有逻辑，保持不变）
 */
const scrapeBrowserMode = async (chapters: Chapter[]): Promise<void> => {
  // ... 现有实现
}

/**
 * 轻量模式爬取（新增）
 */
const scrapeLightMode = async (chapters: Chapter[]): Promise<void> => {
  if (!instance) return
  
  try {
    // 1. 检查是否已学习选择器
    if (!instance.scrapeConfig.lightMode.selectorLearned) {
      ElMessage.info({ message: '正在学习内容选择器...' })
      
      // 使用第一个章节学习选择器
      const firstChapter = chapters[0]
      const selector = await SearchAndScraperService.learnContentSelector(
        props.tabId,
        firstChapter.url
      )
      
      if (!selector.success || !selector.selector) {
        ElMessage.error({ message: '选择器学习失败，请尝试全浏览器模式' })
        return
      }
      
      // 保存学习到的选择器
      searchAndScraperStore.setContentSelector(props.tabId, selector.selector)
      ElMessage.success({ message: `已学习选择器: ${selector.selector}` })
    }
    
    // 2. 开始并行爬取
    const result = await SearchAndScraperService.scrapeChaptersLight(
      props.tabId,
      chapters,
      {
        selector: instance.scrapeConfig.lightMode.contentSelector!,
        parallelCount: instance.scrapeConfig.lightMode.parallelCount,
        timeout: instance.scrapeConfig.lightMode.requestTimeout * 1000,
        urlPrefix: urlPrefixEnabled.value ? urlPrefix.value : undefined
      }
    )
    
    if (result.success) {
      ElMessage.success({ 
        message: `爬取完成！成功 ${result.successCount}/${chapters.length} 章` 
      })
    } else {
      ElMessage.error({ message: result.message || '爬取失败' })
    }
    
  } catch (error) {
    console.error('[NovelScraper] Light mode scrape error:', error)
    ElMessage.error({ message: '爬取过程中发生错误' })
  }
}
```

### 3. 设置面板集成

**文件**: `Nimbria/Client/GUI/components/.../SettingsContent.vue`

#### 添加保存到 Store 的逻辑

```typescript
import { useSearchAndScraperStore } from '@stores/search-and-scraper'

// 接收 tabId 作为 prop
interface Props {
  tabId: string
}

const props = defineProps<Props>()
const searchAndScraperStore = useSearchAndScraperStore()

// 从 Store 初始化设置
onMounted(() => {
  const instance = searchAndScraperStore.getInstance(props.tabId)
  if (instance) {
    scrapeMode.value = instance.scrapeConfig.mode
    parallelCount.value = instance.scrapeConfig.lightMode.parallelCount
    requestTimeout.value = instance.scrapeConfig.lightMode.requestTimeout
  }
})

/**
 * 保存设置
 */
const handleSave = (): void => {
  // 保存到 Store
  searchAndScraperStore.updateScrapeMode(props.tabId, scrapeMode.value)
  searchAndScraperStore.updateLightModeConfig(props.tabId, {
    parallelCount: parallelCount.value,
    requestTimeout: requestTimeout.value
  })
  
  ElMessage.success({ message: '设置已保存' })
}
```

---

## 🔧 后端设计

### 1. 新增服务：LightModeScraper

**文件**: `Nimbria/src-electron/services/search-scraper-service/light-mode-scraper.ts`

```typescript
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios'
import * as cheerio from 'cheerio'
import pLimit from 'p-limit'

/**
 * 爬取选项
 */
export interface LightScrapeOptions {
  /** 内容选择器 */
  selector: string
  /** 并行数 */
  parallelCount: number
  /** 请求超时（毫秒） */
  timeout: number
  /** URL 前缀 */
  urlPrefix?: string
  /** 自定义 Headers */
  headers?: Record<string, string>
}

/**
 * 章节数据（简化版）
 */
export interface ChapterData {
  title: string
  url: string
}

/**
 * 爬取结果
 */
export interface ScrapeResult {
  success: boolean
  chapter: ChapterData
  content?: string
  error?: string
}

/**
 * 轻量模式爬虫
 */
export class LightModeScraper {
  private axiosInstance: AxiosInstance
  
  constructor() {
    this.axiosInstance = axios.create({
      timeout: 30000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
      }
    })
  }
  
  /**
   * 并行爬取多个章节
   */
  public async scrapeChapters(
    chapters: ChapterData[],
    options: LightScrapeOptions
  ): Promise<ScrapeResult[]> {
    const limit = pLimit(options.parallelCount)
    
    const tasks = chapters.map(chapter =>
      limit(() => this.scrapeChapter(chapter, options))
    )
    
    return await Promise.all(tasks)
  }
  
  /**
   * 爬取单个章节
   */
  private async scrapeChapter(
    chapter: ChapterData,
    options: LightScrapeOptions
  ): Promise<ScrapeResult> {
    try {
      // 构建完整 URL
      const fullUrl = options.urlPrefix 
        ? `${options.urlPrefix}${chapter.url}` 
        : chapter.url
      
      // 发送 HTTP 请求
      const response = await this.axiosInstance.get(fullUrl, {
        timeout: options.timeout,
        headers: options.headers
      })
      
      // 使用 cheerio 解析 HTML
      const $ = cheerio.load(response.data)
      
      // 提取内容
      const content = $(options.selector).text().trim()
      
      if (!content) {
        return {
          success: false,
          chapter,
          error: '选择器未匹配到内容'
        }
      }
      
      console.log(`[LightScraper] 成功爬取: ${chapter.title}`)
      
      return {
        success: true,
        chapter,
        content
      }
      
    } catch (error) {
      console.error(`[LightScraper] 爬取失败: ${chapter.title}`, error)
      return {
        success: false,
        chapter,
        error: error instanceof Error ? error.message : '未知错误'
      }
    }
  }
  
  /**
   * 学习内容选择器（使用 BrowserView 加载一次）
   */
  public async learnSelector(html: string): Promise<string | null> {
    const $ = cheerio.load(html)
    
    // 策略1: 查找常见的小说内容容器
    const commonSelectors = [
      '#content',
      '.content',
      '#chaptercontent',
      '.chapter-content',
      '.novel-content',
      '.article-content',
      'article',
      '.text-content'
    ]
    
    for (const selector of commonSelectors) {
      const element = $(selector)
      if (element.length > 0 && element.text().trim().length > 100) {
        console.log(`[LightScraper] 学习到选择器: ${selector}`)
        return selector
      }
    }
    
    // 策略2: 查找文本最多的 div
    let maxTextLength = 0
    let bestSelector = null
    
    $('div').each((_, elem) => {
      const text = $(elem).text().trim()
      if (text.length > maxTextLength && text.length > 100) {
        maxTextLength = text.length
        // 尝试生成一个选择器
        const id = $(elem).attr('id')
        const className = $(elem).attr('class')
        
        if (id) {
          bestSelector = `#${id}`
        } else if (className) {
          const firstClass = className.split(' ')[0]
          bestSelector = `.${firstClass}`
        }
      }
    })
    
    return bestSelector
  }
}
```

### 2. 集成到 BrowserViewManager

**文件**: `Nimbria/src-electron/services/search-scraper-service/browser-view-manager.ts`

```typescript
import { LightModeScraper, type LightScrapeOptions, type ChapterData } from './light-mode-scraper'

export class BrowserViewManager {
  // ... 现有代码
  
  private lightScraper: LightModeScraper
  
  constructor(windowManager: WindowManager) {
    // ... 现有初始化
    this.lightScraper = new LightModeScraper()
  }
  
  /**
   * 学习内容选择器
   */
  public async learnContentSelector(tabId: string, url: string): Promise<string | null> {
    const instance = this.instances.get(tabId)
    if (!instance) {
      throw new Error(`Tab ${tabId} not found`)
    }
    
    try {
      // 在 BrowserView 中加载页面
      await instance.view.webContents.loadURL(url)
      await new Promise(resolve => {
        instance.view.webContents.once('dom-ready', resolve)
      })
      
      // 获取页面 HTML
      const html = await instance.view.webContents.executeJavaScript(
        'document.documentElement.outerHTML'
      )
      
      // 使用 cheerio 学习选择器
      return await this.lightScraper.learnSelector(html)
      
    } catch (error) {
      console.error('[BrowserViewManager] Learn selector failed:', error)
      return null
    }
  }
  
  /**
   * 轻量模式爬取章节
   */
  public async scrapeChaptersLight(
    chapters: ChapterData[],
    options: LightScrapeOptions,
    onProgress?: (current: number, total: number, currentChapter: string) => void
  ): Promise<{ success: boolean; results: any[]; successCount: number }> {
    try {
      const results = await this.lightScraper.scrapeChapters(chapters, options)
      
      const successCount = results.filter(r => r.success).length
      
      console.log(`[BrowserViewManager] Light mode scrape completed: ${successCount}/${chapters.length}`)
      
      return {
        success: true,
        results,
        successCount
      }
      
    } catch (error) {
      console.error('[BrowserViewManager] Light scrape failed:', error)
      return {
        success: false,
        results: [],
        successCount: 0
      }
    }
  }
}
```

---

## 📡 IPC 通信设计

### 1. 新增 IPC Channels

**文件**: `Nimbria/src-electron/ipc/main-renderer/search-scraper-handlers.ts`

```typescript
/**
 * 学习内容选择器
 */
ipcMain.handle('search-scraper:learn-selector', async (event, { tabId, url }) => {
  try {
    const selector = await SearchScraperService.learnContentSelector(tabId, url)
    return { success: !!selector, selector }
  } catch (error) {
    console.error('[IPC] Learn selector error:', error)
    return { 
      success: false, 
      error: error instanceof Error ? error.message : '未知错误' 
    }
  }
})

/**
 * 轻量模式爬取章节
 */
ipcMain.handle('search-scraper:scrape-light', async (event, { tabId, chapters, options }) => {
  try {
    const result = await SearchScraperService.scrapeChaptersLight(tabId, chapters, options)
    return result
  } catch (error) {
    console.error('[IPC] Light scrape error:', error)
    return { 
      success: false, 
      message: error instanceof Error ? error.message : '未知错误',
      successCount: 0
    }
  }
})
```

### 2. 前端 Service 方法

**文件**: `Nimbria/Client/Service/SearchAndScraper/search-and-scraper.service.ts`

```typescript
/**
 * 学习内容选择器
 */
static async learnContentSelector(
  tabId: string, 
  url: string
): Promise<{ success: boolean; selector?: string }> {
  return await window.NimbriaAPI.searchScraper.learnSelector(tabId, url)
}

/**
 * 轻量模式爬取章节
 */
static async scrapeChaptersLight(
  tabId: string,
  chapters: Chapter[],
  options: {
    selector: string
    parallelCount: number
    timeout: number
    urlPrefix?: string
  }
): Promise<{ success: boolean; successCount: number; message?: string }> {
  return await window.NimbriaAPI.searchScraper.scrapeLight(tabId, chapters, options)
}
```

### 3. 类型声明

**文件**: `Nimbria/Client/types/core/window.d.ts`

```typescript
interface NimbriaSearchScraperAPI {
  // ... 现有方法
  
  learnSelector(tabId: string, url: string): Promise<{ 
    success: boolean; 
    selector?: string 
  }>;
  
  scrapeLight(
    tabId: string, 
    chapters: any[], 
    options: any
  ): Promise<{ 
    success: boolean; 
    successCount: number; 
    message?: string 
  }>;
}
```

### 4. Preload 脚本

**文件**: `Nimbria/src-electron/core/project-preload.ts`

```typescript
searchScraper: {
  // ... 现有方法
  
  learnSelector: (tabId: string, url: string) => 
    ipcRenderer.invoke('search-scraper:learn-selector', { tabId, url }),
  
  scrapeLight: (tabId: string, chapters: any[], options: any) =>
    ipcRenderer.invoke('search-scraper:scrape-light', { tabId, chapters, options })
}
```

---

## 📦 依赖安装

### 需要安装的 npm 包

```json
{
  "dependencies": {
    "cheerio": "^1.0.0-rc.12",
    "axios": "^1.6.0",
    "p-limit": "^5.0.0"
  }
}
```

### 安装命令

```bash
cd Nimbria
npm install cheerio axios p-limit
```

---

## 🔄 实现步骤

### 阶段 1: 前端 UI（已完成）
- [x] 设置面板：爬取模式切换器
- [x] 轻量模式配置项（并行数、超时）

### 阶段 2: Store 状态管理
1. **扩展类型定义**
   - 修改 `types.ts`，添加 `ScrapeMode`, `LightModeConfig`
   
2. **扩展 Store 方法**
   - `updateScrapeMode`
   - `updateLightModeConfig`
   - `setContentSelector`

3. **集成到设置面板**
   - 从 Store 读取初始值
   - 保存时更新 Store

### 阶段 3: 后端服务
1. **创建 LightModeScraper 类**
   - 实现 `scrapeChapters`（并行爬取）
   - 实现 `scrapeChapter`（单章爬取）
   - 实现 `learnSelector`（选择器学习）

2. **集成到 BrowserViewManager**
   - 添加 `learnContentSelector` 方法
   - 添加 `scrapeChaptersLight` 方法

### 阶段 4: IPC 通信
1. **添加 IPC Handlers**
   - `search-scraper:learn-selector`
   - `search-scraper:scrape-light`

2. **扩展前端 Service**
   - `learnContentSelector`
   - `scrapeChaptersLight`

3. **更新类型声明和 Preload**

### 阶段 5: 前端爬取逻辑
1. **修改 NovelScraperPanel**
   - 扩展 `handleScrapeChapters`，添加模式判断
   - 实现 `scrapeLightMode`（新方法）
   - 保留 `scrapeBrowserMode`（现有逻辑）

2. **添加进度反馈**
   - 选择器学习进度
   - 并行爬取进度

### 阶段 6: 测试与优化
1. **单元测试**
   - LightModeScraper 测试
   - 选择器学习测试

2. **集成测试**
   - 完整流程测试（不同网站）
   - 错误处理测试

3. **性能优化**
   - 调整并行数
   - 优化选择器学习算法

---

## 🧪 测试计划

### 1. 选择器学习测试

**测试网站**:
- 起点中文网（复杂结构）
- 简书（简单结构）
- 自定义测试站点

**测试用例**:
```typescript
test('学习选择器 - 起点中文网', async () => {
  const url = 'https://www.qidian.com/chapter/xxx/xxx'
  const selector = await learnContentSelector(tabId, url)
  expect(selector).toBeDefined()
  expect(selector).toContain('content')
})
```

### 2. 并行爬取测试

**测试场景**:
- 爬取 10 章（并行数 3）
- 爬取 50 章（并行数 5）
- 爬取 100 章（并行数 10）

**性能指标**:
- 全浏览器模式: ~5s/章
- 轻量模式: ~0.5s/章（预期提升 10x）

### 3. 错误处理测试

**测试场景**:
- 网络超时
- 选择器无效
- 部分章节失败

**预期行为**:
- 优雅降级
- 明确的错误提示
- 失败章节可重试

---

## 🎯 优化方向

### 短期优化
1. **智能选择器学习**
   - 增加更多启发式规则
   - 支持手动调整选择器

2. **进度可视化**
   - 实时显示爬取速度
   - 显示成功/失败统计

3. **断点续传**
   - 记录已爬取章节
   - 支持暂停/继续

### 长期优化
1. **选择器缓存**
   - 为不同网站缓存选择器
   - 自动应用已知选择器

2. **反爬对策**
   - 动态调整并行数
   - 支持代理池
   - Cookie 管理

3. **内容清洗**
   - 自动去除广告
   - 格式化输出
   - 生成 ePub/MOBI

---

## 📝 总结

通过轻量模式的引入，我们将实现：

### ✅ 功能收益
- **速度提升**: 10x+ 的爬取速度（预期）
- **资源节省**: 减少浏览器实例开销
- **灵活性**: 两种模式可自由切换

### ⚠️ 注意事项
- 轻量模式不适用于需要 JS 渲染的动态网站
- 选择器学习可能不准确，需要手动调整机制
- 高并行数可能触发反爬机制

### 🚀 下一步
1. 安装依赖包 (`cheerio`, `axios`, `p-limit`)
2. 按阶段逐步实现
3. 充分测试各种边缘情况

---

**设计完成时间**: 2025-10-25  
**设计者**: AI Assistant  
**审核者**: Boss

