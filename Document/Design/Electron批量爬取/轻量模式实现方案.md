# ğŸš€ è½»é‡æ¨¡å¼å®ç°æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•
1. [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
2. [å‰ç«¯è®¾è®¡](#å‰ç«¯è®¾è®¡)
3. [åç«¯è®¾è®¡](#åç«¯è®¾è®¡)
4. [IPC é€šä¿¡è®¾è®¡](#ipc-é€šä¿¡è®¾è®¡)
5. [ç±»å‹å®šä¹‰](#ç±»å‹å®šä¹‰)
6. [å®ç°æ­¥éª¤](#å®ç°æ­¥éª¤)
7. [æµ‹è¯•è®¡åˆ’](#æµ‹è¯•è®¡åˆ’)

---

## ğŸ—ï¸ æ¶æ„æ¦‚è§ˆ

### ä¸¤ç§æ¨¡å¼å¯¹æ¯”

| ç‰¹æ€§ | å…¨æµè§ˆå™¨æ¨¡å¼ | è½»é‡æ¨¡å¼ |
|------|------------|---------|
| **ç« èŠ‚åˆ—è¡¨è·å–** | BrowserViewï¼ˆç°æœ‰ï¼‰ | BrowserViewï¼ˆç°æœ‰ï¼‰ |
| **å†…å®¹é€‰æ‹©å™¨è·å–** | æ‰‹åŠ¨æˆ–åŠè‡ªåŠ¨ | è‡ªåŠ¨ä»é¦–ä¸ªç« èŠ‚å­¦ä¹  |
| **ç« èŠ‚å†…å®¹çˆ¬å–** | é€ä¸ªåŠ è½½ BrowserView | Cheerio å¹¶è¡Œè¯·æ±‚ |
| **é€Ÿåº¦** | æ…¢ï¼ˆä¸²è¡Œï¼‰ | å¿«ï¼ˆå¹¶è¡Œï¼‰ |
| **é€‚ç”¨åœºæ™¯** | åŠ¨æ€å†…å®¹ã€åçˆ¬å¼º | é™æ€å†…å®¹ã€ç»“æ„è§„èŒƒ |
| **èµ„æºæ¶ˆè€—** | é«˜ï¼ˆæµè§ˆå™¨å®ä¾‹ï¼‰ | ä½ï¼ˆHTTP è¯·æ±‚ï¼‰ |

### æ ¸å¿ƒæµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ç”¨æˆ·è§¦å‘çˆ¬å–                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  æ£€æŸ¥çˆ¬å–æ¨¡å¼      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                     â”‚
        â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å…¨æµè§ˆå™¨æ¨¡å¼   â”‚     â”‚   è½»é‡æ¨¡å¼        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                     â”‚
        â”‚                     â–¼
        â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚             â”‚ 1. è·å–ç« èŠ‚åˆ—è¡¨   â”‚
        â”‚             â”‚   (BrowserView)  â”‚
        â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                      â”‚
        â”‚                      â–¼
        â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚             â”‚ 2. å­¦ä¹ é€‰æ‹©å™¨     â”‚
        â”‚             â”‚   (åŠ è½½é¦–ç« )     â”‚
        â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                      â”‚
        â”‚                      â–¼
        â”‚             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚             â”‚ 3. å¹¶è¡Œçˆ¬å–       â”‚
        â”‚             â”‚   (Cheerio)      â”‚
        â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                         â”‚
                                         â–¼
                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                               â”‚   çˆ¬å–å®Œæˆ        â”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¨ å‰ç«¯è®¾è®¡

### 1. Store çŠ¶æ€ç®¡ç†

#### æ–°å¢çŠ¶æ€å­—æ®µ

**æ–‡ä»¶**: `Nimbria/Client/stores/search-and-scraper/types.ts`

```typescript
/**
 * çˆ¬å–æ¨¡å¼ç±»å‹
 */
export type ScrapeMode = 'browser' | 'light'

/**
 * è½»é‡æ¨¡å¼é…ç½®
 */
export interface LightModeConfig {
  /** å¹¶è¡Œè¯·æ±‚æ•° */
  parallelCount: number
  /** è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ */
  requestTimeout: number
  /** å†…å®¹é€‰æ‹©å™¨ï¼ˆè‡ªåŠ¨å­¦ä¹ ï¼‰ */
  contentSelector?: string
  /** æ˜¯å¦å·²å­¦ä¹ é€‰æ‹©å™¨ */
  selectorLearned: boolean
}

/**
 * çˆ¬å–é…ç½®ï¼ˆæ‰©å±•ç°æœ‰ï¼‰
 */
export interface ScrapeConfig {
  /** çˆ¬å–æ¨¡å¼ */
  mode: ScrapeMode
  /** è½»é‡æ¨¡å¼é…ç½® */
  lightMode: LightModeConfig
  // ... ç°æœ‰å­—æ®µ
}
```

#### Store æ–¹æ³•æ‰©å±•

**æ–‡ä»¶**: `Nimbria/Client/stores/search-and-scraper/search-and-scraper-store.ts`

```typescript
export const useSearchAndScraperStore = defineStore('searchAndScraper', () => {
  // ... ç°æœ‰çŠ¶æ€
  
  /**
   * æ›´æ–°çˆ¬å–æ¨¡å¼
   */
  const updateScrapeMode = (tabId: string, mode: ScrapeMode): void => {
    const instance = instances.value.get(tabId)
    if (!instance) return
    
    instance.scrapeConfig.mode = mode
    console.log(`[Store] Tab ${tabId} çˆ¬å–æ¨¡å¼æ›´æ–°ä¸º: ${mode}`)
  }
  
  /**
   * æ›´æ–°è½»é‡æ¨¡å¼é…ç½®
   */
  const updateLightModeConfig = (tabId: string, config: Partial<LightModeConfig>): void => {
    const instance = instances.value.get(tabId)
    if (!instance) return
    
    instance.scrapeConfig.lightMode = {
      ...instance.scrapeConfig.lightMode,
      ...config
    }
  }
  
  /**
   * è®¾ç½®å†…å®¹é€‰æ‹©å™¨ï¼ˆå­¦ä¹ å®Œæˆï¼‰
   */
  const setContentSelector = (tabId: string, selector: string): void => {
    updateLightModeConfig(tabId, {
      contentSelector: selector,
      selectorLearned: true
    })
    console.log(`[Store] Tab ${tabId} å·²å­¦ä¹ é€‰æ‹©å™¨: ${selector}`)
  }
  
  return {
    // ... ç°æœ‰æ–¹æ³•
    updateScrapeMode,
    updateLightModeConfig,
    setContentSelector
  }
})
```

### 2. å‰ç«¯çˆ¬å–é€»è¾‘ä¿®æ”¹

**æ–‡ä»¶**: `Nimbria/Client/GUI/components/.../NovelScraperPanel.vue`

#### ä¿®æ”¹ `handleScrapeChapters` æ–¹æ³•

```typescript
const handleScrapeChapters = async (): Promise<void> => {
  if (!instance) return
  
  // 1. ç¡®å®šè¦çˆ¬å–çš„ç« èŠ‚
  let chaptersToScrape = matchedChapters.value
  const listComponent = chapterListRef.value
  if (listComponent?.selectMode) {
    const selectedChapters = listComponent.getSelectedChapters()
    if (selectedChapters.length === 0) {
      ElMessage.warning({ message: 'è¯·å…ˆé€‰æ‹©è¦çˆ¬å–çš„ç« èŠ‚' })
      return
    }
    chaptersToScrape = selectedChapters
  }
  
  // 2. æ ¹æ®æ¨¡å¼é€‰æ‹©çˆ¬å–ç­–ç•¥
  const scrapeMode = instance.scrapeConfig.mode
  
  if (scrapeMode === 'browser') {
    // ğŸ”µ å…¨æµè§ˆå™¨æ¨¡å¼ï¼ˆç°æœ‰é€»è¾‘ï¼‰
    await scrapeBrowserMode(chaptersToScrape)
  } else {
    // ğŸŸ¡ è½»é‡æ¨¡å¼ï¼ˆæ–°å¢ï¼‰
    await scrapeLightMode(chaptersToScrape)
  }
}

/**
 * å…¨æµè§ˆå™¨æ¨¡å¼çˆ¬å–ï¼ˆç°æœ‰é€»è¾‘ï¼Œä¿æŒä¸å˜ï¼‰
 */
const scrapeBrowserMode = async (chapters: Chapter[]): Promise<void> => {
  // ... ç°æœ‰å®ç°
}

/**
 * è½»é‡æ¨¡å¼çˆ¬å–ï¼ˆæ–°å¢ï¼‰
 */
const scrapeLightMode = async (chapters: Chapter[]): Promise<void> => {
  if (!instance) return
  
  try {
    // 1. æ£€æŸ¥æ˜¯å¦å·²å­¦ä¹ é€‰æ‹©å™¨
    if (!instance.scrapeConfig.lightMode.selectorLearned) {
      ElMessage.info({ message: 'æ­£åœ¨å­¦ä¹ å†…å®¹é€‰æ‹©å™¨...' })
      
      // ä½¿ç”¨ç¬¬ä¸€ä¸ªç« èŠ‚å­¦ä¹ é€‰æ‹©å™¨
      const firstChapter = chapters[0]
      const selector = await SearchAndScraperService.learnContentSelector(
        props.tabId,
        firstChapter.url
      )
      
      if (!selector.success || !selector.selector) {
        ElMessage.error({ message: 'é€‰æ‹©å™¨å­¦ä¹ å¤±è´¥ï¼Œè¯·å°è¯•å…¨æµè§ˆå™¨æ¨¡å¼' })
        return
      }
      
      // ä¿å­˜å­¦ä¹ åˆ°çš„é€‰æ‹©å™¨
      searchAndScraperStore.setContentSelector(props.tabId, selector.selector)
      ElMessage.success({ message: `å·²å­¦ä¹ é€‰æ‹©å™¨: ${selector.selector}` })
    }
    
    // 2. å¼€å§‹å¹¶è¡Œçˆ¬å–
    const result = await SearchAndScraperService.scrapeChaptersLight(
      props.tabId,
      chapters,
      {
        selector: instance.scrapeConfig.lightMode.contentSelector!,
        parallelCount: instance.scrapeConfig.lightMode.parallelCount,
        timeout: instance.scrapeConfig.lightMode.requestTimeout * 1000,
        urlPrefix: urlPrefixEnabled.value ? urlPrefix.value : undefined
      }
    )
    
    if (result.success) {
      ElMessage.success({ 
        message: `çˆ¬å–å®Œæˆï¼æˆåŠŸ ${result.successCount}/${chapters.length} ç« ` 
      })
    } else {
      ElMessage.error({ message: result.message || 'çˆ¬å–å¤±è´¥' })
    }
    
  } catch (error) {
    console.error('[NovelScraper] Light mode scrape error:', error)
    ElMessage.error({ message: 'çˆ¬å–è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯' })
  }
}
```

### 3. è®¾ç½®é¢æ¿é›†æˆ

**æ–‡ä»¶**: `Nimbria/Client/GUI/components/.../SettingsContent.vue`

#### æ·»åŠ ä¿å­˜åˆ° Store çš„é€»è¾‘

```typescript
import { useSearchAndScraperStore } from '@stores/search-and-scraper'

// æ¥æ”¶ tabId ä½œä¸º prop
interface Props {
  tabId: string
}

const props = defineProps<Props>()
const searchAndScraperStore = useSearchAndScraperStore()

// ä» Store åˆå§‹åŒ–è®¾ç½®
onMounted(() => {
  const instance = searchAndScraperStore.getInstance(props.tabId)
  if (instance) {
    scrapeMode.value = instance.scrapeConfig.mode
    parallelCount.value = instance.scrapeConfig.lightMode.parallelCount
    requestTimeout.value = instance.scrapeConfig.lightMode.requestTimeout
  }
})

/**
 * ä¿å­˜è®¾ç½®
 */
const handleSave = (): void => {
  // ä¿å­˜åˆ° Store
  searchAndScraperStore.updateScrapeMode(props.tabId, scrapeMode.value)
  searchAndScraperStore.updateLightModeConfig(props.tabId, {
    parallelCount: parallelCount.value,
    requestTimeout: requestTimeout.value
  })
  
  ElMessage.success({ message: 'è®¾ç½®å·²ä¿å­˜' })
}
```

---

## ğŸ”§ åç«¯è®¾è®¡

### 1. æ–°å¢æœåŠ¡ï¼šLightModeScraper

**æ–‡ä»¶**: `Nimbria/src-electron/services/search-scraper-service/light-mode-scraper.ts`

```typescript
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios'
import * as cheerio from 'cheerio'
import pLimit from 'p-limit'

/**
 * çˆ¬å–é€‰é¡¹
 */
export interface LightScrapeOptions {
  /** å†…å®¹é€‰æ‹©å™¨ */
  selector: string
  /** å¹¶è¡Œæ•° */
  parallelCount: number
  /** è¯·æ±‚è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰ */
  timeout: number
  /** URL å‰ç¼€ */
  urlPrefix?: string
  /** è‡ªå®šä¹‰ Headers */
  headers?: Record<string, string>
}

/**
 * ç« èŠ‚æ•°æ®ï¼ˆç®€åŒ–ç‰ˆï¼‰
 */
export interface ChapterData {
  title: string
  url: string
}

/**
 * çˆ¬å–ç»“æœ
 */
export interface ScrapeResult {
  success: boolean
  chapter: ChapterData
  content?: string
  error?: string
}

/**
 * è½»é‡æ¨¡å¼çˆ¬è™«
 */
export class LightModeScraper {
  private axiosInstance: AxiosInstance
  
  constructor() {
    this.axiosInstance = axios.create({
      timeout: 30000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
      }
    })
  }
  
  /**
   * å¹¶è¡Œçˆ¬å–å¤šä¸ªç« èŠ‚
   */
  public async scrapeChapters(
    chapters: ChapterData[],
    options: LightScrapeOptions
  ): Promise<ScrapeResult[]> {
    const limit = pLimit(options.parallelCount)
    
    const tasks = chapters.map(chapter =>
      limit(() => this.scrapeChapter(chapter, options))
    )
    
    return await Promise.all(tasks)
  }
  
  /**
   * çˆ¬å–å•ä¸ªç« èŠ‚
   */
  private async scrapeChapter(
    chapter: ChapterData,
    options: LightScrapeOptions
  ): Promise<ScrapeResult> {
    try {
      // æ„å»ºå®Œæ•´ URL
      const fullUrl = options.urlPrefix 
        ? `${options.urlPrefix}${chapter.url}` 
        : chapter.url
      
      // å‘é€ HTTP è¯·æ±‚
      const response = await this.axiosInstance.get(fullUrl, {
        timeout: options.timeout,
        headers: options.headers
      })
      
      // ä½¿ç”¨ cheerio è§£æ HTML
      const $ = cheerio.load(response.data)
      
      // æå–å†…å®¹
      const content = $(options.selector).text().trim()
      
      if (!content) {
        return {
          success: false,
          chapter,
          error: 'é€‰æ‹©å™¨æœªåŒ¹é…åˆ°å†…å®¹'
        }
      }
      
      console.log(`[LightScraper] æˆåŠŸçˆ¬å–: ${chapter.title}`)
      
      return {
        success: true,
        chapter,
        content
      }
      
    } catch (error) {
      console.error(`[LightScraper] çˆ¬å–å¤±è´¥: ${chapter.title}`, error)
      return {
        success: false,
        chapter,
        error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'
      }
    }
  }
  
  /**
   * å­¦ä¹ å†…å®¹é€‰æ‹©å™¨ï¼ˆä½¿ç”¨ BrowserView åŠ è½½ä¸€æ¬¡ï¼‰
   */
  public async learnSelector(html: string): Promise<string | null> {
    const $ = cheerio.load(html)
    
    // ç­–ç•¥1: æŸ¥æ‰¾å¸¸è§çš„å°è¯´å†…å®¹å®¹å™¨
    const commonSelectors = [
      '#content',
      '.content',
      '#chaptercontent',
      '.chapter-content',
      '.novel-content',
      '.article-content',
      'article',
      '.text-content'
    ]
    
    for (const selector of commonSelectors) {
      const element = $(selector)
      if (element.length > 0 && element.text().trim().length > 100) {
        console.log(`[LightScraper] å­¦ä¹ åˆ°é€‰æ‹©å™¨: ${selector}`)
        return selector
      }
    }
    
    // ç­–ç•¥2: æŸ¥æ‰¾æ–‡æœ¬æœ€å¤šçš„ div
    let maxTextLength = 0
    let bestSelector = null
    
    $('div').each((_, elem) => {
      const text = $(elem).text().trim()
      if (text.length > maxTextLength && text.length > 100) {
        maxTextLength = text.length
        // å°è¯•ç”Ÿæˆä¸€ä¸ªé€‰æ‹©å™¨
        const id = $(elem).attr('id')
        const className = $(elem).attr('class')
        
        if (id) {
          bestSelector = `#${id}`
        } else if (className) {
          const firstClass = className.split(' ')[0]
          bestSelector = `.${firstClass}`
        }
      }
    })
    
    return bestSelector
  }
}
```

### 2. é›†æˆåˆ° BrowserViewManager

**æ–‡ä»¶**: `Nimbria/src-electron/services/search-scraper-service/browser-view-manager.ts`

```typescript
import { LightModeScraper, type LightScrapeOptions, type ChapterData } from './light-mode-scraper'

export class BrowserViewManager {
  // ... ç°æœ‰ä»£ç 
  
  private lightScraper: LightModeScraper
  
  constructor(windowManager: WindowManager) {
    // ... ç°æœ‰åˆå§‹åŒ–
    this.lightScraper = new LightModeScraper()
  }
  
  /**
   * å­¦ä¹ å†…å®¹é€‰æ‹©å™¨
   */
  public async learnContentSelector(tabId: string, url: string): Promise<string | null> {
    const instance = this.instances.get(tabId)
    if (!instance) {
      throw new Error(`Tab ${tabId} not found`)
    }
    
    try {
      // åœ¨ BrowserView ä¸­åŠ è½½é¡µé¢
      await instance.view.webContents.loadURL(url)
      await new Promise(resolve => {
        instance.view.webContents.once('dom-ready', resolve)
      })
      
      // è·å–é¡µé¢ HTML
      const html = await instance.view.webContents.executeJavaScript(
        'document.documentElement.outerHTML'
      )
      
      // ä½¿ç”¨ cheerio å­¦ä¹ é€‰æ‹©å™¨
      return await this.lightScraper.learnSelector(html)
      
    } catch (error) {
      console.error('[BrowserViewManager] Learn selector failed:', error)
      return null
    }
  }
  
  /**
   * è½»é‡æ¨¡å¼çˆ¬å–ç« èŠ‚
   */
  public async scrapeChaptersLight(
    chapters: ChapterData[],
    options: LightScrapeOptions,
    onProgress?: (current: number, total: number, currentChapter: string) => void
  ): Promise<{ success: boolean; results: any[]; successCount: number }> {
    try {
      const results = await this.lightScraper.scrapeChapters(chapters, options)
      
      const successCount = results.filter(r => r.success).length
      
      console.log(`[BrowserViewManager] Light mode scrape completed: ${successCount}/${chapters.length}`)
      
      return {
        success: true,
        results,
        successCount
      }
      
    } catch (error) {
      console.error('[BrowserViewManager] Light scrape failed:', error)
      return {
        success: false,
        results: [],
        successCount: 0
      }
    }
  }
}
```

---

## ğŸ“¡ IPC é€šä¿¡è®¾è®¡

### 1. æ–°å¢ IPC Channels

**æ–‡ä»¶**: `Nimbria/src-electron/ipc/main-renderer/search-scraper-handlers.ts`

```typescript
/**
 * å­¦ä¹ å†…å®¹é€‰æ‹©å™¨
 */
ipcMain.handle('search-scraper:learn-selector', async (event, { tabId, url }) => {
  try {
    const selector = await SearchScraperService.learnContentSelector(tabId, url)
    return { success: !!selector, selector }
  } catch (error) {
    console.error('[IPC] Learn selector error:', error)
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯' 
    }
  }
})

/**
 * è½»é‡æ¨¡å¼çˆ¬å–ç« èŠ‚
 */
ipcMain.handle('search-scraper:scrape-light', async (event, { tabId, chapters, options }) => {
  try {
    const result = await SearchScraperService.scrapeChaptersLight(tabId, chapters, options)
    return result
  } catch (error) {
    console.error('[IPC] Light scrape error:', error)
    return { 
      success: false, 
      message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯',
      successCount: 0
    }
  }
})
```

### 2. å‰ç«¯ Service æ–¹æ³•

**æ–‡ä»¶**: `Nimbria/Client/Service/SearchAndScraper/search-and-scraper.service.ts`

```typescript
/**
 * å­¦ä¹ å†…å®¹é€‰æ‹©å™¨
 */
static async learnContentSelector(
  tabId: string, 
  url: string
): Promise<{ success: boolean; selector?: string }> {
  return await window.NimbriaAPI.searchScraper.learnSelector(tabId, url)
}

/**
 * è½»é‡æ¨¡å¼çˆ¬å–ç« èŠ‚
 */
static async scrapeChaptersLight(
  tabId: string,
  chapters: Chapter[],
  options: {
    selector: string
    parallelCount: number
    timeout: number
    urlPrefix?: string
  }
): Promise<{ success: boolean; successCount: number; message?: string }> {
  return await window.NimbriaAPI.searchScraper.scrapeLight(tabId, chapters, options)
}
```

### 3. ç±»å‹å£°æ˜

**æ–‡ä»¶**: `Nimbria/Client/types/core/window.d.ts`

```typescript
interface NimbriaSearchScraperAPI {
  // ... ç°æœ‰æ–¹æ³•
  
  learnSelector(tabId: string, url: string): Promise<{ 
    success: boolean; 
    selector?: string 
  }>;
  
  scrapeLight(
    tabId: string, 
    chapters: any[], 
    options: any
  ): Promise<{ 
    success: boolean; 
    successCount: number; 
    message?: string 
  }>;
}
```

### 4. Preload è„šæœ¬

**æ–‡ä»¶**: `Nimbria/src-electron/core/project-preload.ts`

```typescript
searchScraper: {
  // ... ç°æœ‰æ–¹æ³•
  
  learnSelector: (tabId: string, url: string) => 
    ipcRenderer.invoke('search-scraper:learn-selector', { tabId, url }),
  
  scrapeLight: (tabId: string, chapters: any[], options: any) =>
    ipcRenderer.invoke('search-scraper:scrape-light', { tabId, chapters, options })
}
```

---

## ğŸ“¦ ä¾èµ–å®‰è£…

### éœ€è¦å®‰è£…çš„ npm åŒ…

```json
{
  "dependencies": {
    "cheerio": "^1.0.0-rc.12",
    "axios": "^1.6.0",
    "p-limit": "^5.0.0"
  }
}
```

### å®‰è£…å‘½ä»¤

```bash
cd Nimbria
npm install cheerio axios p-limit
```

---

## ğŸ”„ å®ç°æ­¥éª¤

### é˜¶æ®µ 1: å‰ç«¯ UIï¼ˆå·²å®Œæˆï¼‰
- [x] è®¾ç½®é¢æ¿ï¼šçˆ¬å–æ¨¡å¼åˆ‡æ¢å™¨
- [x] è½»é‡æ¨¡å¼é…ç½®é¡¹ï¼ˆå¹¶è¡Œæ•°ã€è¶…æ—¶ï¼‰

### é˜¶æ®µ 2: Store çŠ¶æ€ç®¡ç†
1. **æ‰©å±•ç±»å‹å®šä¹‰**
   - ä¿®æ”¹ `types.ts`ï¼Œæ·»åŠ  `ScrapeMode`, `LightModeConfig`
   
2. **æ‰©å±• Store æ–¹æ³•**
   - `updateScrapeMode`
   - `updateLightModeConfig`
   - `setContentSelector`

3. **é›†æˆåˆ°è®¾ç½®é¢æ¿**
   - ä» Store è¯»å–åˆå§‹å€¼
   - ä¿å­˜æ—¶æ›´æ–° Store

### é˜¶æ®µ 3: åç«¯æœåŠ¡
1. **åˆ›å»º LightModeScraper ç±»**
   - å®ç° `scrapeChapters`ï¼ˆå¹¶è¡Œçˆ¬å–ï¼‰
   - å®ç° `scrapeChapter`ï¼ˆå•ç« çˆ¬å–ï¼‰
   - å®ç° `learnSelector`ï¼ˆé€‰æ‹©å™¨å­¦ä¹ ï¼‰

2. **é›†æˆåˆ° BrowserViewManager**
   - æ·»åŠ  `learnContentSelector` æ–¹æ³•
   - æ·»åŠ  `scrapeChaptersLight` æ–¹æ³•

### é˜¶æ®µ 4: IPC é€šä¿¡
1. **æ·»åŠ  IPC Handlers**
   - `search-scraper:learn-selector`
   - `search-scraper:scrape-light`

2. **æ‰©å±•å‰ç«¯ Service**
   - `learnContentSelector`
   - `scrapeChaptersLight`

3. **æ›´æ–°ç±»å‹å£°æ˜å’Œ Preload**

### é˜¶æ®µ 5: å‰ç«¯çˆ¬å–é€»è¾‘
1. **ä¿®æ”¹ NovelScraperPanel**
   - æ‰©å±• `handleScrapeChapters`ï¼Œæ·»åŠ æ¨¡å¼åˆ¤æ–­
   - å®ç° `scrapeLightMode`ï¼ˆæ–°æ–¹æ³•ï¼‰
   - ä¿ç•™ `scrapeBrowserMode`ï¼ˆç°æœ‰é€»è¾‘ï¼‰

2. **æ·»åŠ è¿›åº¦åé¦ˆ**
   - é€‰æ‹©å™¨å­¦ä¹ è¿›åº¦
   - å¹¶è¡Œçˆ¬å–è¿›åº¦

### é˜¶æ®µ 6: æµ‹è¯•ä¸ä¼˜åŒ–
1. **å•å…ƒæµ‹è¯•**
   - LightModeScraper æµ‹è¯•
   - é€‰æ‹©å™¨å­¦ä¹ æµ‹è¯•

2. **é›†æˆæµ‹è¯•**
   - å®Œæ•´æµç¨‹æµ‹è¯•ï¼ˆä¸åŒç½‘ç«™ï¼‰
   - é”™è¯¯å¤„ç†æµ‹è¯•

3. **æ€§èƒ½ä¼˜åŒ–**
   - è°ƒæ•´å¹¶è¡Œæ•°
   - ä¼˜åŒ–é€‰æ‹©å™¨å­¦ä¹ ç®—æ³•

---

## ğŸ§ª æµ‹è¯•è®¡åˆ’

### 1. é€‰æ‹©å™¨å­¦ä¹ æµ‹è¯•

**æµ‹è¯•ç½‘ç«™**:
- èµ·ç‚¹ä¸­æ–‡ç½‘ï¼ˆå¤æ‚ç»“æ„ï¼‰
- ç®€ä¹¦ï¼ˆç®€å•ç»“æ„ï¼‰
- è‡ªå®šä¹‰æµ‹è¯•ç«™ç‚¹

**æµ‹è¯•ç”¨ä¾‹**:
```typescript
test('å­¦ä¹ é€‰æ‹©å™¨ - èµ·ç‚¹ä¸­æ–‡ç½‘', async () => {
  const url = 'https://www.qidian.com/chapter/xxx/xxx'
  const selector = await learnContentSelector(tabId, url)
  expect(selector).toBeDefined()
  expect(selector).toContain('content')
})
```

### 2. å¹¶è¡Œçˆ¬å–æµ‹è¯•

**æµ‹è¯•åœºæ™¯**:
- çˆ¬å– 10 ç« ï¼ˆå¹¶è¡Œæ•° 3ï¼‰
- çˆ¬å– 50 ç« ï¼ˆå¹¶è¡Œæ•° 5ï¼‰
- çˆ¬å– 100 ç« ï¼ˆå¹¶è¡Œæ•° 10ï¼‰

**æ€§èƒ½æŒ‡æ ‡**:
- å…¨æµè§ˆå™¨æ¨¡å¼: ~5s/ç« 
- è½»é‡æ¨¡å¼: ~0.5s/ç« ï¼ˆé¢„æœŸæå‡ 10xï¼‰

### 3. é”™è¯¯å¤„ç†æµ‹è¯•

**æµ‹è¯•åœºæ™¯**:
- ç½‘ç»œè¶…æ—¶
- é€‰æ‹©å™¨æ— æ•ˆ
- éƒ¨åˆ†ç« èŠ‚å¤±è´¥

**é¢„æœŸè¡Œä¸º**:
- ä¼˜é›…é™çº§
- æ˜ç¡®çš„é”™è¯¯æç¤º
- å¤±è´¥ç« èŠ‚å¯é‡è¯•

---

## ğŸ¯ ä¼˜åŒ–æ–¹å‘

### çŸ­æœŸä¼˜åŒ–
1. **æ™ºèƒ½é€‰æ‹©å™¨å­¦ä¹ **
   - å¢åŠ æ›´å¤šå¯å‘å¼è§„åˆ™
   - æ”¯æŒæ‰‹åŠ¨è°ƒæ•´é€‰æ‹©å™¨

2. **è¿›åº¦å¯è§†åŒ–**
   - å®æ—¶æ˜¾ç¤ºçˆ¬å–é€Ÿåº¦
   - æ˜¾ç¤ºæˆåŠŸ/å¤±è´¥ç»Ÿè®¡

3. **æ–­ç‚¹ç»­ä¼ **
   - è®°å½•å·²çˆ¬å–ç« èŠ‚
   - æ”¯æŒæš‚åœ/ç»§ç»­

### é•¿æœŸä¼˜åŒ–
1. **é€‰æ‹©å™¨ç¼“å­˜**
   - ä¸ºä¸åŒç½‘ç«™ç¼“å­˜é€‰æ‹©å™¨
   - è‡ªåŠ¨åº”ç”¨å·²çŸ¥é€‰æ‹©å™¨

2. **åçˆ¬å¯¹ç­–**
   - åŠ¨æ€è°ƒæ•´å¹¶è¡Œæ•°
   - æ”¯æŒä»£ç†æ± 
   - Cookie ç®¡ç†

3. **å†…å®¹æ¸…æ´—**
   - è‡ªåŠ¨å»é™¤å¹¿å‘Š
   - æ ¼å¼åŒ–è¾“å‡º
   - ç”Ÿæˆ ePub/MOBI

---

## ğŸ“ æ€»ç»“

é€šè¿‡è½»é‡æ¨¡å¼çš„å¼•å…¥ï¼Œæˆ‘ä»¬å°†å®ç°ï¼š

### âœ… åŠŸèƒ½æ”¶ç›Š
- **é€Ÿåº¦æå‡**: 10x+ çš„çˆ¬å–é€Ÿåº¦ï¼ˆé¢„æœŸï¼‰
- **èµ„æºèŠ‚çœ**: å‡å°‘æµè§ˆå™¨å®ä¾‹å¼€é”€
- **çµæ´»æ€§**: ä¸¤ç§æ¨¡å¼å¯è‡ªç”±åˆ‡æ¢

### âš ï¸ æ³¨æ„äº‹é¡¹
- è½»é‡æ¨¡å¼ä¸é€‚ç”¨äºéœ€è¦ JS æ¸²æŸ“çš„åŠ¨æ€ç½‘ç«™
- é€‰æ‹©å™¨å­¦ä¹ å¯èƒ½ä¸å‡†ç¡®ï¼Œéœ€è¦æ‰‹åŠ¨è°ƒæ•´æœºåˆ¶
- é«˜å¹¶è¡Œæ•°å¯èƒ½è§¦å‘åçˆ¬æœºåˆ¶

### ğŸš€ ä¸‹ä¸€æ­¥
1. å®‰è£…ä¾èµ–åŒ… (`cheerio`, `axios`, `p-limit`)
2. æŒ‰é˜¶æ®µé€æ­¥å®ç°
3. å……åˆ†æµ‹è¯•å„ç§è¾¹ç¼˜æƒ…å†µ

---

**è®¾è®¡å®Œæˆæ—¶é—´**: 2025-10-25  
**è®¾è®¡è€…**: AI Assistant  
**å®¡æ ¸è€…**: Boss

