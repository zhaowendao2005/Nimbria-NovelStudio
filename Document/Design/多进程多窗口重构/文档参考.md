## 📊 **技术栈分析**

基于需求分析文档，核心技术栈包括：

### 🎯 **核心技术组件**
1. **Electron** - 主进程管理、多进程架构
2. **TypeScript** - 类型安全开发
3. **Vue 3** - 前端框架
4. **Quasar Framework** - UI组件库
5. **Pinia** - 状态管理

### 🔧 **关键技术点**
1. **MessageChannelMain** - 进程间通信
2. **BrowserWindow** - 窗口管理
3. **contextBridge** - 安全上下文桥接
4. **Worker线程** - 重型任务处理

让我查询这些核心技术的官方文档：

[4 tools called]

现在我来获取这些核心技术的详细文档：

[4 tools called]

## 📚 **多进程窗口架构开发参考文档汇总**

基于技术栈分析，我为你整理了开发过程中需要对照的核心技术文档。

### 🔧 **核心技术栈组件**

| 技术组件 | 版本要求 | 主要用途 | 文档来源 |
|----------|----------|----------|----------|
| **Electron** | 最新版 | 多进程窗口管理、MessageChannel通信 | `/electron/electron` |
| **Vue 3** | 最新版 | 前端框架、Composition API | `/vuejs/docs` |
| **Quasar Framework** | 2.x | UI组件库、布局系统 | `/quasarframework/quasar.git` |
| **Pinia** | 2.x | 状态管理、多实例隔离 | `/vuejs/pinia` |
| **TypeScript** | 5.x | 类型安全开发 | 项目已配置 |

---

## 🚀 **Electron 多进程窗口管理核心API**

### **1. MessageChannelMain 进程间通信**

```javascript
// 主进程创建通信通道
const { BrowserWindow, MessageChannelMain } = require('electron')

const w = new BrowserWindow()
const { port1, port2 } = new MessageChannelMain()
w.webContents.postMessage('port', null, [port2])
port1.postMessage({ some: 'message' })

// 渲染进程接收通信端口
const { ipcRenderer } = require('electron')
ipcRenderer.on('port', (e) => {
  e.ports[0].onmessage = (messageEvent) => {
    console.log(messageEvent.data)
  }
})
```

### **2. BrowserWindow 多窗口管理**

```javascript
// 创建独立渲染进程的窗口
const win = new BrowserWindow({ 
  width: 800, 
  height: 1500,
  webPreferences: {
    contextIsolation: true,
    nodeIntegration: false,
    preload: path.join(__dirname, 'preload.js'),
    nodeIntegrationInWorker: true,  // 支持Worker线程
    partition: `persist:project-${processId}` // 进程隔离
  }
})
```

### **3. 主进程多窗口通信架构**

```javascript
// 设置多窗口MessageChannel通信
const { BrowserWindow, app, MessageChannelMain } = require('electron')

app.whenReady().then(async () => {
  const mainWindow = new BrowserWindow({
    webPreferences: { contextIsolation: false, preload: 'preloadMain.js' }
  })
  
  const projectWindow = new BrowserWindow({
    webPreferences: { contextIsolation: false, preload: 'preloadProject.js' }
  })

  // 建立通信通道
  const { port1, port2 } = new MessageChannelMain()
  
  mainWindow.once('ready-to-show', () => {
    mainWindow.webContents.postMessage('port', null, [port1])
  })
  
  projectWindow.once('ready-to-show', () => {
    projectWindow.webContents.postMessage('port', null, [port2])
  })
})
```

---

## 🎯 **Vue 3 Composition API 开发模式**

### **1. 基础 Composition API 模式**

```vue
<script setup>
import { ref, onMounted } from 'vue'

// 响应式状态
const count = ref(0)

// 状态变更函数
function increment() {
  count.value++
}

// 生命周期钩子
onMounted(() => {
  console.log(`Initial count: ${count.value}`)
})
</script>

<template>
  <button @click="increment">Count: {{ count }}</button>
</template>
```

### **2. Props 和 Emits 定义**

```vue
<script setup lang="ts">
// Props 类型定义
const props = defineProps<{
  foo: string
  bar?: number
}>()

// Events 定义
const emit = defineEmits(['enlarge-text'])

// 使用props
console.log(props.foo) // string
console.log(props.bar) // number | undefined
</script>
```

### **3. 组件间通信**

```vue
<script setup>
import ComponentA from './ComponentA.vue'

// 导入的组件自动可用
</script>

<template>
  <ComponentA @custom-event="handleEvent" />
</template>
```

---

## 🎨 **Quasar Framework 布局系统**

### **1. QLayout 基础布局**

```vue
<template>
  <q-layout view="lHh Lpr lFf">
    <q-header>
      <q-toolbar>
        <q-btn flat dense round icon="menu" @click="leftDrawerOpen = !leftDrawerOpen" />
      </q-toolbar>
    </q-header>

    <q-drawer v-model="leftDrawerOpen" show-if-above bordered>
      <q-list>
        <q-item clickable v-ripple to="/">
          <q-item-section avatar>
            <q-icon name="home" />
          </q-item-section>
          <q-item-section>Home</q-item-section>
        </q-item>
      </q-list>
    </q-drawer>

    <q-page-container>
      <q-page padding>
        <!-- 页面内容 -->
      </q-page>
    </q-page-container>
  </q-layout>
</template>

<script>
import { defineComponent, ref } from 'vue'

export default defineComponent({
  setup() {
    const leftDrawerOpen = ref(false)
    return { leftDrawerOpen }
  }
})
</script>
```

### **2. QDrawer 侧边栏模式**

```vue
<!-- Mini模式抽屉 -->
<q-drawer
  v-model="leftDrawerOpen"
  show-if-above
  :mini="miniState"
  @mouseover="miniState = true"
  @mouseout="miniState = false"
  :mini-width="50"
  :breakpoint="500"
  mini-to-overlay
  bordered
>
```

### **3. 覆盖模式抽屉**

```vue
<!-- 覆盖模式抽屉 -->
<q-drawer
  v-model="leftDrawerOpen"
  show-if-above
  :breakpoint="500"
  overlay
  bordered
>
```

---

## 🗄️ **Pinia 状态管理多实例**

### **1. Setup Store 定义**

```javascript
import { ref, computed } from 'vue'
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  const name = ref('Eduardo')
  const doubleCount = computed(() => count.value * 2)
  
  function increment() {
    count.value++
  }

  return { count, name, doubleCount, increment }
})
```

### **2. 避免循环依赖的Store组合**

```javascript
const useMainStore = defineStore('main', () => {
  const project = useProjectStore()

  // ❌ 不能在setup中直接读取
  // project.name

  function doSomething() {
    // ✅ 在computed或actions中读取
    const projectName = project.name
    // ...
  }

  return { name: ref('Main Window') }
})

const useProjectStore = defineStore('project', () => {
  const main = useMainStore()

  function doSomething() {
    // ✅ 在computed或actions中读取
    const mainName = main.name
    // ...
  }

  return { name: ref('Project Window') }
})
```

### **3. 状态映射（Options API）**

```javascript
import { mapStores, mapWritableState } from 'pinia'

export default {
  computed: {
    // 映射多个store
    ...mapStores(useMainStore, useProjectStore),
    
    // 映射可写状态
    ...mapWritableState(useCounterStore, ['count']),
  },

  methods: {
    async doAction() {
      // 使用映射的store
      if (this.mainStore.isReady()) {
        await this.projectStore.save()
      }
    },
  },
}
```

---

## ⚡ **关键开发模式总结**

### **🔄 进程间通信模式**
1. **主进程 → 渲染进程**: `webContents.postMessage()`
2. **渲染进程 → 主进程**: `MessagePort.postMessage()`
3. **渲染进程 ↔ 渲染进程**: 通过主进程的MessageChannel路由

### **🏗️ 组件开发模式**
1. **优先使用 `<script setup>`**: 更简洁的语法
2. **TypeScript类型定义**: `defineProps<Interface>()`
3. **响应式状态**: `ref()` 和 `computed()`

### **🎨 布局开发模式**
1. **QLayout基础**: `view="lHh Lpr lFf"`
2. **QDrawer配置**: `show-if-above` + `bordered`
3. **响应式控制**: `ref()` 控制抽屉状态

### **🗄️ 状态管理模式**
1. **Setup Store**: 使用Composition API语法
2. **多实例隔离**: 每个窗口独立的Pinia实例
3. **避免循环依赖**: 在actions中读取其他store

---

## 📋 **开发检查清单**

### **✅ Electron 多进程**
- [ ] MessageChannelMain正确创建
- [ ] port1和port2正确分配给不同进程
- [ ] webPreferences配置正确
- [ ] 进程隔离参数设置

### **✅ Vue组件**
- [ ] 使用 `<script setup>` 语法
- [ ] Props和Emits正确定义
- [ ] 响应式状态使用ref/reactive
- [ ] 生命周期钩子正确使用

### **✅ Quasar布局**
- [ ] QLayout view属性配置
- [ ] QDrawer模式选择正确
- [ ] 响应式断点设置
- [ ] 图标和样式应用

### **✅ Pinia状态**
- [ ] Store使用Setup语法
- [ ] 避免循环依赖
- [ ] 状态映射正确
- [ ] 多实例隔离实现

