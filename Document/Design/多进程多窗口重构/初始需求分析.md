## 🚀 **多进程窗口架构重构方案**

基于你提供的专家模式参考，我来设计一个真正的多进程架构。

### 🎯 **核心特性**

1. **真正的进程隔离**：每个项目窗口运行在独立的渲染进程中
2. **MessageChannel通信**：主进程与各渲染进程之间的高效通信
3. **进程级稳定性**：单个项目窗口崩溃不影响其他窗口
4. **资源精细控制**：每个进程可以独立管理内存和CPU资源

### 🏗️ **架构设计**

```
┌─────────────────────────────────────────────────────────────┐
│                    主进程 (Main Process)                       │
├─────────────────────────────────────────────────────────────┤
│  ProcessManager (进程管理器)                                  │
│  ├── createMainProcess()        # 主窗口进程                  │
│  ├── createProjectProcess()     # 项目窗口进程                │
│  ├── MessageChannelRouter       # 消息通道路由器              │
│  └── ProcessRegistry            # 进程注册表                  │
│                                                              │
│  ResourceCoordinator (资源协调器)                             │
│  ├── 内存使用监控                                              │
│  ├── CPU资源分配                                              │
│  └── 进程健康检查                                              │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                 渲染进程 (Renderer Processes)                  │
├─────────────────────────────────────────────────────────────┤
│  主窗口进程 (Main Window Process)                            │
│  ├── Vue3 + Quasar + Pinia                                 │
│  ├── MessagePort通信接口                                     │
│  └── 项目管理界面                                              │
│                                                              │
│  项目进程1 (Project Process 1)                              │
│  ├── Vue3 + Quasar + 独立Pinia                             │
│  ├── MessagePort通信接口                                     │
│  ├── Worker线程支持                                          │
│  └── 完全隔离的项目环境                                        │
│                                                              │
│  项目进程2 (Project Process 2)                              │
│  ├── 独立的渲染进程                                            │
│  └── 与其他进程完全隔离                                        │
└─────────────────────────────────────────────────────────────┘
```

### 🔧 **核心实现**

#### **Step 1: 进程管理器 (ProcessManager)**

```typescript
// src-electron/services/window-service/process-manager.ts
import { BrowserWindow, MessageChannelMain } from 'electron'
import path from 'path'

export class ProcessManager {
  private processes = new Map<string, ProcessInfo>()
  private messageChannels = new Map<string, MessagePortMain>()
  
  // 创建主窗口进程
  createMainProcess(): BrowserWindow {
    const mainWindow = new BrowserWindow({
      width: 1024,
      height: 720,
      frame: false,
      webPreferences: {
        contextIsolation: true,
        nodeIntegration: false,
        preload: path.join(__dirname, 'main-preload.js'),
        // 主进程不需要Worker线程
      }
    })
    
    // 为主窗口建立消息通道
    const { port1, port2 } = new MessageChannelMain()
    mainWindow.webContents.postMessage('port', null, [port1])
    
    this.processes.set('main', {
      type: 'main',
      window: mainWindow,
      port: port2,
      processId: mainWindow.webContents.getProcessId()
    })
    
    this.messageChannels.set('main', port2)
    this.setupMainProcessHandlers(port2)
    
    return mainWindow
  }
  
  // 创建项目窗口进程 (核心功能)
  createProjectProcess(projectPath: string): BrowserWindow {
    const processId = `project-${Date.now()}`
    
    const projectWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      webPreferences: {
        contextIsolation: true,
        nodeIntegration: false,
        preload: path.join(__dirname, 'project-preload.js'),
        nodeIntegrationInWorker: true,  // 支持Worker线程
        // 进程隔离配置
        partition: `persist:project-${processId}`,
        sandbox: false, // 为了支持复杂的项目操作
      }
    })
    
    // 为项目窗口建立独立的消息通道
    const { port1, port2 } = new MessageChannelMain()
    projectWindow.webContents.once('did-finish-load', () => {
      projectWindow.webContents.postMessage('port', null, [port1])
    })
    
    this.processes.set(processId, {
      type: 'project',
      projectPath,
      window: projectWindow,
      port: port2,
      processId: projectWindow.webContents.getProcessId()
    })
    
    this.messageChannels.set(processId, port2)
    this.setupProjectProcessHandlers(processId, port2)
    
    // 进程清理
    projectWindow.on('closed', () => {
      this.cleanupProcess(processId)
    })
    
    return projectWindow
  }
  
  // 设置主进程消息处理
  private setupMainProcessHandlers(port: MessagePortMain) {
    port.on('message', (event) => {
      const { type, data } = event.data
      
      switch (type) {
        case 'request-project-window':
          this.handleCreateProjectWindow(data.projectPath)
          break
        case 'broadcast-to-projects':
          this.broadcastToProjects(data.message)
          break
      }
    })
    
    port.start()
  }
  
  // 设置项目进程消息处理
  private setupProjectProcessHandlers(processId: string, port: MessagePortMain) {
    port.on('message', (event) => {
      const { type, data } = event.data
      
      switch (type) {
        case 'project-ready':
          console.log(`项目进程 ${processId} 就绪`)
          break
        case 'project-save':
          this.handleProjectSave(processId, data)
          break
        case 'request-main-window':
          this.sendToMainProcess(data.message)
          break
      }
    })
    
    port.start()
  }
  
  // 向所有项目进程广播消息
  broadcastToProjects(message: any) {
    this.processes.forEach((process, id) => {
      if (process.type === 'project') {
        process.port.postMessage({ type: 'broadcast', data: message })
      }
    })
  }
  
  // 向主进程发送消息
  sendToMainProcess(message: any) {
    const mainProcess = this.processes.get('main')
    if (mainProcess) {
      mainProcess.port.postMessage({ type: 'from-project', data: message })
    }
  }
  
  // 清理进程资源
  private cleanupProcess(processId: string) {
    const process = this.processes.get(processId)
    if (process) {
      process.port.close()
      this.processes.delete(processId)
      this.messageChannels.delete(processId)
      console.log(`进程 ${processId} 已清理`)
    }
  }
}

interface ProcessInfo {
  type: 'main' | 'project'
  projectPath?: string
  window: BrowserWindow
  port: MessagePortMain
  processId: number
}
```

#### **Step 2: 主进程Preload脚本**

```typescript
// src-electron/core/main-preload.ts
import { contextBridge, ipcRenderer } from 'electron'

let mainPort: MessagePort | null = null

// 接收主进程的MessagePort
ipcRenderer.on('port', (event) => {
  const [port] = event.ports
  mainPort = port
  
  // 设置消息监听
  port.onmessage = (event) => {
    const { type, data } = event.data
    
    switch (type) {
      case 'from-project':
        // 处理来自项目进程的消息
        console.log('收到项目进程消息:', data)
        break
    }
  }
  
  port.start()
})

// 暴露给主窗口的API
contextBridge.exposeInMainWorld('nimbria', {
  window: {
    minimize: () => ipcRenderer.invoke('window-minimize'),
    close: () => ipcRenderer.invoke('window-close'),
    // ... 其他窗口控制API
  },
  
  project: {
    // 通过MessageChannel创建项目窗口
    createWindow: (projectPath: string) => {
      if (mainPort) {
        mainPort.postMessage({
          type: 'request-project-window',
          data: { projectPath }
        })
      }
    },
    
    // 向所有项目进程广播消息
    broadcastToProjects: (message: any) => {
      if (mainPort) {
        mainPort.postMessage({
          type: 'broadcast-to-projects',
          data: { message }
        })
      }
    }
  }
})
```

#### **Step 3: 项目进程Preload脚本**

```typescript
// src-electron/core/project-preload.ts
import { contextBridge, ipcRenderer } from 'electron'

let projectPort: MessagePort | null = null

// 接收主进程的MessagePort
ipcRenderer.on('port', (event) => {
  const [port] = event.ports
  projectPort = port
  
  // 设置消息监听
  port.onmessage = (event) => {
    const { type, data } = event.data
    
    switch (type) {
      case 'broadcast':
        // 处理来自主进程的广播消息
        console.log('收到广播消息:', data)
        // 通知Vue组件
        window.dispatchEvent(new CustomEvent('project-broadcast', { detail: data }))
        break
    }
  }
  
  port.start()
  
  // 通知主进程该项目进程已就绪
  port.postMessage({
    type: 'project-ready',
    data: { timestamp: Date.now() }
  })
})

// 暴露给项目窗口的API
contextBridge.exposeInMainWorld('nimbria', {
  project: {
    // 保存项目数据
    save: (projectData: any) => {
      if (projectPort) {
        projectPort.postMessage({
          type: 'project-save',
          data: projectData
        })
      }
    },
    
    // 向主窗口发送消息
    sendToMain: (message: any) => {
      if (projectPort) {
        projectPort.postMessage({
          type: 'request-main-window',
          data: { message }
        })
      }
    },
    
    // Worker线程支持
    createWorker: (scriptPath: string) => {
      return new Worker(scriptPath)
    }
  }
})
```

#### **Step 4: 主进程集成**

```typescript
// src-electron/core/electron-main.ts (重构)
import { app, BrowserWindow } from 'electron'
import { ProcessManager } from '../services/window-service/process-manager'

const processManager = new ProcessManager()

app.whenReady().then(() => {
  console.log('🚀 启动多进程窗口架构')
  
  // 创建主窗口进程
  const mainWindow = processManager.createMainProcess()
  mainWindow.loadFile('index.html')
  
  // 设置IPC处理器
  setupIpcHandlers()
})

function setupIpcHandlers() {
  // 传统IPC处理器（用于窗口控制等）
  ipcMain.handle('window-minimize', () => {
    // ...现有逻辑
  })
  
  // 项目窗口创建（现在通过ProcessManager）
  ipcMain.handle('project-create-window', async (event, projectPath: string) => {
    try {
      const projectWindow = processManager.createProjectProcess(projectPath)
      await projectWindow.loadFile('project.html')
      return { success: true, processId: projectWindow.webContents.getProcessId() }
    } catch (error) {
      return { success: false, error: error.message }
    }
  })
}
```

### 🎯 **使用示例**

#### **主窗口中创建项目进程**
```typescript
// 在主窗口Vue组件中
export default {
  methods: {
    async openProject(projectPath: string) {
      // 通过MessageChannel创建项目进程
      window.nimbria.project.createWindow(projectPath)
      console.log('项目进程创建请求已发送')
    },
    
    broadcastMessage() {
      // 向所有项目进程广播消息
      window.nimbria.project.broadcastToProjects({
        type: 'theme-change',
        theme: 'dark'
      })
    }
  }
}
```

#### **项目窗口中的进程间通信**
```typescript
// 在项目窗口Vue组件中
export default {
  mounted() {
    // 监听来自主进程的广播
    window.addEventListener('project-broadcast', (event) => {
      console.log('收到广播:', event.detail)
      if (event.detail.type === 'theme-change') {
        this.updateTheme(event.detail.theme)
      }
    })
  },
  
  methods: {
    saveProject() {
      // 通过MessageChannel保存项目
      window.nimbria.project.save(this.projectData)
    },
    
    notifyMainWindow() {
      // 向主窗口发送消息
      window.nimbria.project.sendToMain({
        type: 'project-status',
        status: 'saved'
      })
    },
    
    // 利用Worker线程处理重型任务
    processLargeFile() {
      const worker = window.nimbria.project.createWorker('file-processor.js')
      worker.postMessage(this.largeFileData)
      worker.onmessage = (event) => {
        console.log('Worker处理完成:', event.data)
      }
    }
  }
}
```

### ⚡ **核心优势**

1. **真正的进程隔离**：每个项目运行在独立进程中，崩溃不相互影响
2. **MessageChannel高效通信**：比传统IPC更高效的进程间通信
3. **Worker线程支持**：项目进程可以使用Worker处理重型任务
4. **资源精细控制**：每个进程独立的内存空间和存储分区
5. **多核CPU利用**：充分利用多核处理器性能

### 📋 **工作量评估**

| 任务 | 预估时间 | 说明 |
|------|----------|------|
| ProcessManager实现 | 2天 | 核心进程管理逻辑 |
| Preload脚本重构 | 1天 | 主进程和项目进程预加载 |
| 主进程集成 | 0.5天 | 集成ProcessManager |
| 前端适配 | 1天 | Vue组件适配新API |
| 测试验证 | 0.5天 | 多进程架构测试 |
| **总计** | **5天** | **多进程架构** |

[1 tool called]

## 🎯 **方案总结**

这个多进程窗口架构方案提供了：

✅ **真正的进程级隔离**：每个项目窗口都是独立的渲染进程  
✅ **高效的进程间通信**：基于MessageChannel的现代通信方式  
✅ **Worker线程支持**：项目进程可以使用Worker处理重型任务  
✅ **资源精细控制**：独立的内存空间和存储分区  
✅ **简洁的API接口**：你后续开发只需调用简单方法  
