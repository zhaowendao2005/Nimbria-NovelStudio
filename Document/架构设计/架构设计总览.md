Boss，明白！完全抽象化所有业务和框架相关内容。

## 🏗️ **Biology-Toolbox Client 完全抽象架构**

```
Client/
├── GUI/                                    # 界面层
│   ├── components/                         # 组件库（按页面同名目录组织）
│   │   ├── {模块A}/                        # 模块A页面组件目录
│   │   │   ├── {组件类型1}/                # 组件类型1
│   │   │   │   ├── {模块A.组件类型1.子组件1}/
│   │   │   │   |   ├-----{asset}/   业务模块的静态资源，如图片，视频，svg等等
│   │   │   │   ├── {模块A.组件类型1.子组件2}/
│   │   │   │   └── {模块A.组件类型1.子组件3}/
│   │   │   ├── {组件类型2}/                # 组件类型2
│   │   │   │   ├── {模块A.组件类型2.子组件1}/
│   │   │   │   ├── {模块A.组件类型2.子组件2}/
│   │   │   │   └── {模块A.组件类型2.子组件3}/
│   │   │   ├── {组件类型3}/                # 组件类型3
│   │   │   │   ├── {模块A.组件类型3.子组件1}/
│   │   │   │   ├── {模块A.组件类型3.子组件2}/
│   │   │   │   └── {模块A.组件类型3.子组件3}/
│   │   │   ├── {组件类型4}/                # 组件类型4
│   │   │   │   ├── {模块A.组件类型4.子组件1}/
│   │   │   │   └── {模块A.组件类型4.子组件2}
│   │   │   └── {组件类型5}/                # 组件类型5
│   │   │       ├── {模块A.组件类型5.子组件1}/
│   │   │       └── {模块A.组件类型5.子组件2}/
│   │   ├── {模块B}/                        # 模块B页面组件目录
│   │   │   ├── {组件类型1}/
│   │   │   │   ├── {模块B.组件类型1.子组件1}/
│   │   │   │   └── {模块B.组件类型1.子组件2}/
│   │   │   ├── {组件类型2}/
│   │   │   │   ├── {模块B.组件类型2.子组件1}/
│   │   │   │   └── {模块B.组件类型2.子组件2}/
│   │   │   ├── {组件类型3}/
│   │   │   │   ├── {模块B.组件类型3.子组件1}/
│   │   │   │   └── {模块B.组件类型3.子组件2}/
│   │   │   └── {组件类型4}/
│   │   │       └── {模块B.组件类型4.子组件1}/
│   │   ├── {模块C}/                        # 模块C页面组件目录
│   │   │   ├── {组件类型X}/
│   │   │   │   ├── {模块C.组件类型X.子组件1}/
│   │   │   │   ├── {模块C.组件类型X.子组件2}/
│   │   │   │   └── {模块C.组件类型X.子组件3}/
│   │   │   └── {组件类型Y}/
│   │   │       ├── {模块C.组件类型Y.子组件1}/
│   │   │       └── {模块C.组件类型Y.子组件2}/
│   │   ├── {模块D}/                        # 模块D页面组件目录
│   │   │   ├── {模块D.功能组件1}
│   │   │   ├── {模块D.功能组件2}
│   │   │   ├── {模块D.功能组件3}
│   │   │   └── {模块D.功能组件4}
│   ├── PagesLayout/                       # 页面布局入口组件目录                  # 首页布局（包含内部路由）
│   │   ├── {业务模块A}/               # 业务模块A页面布局
│   │   ├── {业务模块B}/              # 业务模块B页面布局
│   │   ├── {业务模块C}/                # 业务模块C页面布局
│   │   ├── {业务模块D}/         # 业务模块D页面布局
│   ├── Index/                           # 系统入口，不同系统是隔离的，比如a系统包含abc业务模块，b系统包含edf业务模块，使用独立的组织和入口,这些入口内部导入PagesLayout/
│   ├── router/                            # 对外路由配置
│   │   ├── index.ts                       # 路由入口
│   │   └── routes.ts                      # 路由定义
│   ├── assets/                            # 全局静态资源
│   │   ├── {资源分类1}/
│   │   ├── {资源分类2}/
│   │   └── {资源分类3}/
│   └── App.vue                            # 应用入口
├── Service/                               # 大型服务目录（按页面系统分区）
│   ├── home/                              # 首页服务模块
│   │   ├── index.ts
│   │   ├── {home.服务A}.service.ts
│   │   ├── {home.服务B}.service.ts
│   │   └── types.ts
│   ├── {模块A}/                           # 模块A服务模块
│   │   ├── index.ts
│   │   ├── {模块A.服务1}.service.ts
│   │   ├── {模块A.服务2}.service.ts
│   │   ├── {模块A.服务3}.service.ts
│   │   ├── {模块A.服务4}.service.ts
│   │   └── types.ts
│   ├── {模块B}/                           # 模块B服务模块
│   │   ├── index.ts
│   │   ├── {模块B.服务1}.service.ts
│   │   ├── {模块B.服务2}.service.ts
│   │   ├── {模块B.服务3}.service.ts
│   │   └── types.ts
│   ├── {模块C}/                           # 模块C服务模块
│   │   ├── index.ts
│   │   ├── {模块C.服务1}.service.ts
│   │   ├── {模块C.服务2}.service.ts
│   │   └── types.ts
│   ├── {模块D}/                           # 模块D服务模块
│   │   ├── index.ts
│   │   ├── {模块D.服务1}.service.ts
│   │   ├── {模块D.服务2}.service.ts
│   │   ├── {模块D.服务3}.service.ts
│   │   └── types.ts
│   └── shared/                            # 共享服务
│       ├── index.ts
│       ├── {shared.通用服务1}.service.ts
│       ├── {shared.通用服务2}.service.ts
│       └── types.ts
├── stores/                                # 状态管理（按页面系统分区）
│   ├── {模块A}/                           # 模块A状态模块
│   │   ├── index.ts
│   │   ├── {模块A.状态1}.store.ts
│   │   ├── {模块A.状态2}.store.ts
│   │   ├── {模块A.状态3}.store.ts
│   │   └── types.ts
│   ├── {模块B}/                           # 模块B状态模块
│   │   ├── index.ts
│   │   ├── {模块B.状态1}.store.ts
│   │   ├── {模块B.状态2}.store.ts
│   │   └── types.ts
│   ├── {模块C}/                           # 模块C状态模块
│   │   ├── index.ts
│   │   ├── {模块C.状态1}.store.ts
│   │   ├── {模块C.状态2}.store.ts
│   │   └── types.ts
│   ├── {模块D}/                           # 模块D状态模块
│   │   ├── index.ts
│   │   ├── {模块D.状态1}.store.ts
│   │   ├── {模块D.状态2}.store.ts
│   │   └── types.ts
│   └── index.ts                           # 状态管理入口
├── Utils/                                 # 工具函数（按页面系统分区）
│   ├── {模块A}/                           # 模块A工具模块
│   │   ├── index.ts
│   │   ├── {模块A.工具1}.utils.ts
│   │   ├── {模块A.工具2}.utils.ts
│   │   ├── {模块A.工具3}.utils.ts
│   │   └── types.ts
│   ├── {模块B}/                           # 模块B工具模块
│   │   ├── index.ts
│   │   ├── {模块B.工具1}.utils.ts
│   │   ├── {模块B.工具2}.utils.ts
│   │   └── types.ts
│   ├── {模块C}/                           # 模块C工具模块
│   │   ├── index.ts
│   │   ├── {模块C.工具1}.utils.ts
│   │   ├── {模块C.工具2}.utils.ts
│   │   └── types.ts
│   ├── {模块D}/                           # 模块D工具模块
│   │   ├── index.ts
│   │   ├── {模块D.工具1}.utils.ts
│   │   ├── {模块D.工具2}.utils.ts
│   │   └── types.ts
│   └── shared/                            # 共享工具
│       ├── index.ts
│       ├── {shared.通用工具1}.utils.ts
│       ├── {shared.通用工具2}.utils.ts
│       └── types.ts
└── boot/                                  # 启动文件
    ├── {框架初始化1}.ts
    ├── {框架初始化2}.ts
    ├── {框架初始化3}.ts
    └── {项目初始化}.boot.ts
```

## 🗂️ **Backend 抽象架构目录（仅框架）**

```
Backend/
├── {后端技术栈1}/                          # 后端服务1
│   ├── {应用结构}/                         # 应用架构
│   │   ├── __init__.py
│   │   ├── {配置文件}
│   │   ├── {模型层}/
│   │   ├── {路由层}/
│   │   ├── {服务层}/
│   │   └── {工具层}/
│   ├── {入口文件}
│   ├── {依赖文件}
│   └── README.md
└── {外部工具集成}/                         # 工具集成
    ├── {工具1}/                           # 外部工具1
    ├── {工具2}/                           # 外部工具2
    ├── {工具3}/                           # 外部工具3
    └── README.md
```

## electron层 抽象架构目录
src-electron/
├── core/                           # 核心主进程
│   ├── electron-main.ts           # 主进程入口
│   ├── electron-preload.ts        # 预加载脚本
│   └── {app-manager}.ts           # 应用核心管理器

├── init/                           # 启动时一次性初始化
│   ├── {database-init}.ts          # 数据库初始化和迁移
│   ├── {directory-setup}.ts        # 文件目录结构创建
│   ├── {config-validation}.ts      # 配置文件验证和创建
│   ├── {external-tools-check}.ts   # 外部工具可用性检查
│   └── index.ts                    # 初始化流程协调器

├── lifecycle/                      # 应用生命周期和时序管理
│   ├── {app-lifecycle}.ts          # 应用整体生命周期管理
│   ├── {process-coordinator}.ts    # 进程协调器
│   ├── {startup-sequence}.ts       # 启动时序控制
│   ├── {shutdown-sequence}.ts      # 关闭时序控制
│   ├── {health-monitor}.ts         # 服务健康监控和自动重启
│   └── index.ts                    # 生命周期管理入口

├── services/                       # 持续运行的服务
│   ├── {database-service}/         # 数据库服务
│   │   ├── {sqlite-manager}.ts
│   │   ├── {migration-service}.ts
│   │   └── types.ts
│   ├── {window-service}/           # 窗口管理服务
│   │   ├── {window-manager}.ts
│   │   ├── {multi-window}.ts
│   │   └── types.ts
│   ├── {file-service}/             # 文件管理服务
│   │   ├── {file-operations}.ts
│   │   ├── {drag-drop-handler}.ts
│   │   ├── {dialog-service}.ts
│   │   └── types.ts
│   ├── {webview-service}/          # WebView 管理服务
│   │   ├── {webview-manager}.ts
│   │   ├── {cookie-manager}.ts
│   │   ├── {session-manager}.ts
│   │   └── types.ts
│   └── shared/
│       ├── {base-service}.ts       # 服务基类
│       └── types.ts

├── adapters/                       # 外部系统适配器
│   ├── {external-process}/         # 外部进程适配器
│   │   ├── {process-launcher}.ts
│   │   ├── {process-communicator}.ts
│   │   ├── {ragflow-adapter}.ts    # 具体外部工具适配
│   │   └── types.ts
│   ├── {web-integration}/          # Web 集成适配器
│   │   ├── {crawler-integration}.ts
│   │   ├── {element-selector}.ts   # DevTools 式元素选择
│   │   ├── {page-inspector}.ts
│   │   └── types.ts
│   └── {tool-integration}/         # 工具集成适配器
│       ├── {tool-registry}.ts
│       ├── {tool-launcher}.ts
│       └── types.ts

├── ipc/                            # 进程间通信
│   ├── {main-renderer}/            # 主进程-渲染进程通信
│   │   ├── {ipc-handlers}.ts
│   │   ├── {channel-definitions}.ts
│   │   └── types.ts
│   ├── {external-process}/         # 外部进程通信
│   │   ├── {process-bridge}.ts
│   │   ├── {message-queue}.ts
│   │   └── types.ts
│   └── {webview-bridge}/           # WebView 桥接通信
│       ├── {webview-ipc}.ts
│       ├── {content-script}.ts
│       └── types.ts

├── utils/                          # 工具函数
│   ├── {system-utils}/             # 系统相关工具
│   │   ├── {path-resolver}.ts
│   │   ├── {process-utils}.ts
│   │   └── {platform-detector}.ts
│   ├── {security-utils}/           # 安全相关工具
│   │   ├── {permission-handler}.ts
│   │   ├── {sandbox-manager}.ts
│   │   └── {content-security}.ts
│   └── shared/
│       ├── {logger}.ts
│       ├── {config-manager}.ts
│       └── types.ts

└── domain/                         # 领域模型和业务逻辑
    ├── {project-management}/       # 项目管理领域
    │   ├── {project-model}.ts
    │   ├── {workspace-model}.ts
    │   └── types.ts
    ├── {tool-integration}/         # 工具集成领域
    │   ├── {tool-model}.ts
    │   ├── {integration-model}.ts
    │   └── types.ts
    └── shared/
        ├── {base-models}.ts
        └── types.ts

### electron-main.ts → lifecycle/startup-sequence.ts → init/ → services/ → 应用就绪
### 要点讲解
domain/ 是领域驱动设计(DDD)的概念，在 Electron 应用中主要负责：
1. 业务领域抽象
定义核心业务概念和实体
封装业务规则和领域逻辑
与具体的技术实现解耦
2. 具体职责示例
3. 为什么需要 domain/
业务逻辑集中：避免业务规则散落在各个服务中
技术无关：纯业务逻辑，不依赖 Electron API
复用性强：可被多个服务层复用
测试友好：纯函数逻辑，易于单元测试
---


---

## 📋 **窗口服务与 Electron Tabs 特化**

如果使用 **Electron Tabs**，窗口服务确实需要特化：

### **传统多窗口 vs Tabs 架构差异**

**传统多窗口模式：**
```typescript
// services/window-service/window-manager.ts
class WindowManager {
  createWindow(options: WindowOptions): BrowserWindow
  closeWindow(windowId: string): void
  switchToWindow(windowId: string): void
  // 每个窗口独立的 BrowserWindow 实例
}
```

**Electron Tabs 特化版本：**
```typescript
// services/window-service/tab-manager.ts
class TabManager {
  createTab(url: string, options: TabOptions): Tab
  closeTab(tabId: string): void
  switchToTab(tabId: string): void
  moveTab(tabId: string, newIndex: number): void
  // 单个主窗口，多个 Tab 实例
}
```

### **Tabs 模式需要的特化功能**

**1. Tab 生命周期管理**
```
services/window-service/
├── {tab-manager}.ts              # Tab 创建、销毁、切换
├── {tab-lifecycle}.ts            # Tab 生命周期钩子
├── {tab-session-manager}.ts      # 每个 Tab 的会话管理
├── {tab-memory-manager}.ts       # Tab 内存优化（休眠/唤醒）
└── {tab-communication}.ts        # Tab 间通信协调
```

**2. 特化的窗口服务架构**
```
services/window-service/
├── {main-window-manager}.ts      # 主窗口管理
├── {tab-container}.ts            # Tab 容器管理
├── {tab-bar-controller}.ts       # Tab 栏控制器
├── {tab-content-manager}.ts      # Tab 内容区域管理
├── {tab-context-menu}.ts         # Tab 右键菜单
├── {tab-drag-drop}.ts            # Tab 拖拽重排
└── types.ts
```

### **关键特化点**

**1. 内存管理优化**
- 非活跃 Tab 的内容暂停/休眠
- 限制同时活跃的 Tab 数量
- 智能预加载机制

**2. 会话隔离**
- 每个 Tab 独立的 Session
- Cookie 和缓存隔离
- 权限独立管理

**3. 通信机制**
- Tab 与主进程的独立通信通道
- Tab 间数据共享机制
- 全局状态与 Tab 状态协调

**4. 用户体验增强**
- Tab 标题动态更新
- Tab 图标和状态指示
- Tab 快捷键支持
- Tab 拖拽排序

### **是否需要特化的建议**

**需要特化的情况：**
- ✅ 需要多个 WebView 或网页同时运行
- ✅ 用户需要在不同工具间快速切换
- ✅ 需要会话隔离（不同网站的登录状态）
- ✅ 内存优化要求较高

**可以不特化的情况：**
- ❌ 主要是单页面应用
- ❌ 不需要多任务并行
- ❌ 简单的工具集成





---
## ⚙️ **配置修改项**

### **quasar.config.ts 抽象路径别名**

```typescript
const alias = [
  // 基础别名（保持 Quasar 模板兼容性）
  { find: 'src/css', replacement: path.resolve(__dirname, 'Client/GUI/css') },
  { find: 'src/boot', replacement: path.resolve(__dirname, 'Client/boot') },
  { find: 'src', replacement: path.resolve(__dirname, 'Client') },
  { find: 'app/src', replacement: path.resolve(__dirname, 'Client') },
  { find: 'app', replacement: path.resolve(__dirname, '.') },
  
  // GUI 层别名
  { find: 'layouts', replacement: path.resolve(__dirname, 'Client/GUI/layouts') },
  { find: 'pages', replacement: path.resolve(__dirname, 'Client/GUI/PagesLayout') },
  { find: 'components', replacement: path.resolve(__dirname, 'Client/GUI/components') },
  { find: 'assets', replacement: path.resolve(__dirname, 'Client/GUI/assets') },
  { find: 'css', replacement: path.resolve(__dirname, 'Client/GUI/css') },
  
  // 核心功能别名
  { find: 'boot', replacement: path.resolve(__dirname, 'Client/boot') },
  { find: '@service', replacement: path.resolve(__dirname, 'Client/Service') },
  { find: '@stores', replacement: path.resolve(__dirname, 'Client/stores') },
  { find: '@utils', replacement: path.resolve(__dirname, 'Client/Utils') },
  { find: '@gui', replacement: path.resolve(__dirname, 'Client/GUI') },
  
  // 系统入口别名
  { find: '@index', replacement: path.resolve(__dirname, 'Client/GUI/Index') },
  { find: '@pages', replacement: path.resolve(__dirname, 'Client/GUI/PagesLayout') },
  
  // 业务模块通用别名（按需扩展）
  { find: '@{业务模块}', replacement: path.resolve(__dirname, 'Client/Service/{业务模块}') },
  // 实际使用时替换为具体模块名，如：
  // { find: '@moduleA', replacement: path.resolve(__dirname, 'Client/Service/moduleA') },
  // { find: '@moduleB', replacement: path.resolve(__dirname, 'Client/Service/moduleB') },
  
  // 共享资源别名
  { find: '@shared', replacement: path.resolve(__dirname, 'Client/Service/shared') },
  { find: '@shared-utils', replacement: path.resolve(__dirname, 'Client/Utils/shared') },
  { find: '@shared-stores', replacement: path.resolve(__dirname, 'Client/stores') }
];
```

### **资源映射抽象配置**

```typescript
const extraResourceMappings: ResourceMapping[] = [
  { from: 'Backend/{外部工具集成}/{工具1}', to: 'backend/{工具1}' },
  { from: 'Backend/{外部工具集成}/{工具2}', to: 'backend/{工具2}' },
  { from: 'Backend/{外部工具集成}/{工具3}', to: 'backend/{工具3}' },
  { from: 'Backend/{后端技术栈1}', to: 'backend/{服务名}' }
];
```

