## 📐 **LlmTranslate 类型系统规范**

### **核心设计理念**

```
🎯 职责明确：前端类型 ↔ IPC 转发 ↔ 后端事件
🎯 单向依赖：后端导入前端类型，前端永不导入后端类型
🎯 别名转发：所有跨进程导入统一通过中转层
🎯 分离私有：服务内部类型不暴露给 IPC 层
```

---

### **目录结构及文件职责**

#### **第1层：前端类型定义**
📍 **位置：** `Nimbria/Client/GUI/DemoPage/LlmTranslate/types/`

```
LlmTranslate/types/
├── index.ts          ⭐ 统一导出口，所有类型从这里出
├── config.ts         【核心】用户填写的配置 + BatchConfig + 导出配置
├── batch.ts          【核心】批次数据结构 + BatchStats
├── task.ts           【核心】任务数据结构 + TaskMetadata
└── api.ts            【核心】IPC API 请求/响应类型
```

**文件职责详解：**

| 文件 | 职责 | 谁使用 | 导出内容 |
|------|------|--------|--------|
| `config.ts` | **原点：** 用户在 HomePage 填写表单时的类型源头 | 前端Store、后端IPC、后端Service | `TranslateConfig`, `BatchConfig`, `ExportConfig` |
| `batch.ts` | **数据库映射：** 前端渲染批次卡片 | 前端组件、后端IPC | `Batch`, `BatchStats`, `BatchStatus` |
| `task.ts` | **任务详情：** 每个任务的完整数据（含元数据） | 前端组件、后端IPC | `Task`, `TaskMetadata`, `TaskStatus` |
| `api.ts` | **契约定义：** IPC 请求和响应的格式 | IPC Handler、前端Datasource | API 类型 |

**规范：** 这里的类型 **绝不涉及** 后端的服务逻辑或事件，只定义数据结构。

---

#### **第2层：后端类型转发（桥接层）**
📍 **位置：** `Nimbria/src-electron/types/LlmTranslate/`

```
LlmTranslate/
├── index.ts          ⭐ 根导出口（export client 和 backend）
├── client/
│   └── index.ts      🌉 将前端类型通过别名重新导出给后端
└── backend/
    ├── index.ts      【根导出】
    ├── events.ts     【后端独有】事件类型（外部不应使用）
    └── database.ts   【后端独有】数据库行结构（外部不应使用）
```

**client/index.ts 的作用：**
```typescript
// ✅ 别名导入前端路径
export type { TranslateConfig, Batch, Task, ... } from '@demo/LlmTranslate/types'

// 📝 注释明确标注：这些是前端定义的，我只是转发
```

**backend/events.ts 的作用：**
```typescript
// ❌ 这里定义的事件类型绝不导出
export interface BatchCreatedEvent { ... }      // 只在 llm-translate-service 内部和 handlers 中使用
export interface TaskProgressEvent { ... }      // 不通过 client/index.ts 导出
```

**为什么要有这个桥接层：**
1. **清晰职责：** 开发者看到 `src-electron/types/LlmTranslate` 就知道这是 LlmTranslate 的完整类型
2. **易于迁移：** 如果前端类型路径改了，只需改一个文件
3. **防止混乱：** 后端 Service 导入自己的类型时，不会搞混路径

---

#### **第3层：前端 Store 和 Datasource**
📍 **位置：** `Nimbria/Client/GUI/DemoPage/LlmTranslate/stores/`

```
stores/
├── index.ts                      【Store 导出】
├── translate.store.ts            【Pinia Store】核心状态管理
├── translate.datasource.ts       【IPC 适配层】
├── translate.mock.ts             【Mock 数据】
├── translate.types.ts            【Store 内部状态类型】
└── types/
    ├── state.ts                  【可选】如果 types.ts 太大可拆分
    ├── operations.ts             【可选】操作相关类型
    └── context.ts                【可选】上下文类型
```

**类型导入规范：**
```typescript
// ✅ 从前端类型导入（这是源头）
import type { Batch, Task, TranslateConfig } from '../types'

// ❌ 严禁导入后端类型
import type { BatchCreatedEvent } from 'src-electron/types/LlmTranslate/backend'  // 🚫
```

---

#### **第4层：后端 Service 层**
📍 **位置：** `Nimbria/src-electron/services/llm-translate-service/`

```
llm-translate-service/
├── llm-translate-service.ts      【Service 主类】
├── types.ts                      【私有类型】不暴露，不导出
└── utils/                         【工具函数】
```

**Service 内部的类型导入规范：**
```typescript
// ✅ 导入前端定义的数据结构
import type { Batch, Task, TranslateConfig, BatchConfig } from '../../types/LlmTranslate'

// ✅ 导入后端事件类型（私有）
import type { BatchCreatedEvent } from '../../types/LlmTranslate/backend'

// ❌ 不要导入 Service 自己目录下的 types.ts
import type { SomeInternalType } from './types'  // 🚫 除非是真正内部使用
```

---

#### **第5层：IPC Handler 层**
📍 **位置：** `Nimbria/src-electron/ipc/main-renderer/llm-translate-handlers.ts`

```typescript
/**
 * IPC 的职责：充当翻译官
 * - 接收 IPC 请求（请求类型来自 types/api.ts）
 * - 调用 Service 执行业务逻辑
 * - 返回 IPC 响应
 */

// ✅ 导入规范
import type { TranslateConfig, Batch, Task } from '../../types/LlmTranslate'
import type { BatchCreatedEvent } from '../../types/LlmTranslate/backend'
import type { LlmTranslateService } from '../../services/llm-translate-service/llm-translate-service'
```

---

### **完整调用链：从前端到后端**

```
┌─────────────────────────────────────────────────────────┐
│ 1️⃣  前端 HomePage 表单                                  │
│    （用户填写配置）                                       │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ├─ 组装 TranslateConfig 对象
                   │   来源: types/config.ts
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│ 2️⃣  前端 Store (translate.store.ts)                     │
│    （调用 Datasource.createBatch()）                    │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ├─ 转换 Proxy → Plain Object
                   │   使用 JSON.parse(JSON.stringify())
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│ 3️⃣  Datasource (translate.datasource.ts)                │
│    （通过 IPC 发送请求）                                │
│                                                         │
│    electronAPI.createBatch({ config: plainConfig })    │
└──────────────────┬──────────────────────────────────────┘
                   │
        ════════════ IPC 边界 ════════════
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│ 4️⃣  IPC Handler (llm-translate-handlers.ts)             │
│    监听 'create-batch' 通道                              │
│                                                         │
│    ipcMain.handle('create-batch', (event, args) => {  │
│      return llmTranslateService.createBatchAsync()    │
│    })                                                  │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ├─ 提取 config: TranslateConfig
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│ 5️⃣  Service (llm-translate-service.ts)                  │
│    （执行业务逻辑）                                      │
│                                                         │
│    createBatchAsync(config: TranslateConfig) {        │
│      - 提取 BatchConfig                               │
│      - 分片内容                                        │
│      - 创建 Task 对象（含 TaskMetadata）              │
│      - 写入数据库                                      │
│      - 发出事件 ('batch:created')                     │
│      - 返回 Batch 对象                                │
│    }                                                   │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ├─ 发出事件给所有窗口
                   │   event: 'batch:created'
                   │   data: BatchCreatedEvent
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│ 6️⃣  IPC Handler 事件广播                                │
│    （向所有渲染窗口广播事件）                            │
│                                                         │
│    llmTranslateService.on('batch:created', (data) => {│
│      BrowserWindow.getAllWindows().forEach(win => {   │
│        win.webContents.send('llm-translate:batch-..', data)
│      })                                                │
│    })                                                  │
└──────────────────┬──────────────────────────────────────┘
                   │
        ════════════ IPC 边界 ════════════
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│ 7️⃣  前端监听事件 (translate.store.ts)                   │
│    （更新前端状态）                                      │
│                                                         │
│    electronAPI.on('llm-translate:batch-created', ...) │
│      ↓                                                 │
│      更新 store.batchList                             │
└─────────────────────────────────────────────────────────┘
```

---

### **别名配置详解**

**📍 在 `tsconfig.json` 中定义：**
```json
{
  "paths": {
    "@demo": ["Client/GUI/DemoPage"],
    "@demo/*": ["Client/GUI/DemoPage/*"]
  }
}
```

**✅ 正确使用别名：**

| 位置 | 导入语句 | 解析为 |
|------|---------|------|
| 前端组件 | `import type { Batch } from '@demo/LlmTranslate/types'` | `Client/GUI/DemoPage/LlmTranslate/types/index.ts` |
| 后端 client/index.ts | `export from '@demo/LlmTranslate/types'` | 同上 |
| 后端 Service | `import type { Batch } from '../../types/LlmTranslate'` | `src-electron/types/LlmTranslate/client/index.ts` |

**❌ 错误用法：**
```typescript
// ❌ 直接导入后端路径（不走别名）
import { Batch } from 'src-electron/types/LlmTranslate'

// ❌ 跨越转发层直接导入前端
import { Batch } from 'Client/GUI/DemoPage/LlmTranslate/types'  // 在后端中
```

---

### **数据流与类型映射**

```
用户输入表单
    ↓
TranslateConfig（前端 types/config.ts）
    ↓ [IPC]
IPC Request: CreateBatchRequest（前端 types/api.ts）
    ↓ [Handler]
提取 content + BatchConfig
    ↓ [Service]
1. 分片内容得到多个 chunk
2. 为每个 chunk 创建 Task：
   {
     id: '...',
     content: chunk,
     metadataJson: JSON.stringify({
       systemPrompt: config.systemPrompt,
       modelId: config.modelId,
       ...
     })
   }
3. 批量插入数据库 Llmtranslate_tasks
    ↓ [发出事件]
BatchCreatedEvent（后端 backend/events.ts）
    ↓ [IPC 广播]
win.webContents.send('llm-translate:batch-created')
    ↓ [前端监听]
更新 store.batchList: Batch[]
```

---

### **常见错误模式 ❌ 和纠正方法 ✅**

#### **错误1：前端导入后端类型**
```typescript
// ❌ 前端组件中
import { BatchCreatedEvent } from '../../backend/types'

// ✅ 正确做法
// 后端事件只在后端处理，前端无需导入
// 前端通过 IPC 消息接收数据，类型由 api.ts 定义
```

#### **错误2：后端直接导入前端路径**
```typescript
// ❌ 后端 Service 中
import { Batch } from 'Client/GUI/DemoPage/LlmTranslate/types'

// ✅ 正确做法
import type { Batch } from '../../types/LlmTranslate'
// 这样导入的是 src-electron/types/LlmTranslate/client/index.ts
// 它在底层转发了前端类型，但开发者看起来"用的就是后端的"
```

#### **错误3：Service 内部类型暴露**
```typescript
// ❌ src-electron/services/llm-translate-service/types.ts
export interface InternalChunkTask { ... }

// 然后在 IPC Handler 中
import { InternalChunkTask } from '../services/llm-translate-service/types'

// ✅ 正确做法
// 把需要跨层共享的类型放到 src-electron/types/LlmTranslate/backend/
// Service 内部私有的类型直接在 service.ts 中定义或使用
```

#### **错误4：IPC API 类型定义混乱**
```typescript
// ❌ 没有统一的 API 类型定义
// Store 直接调用 electronAPI.createBatch(config)
// 没有约定请求/响应格式

// ✅ 正确做法
// types/api.ts 中定义
export interface CreateBatchRequest {
  config: TranslateConfig
}
export interface CreateBatchResponse {
  batch: Batch
}

// Store 中
const result: CreateBatchResponse = await electronAPI.createBatch(request)
```

---

### **新增模块时的模板**

当需要新增一个功能模块（如 `OtherFeature`）时：

```
1️⃣  前端类型（前端自己维护）
   Client/GUI/DemoPage/OtherFeature/types/
   ├── index.ts
   ├── config.ts        【配置类型】
   ├── models.ts        【数据模型】
   └── api.ts           【IPC 接口】

2️⃣  后端转发（后端维护）
   src-electron/types/OtherFeature/
   ├── index.ts
   ├── client/index.ts  【转发前端类型】
   └── backend/
       ├── index.ts
       ├── events.ts    【后端事件】
       └── database.ts  【DB 结构】

3️⃣  导入规范
   前端：from '@demo/OtherFeature/types'
   后端：from '../../types/OtherFeature'
```

---

### **检查清单 ✅**

创建新模块或修改类型时，检查以下项：

- [ ] 前端类型是否都在 `Client/GUI/DemoPage/<Module>/types/` 中？
- [ ] 后端是否通过 `src-electron/types/<Module>/client/` 转发？
- [ ] 后端独有的类型（事件、DB）是否在 `backend/` 中？
- [ ] Service 内部类型是否未被暴露？
- [ ] IPC API 类型是否在 `api.ts` 中定义？
- [ ] 所有导入是否都使用了别名或正确的相对路径？
- [ ] 前端是否有导入后端类型？（应该没有）
- [ ] 是否有重复定义相同类型？

