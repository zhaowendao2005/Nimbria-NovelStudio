# 事件驱动架构范式总结文档

**版本**: v1.0  
**创建时间**: 2025年10月15日  
**适用场景**: Electron 主进程服务 + IPC 通信  

---

## 📋 问题根源

### 传统回调模式的问题

```typescript
// ❌ 问题代码
ipcMain.handle('service:action', async (event, args) => {
  const result = await service.doSomething(args, {
    onProgress: (data) => {
      // 问题：result 在 await 完成前未初始化
      event.sender.send('service:progress', { id: result.id, data })
    }
  })
  return { success: true, id: result.id }
})
```

**核心问题**：
1. **循环依赖**：回调需要使用尚未返回的值（如 `messageId`）
2. **职责混乱**：IPC Handler 既要调用服务，又要处理业务回调
3. **单窗口限制**：回调只能发送到当前窗口
4. **难以测试**：Service 层耦合了 IPC 逻辑

---

## ✅ 事件驱动架构解决方案

### 核心原则

1. **Service 层纯净**：只负责业务逻辑，通过事件发射状态
2. **IPC 层薄薄的**：只负责监听事件并转发，不参与业务
3. **立即返回标识**：需要的 ID 在方法开始时立即生成并返回
4. **事件解耦通信**：用事件代替回调传递进度/状态

---

## 🏗️ 标准实现模板

### 1. Service 层设计

```typescript
import { EventEmitter } from 'events'

// 定义事件数据类型
export interface ActionStartEvent {
  actionId: string
  // ... 其他字段
}

export interface ActionProgressEvent {
  actionId: string
  progress: number
  data: any
}

export interface ActionCompleteEvent {
  actionId: string
  result: any
}

export interface ActionErrorEvent {
  actionId: string
  error: string
}

// Service 继承 EventEmitter
export class MyService extends EventEmitter {
  /**
   * 执行操作（立即返回 actionId）
   */
  async doSomething(params: any): Promise<string> {
    // ✅ 1. 立即生成并返回 ID
    const actionId = `action_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`
    
    // ✅ 2. 发射开始事件
    this.emit('action:start', {
      actionId,
      ...params
    } as ActionStartEvent)
    
    // ✅ 3. 异步处理，不阻塞返回
    this.processAsync(actionId, params)
    
    return actionId
  }
  
  /**
   * 私有方法：异步处理业务逻辑
   */
  private async processAsync(actionId: string, params: any): Promise<void> {
    try {
      // 业务逻辑...
      
      // ✅ 通过事件发射进度
      this.emit('action:progress', {
        actionId,
        progress: 50,
        data: { /* ... */ }
      } as ActionProgressEvent)
      
      // 完成时发射完成事件
      this.emit('action:complete', {
        actionId,
        result: { /* ... */ }
      } as ActionCompleteEvent)
      
    } catch (error: any) {
      // ✅ 错误也通过事件传递
      this.emit('action:error', {
        actionId,
        error: error.message
      } as ActionErrorEvent)
    }
  }
}
```

---

### 2. IPC Handler 层设计

```typescript
import { ipcMain, BrowserWindow } from 'electron'
import type { MyService } from '../services/my-service'

export function registerMyServiceHandlers(myService: MyService) {
  // ========== 事件监听器（只在注册时执行一次） ==========
  
  myService.on('action:start', (data: ActionStartEvent) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('my-service:action-start', data)
    })
  })
  
  myService.on('action:progress', (data: ActionProgressEvent) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('my-service:action-progress', data)
    })
  })
  
  myService.on('action:complete', (data: ActionCompleteEvent) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('my-service:action-complete', data)
    })
  })
  
  myService.on('action:error', (data: ActionErrorEvent) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('my-service:action-error', data)
    })
  })
  
  // ========== IPC Handlers（纯调用） ==========
  
  ipcMain.handle('my-service:do-something', async (event, args) => {
    try {
      const actionId = await myService.doSomething(args)
      return { success: true, actionId }
    } catch (error: any) {
      return { success: false, error: error.message }
    }
  })
  
  console.log('MyService IPC handlers registered')
}
```

---

### 3. 前端 Store 设计

```typescript
// Pinia Store
export const useMyServiceStore = defineStore('myService', () => {
  const activeActions = ref<Map<string, ActionState>>(new Map())
  
  // 执行操作
  async function doSomething(params: any) {
    const result = await window.api.myService.doSomething(params)
    if (result.success) {
      // 初始化本地状态
      activeActions.value.set(result.actionId, {
        id: result.actionId,
        status: 'running',
        progress: 0
      })
      return result.actionId
    }
    return null
  }
  
  // 设置事件监听器（在 onMounted 中调用）
  function setupListeners() {
    window.api.myService.onActionStart((data) => {
      console.log('Action started:', data.actionId)
    })
    
    window.api.myService.onActionProgress((data) => {
      const action = activeActions.value.get(data.actionId)
      if (action) {
        action.progress = data.progress
        action.data = data.data
      }
    })
    
    window.api.myService.onActionComplete((data) => {
      const action = activeActions.value.get(data.actionId)
      if (action) {
        action.status = 'completed'
        action.result = data.result
      }
    })
    
    window.api.myService.onActionError((data) => {
      const action = activeActions.value.get(data.actionId)
      if (action) {
        action.status = 'error'
        action.error = data.error
      }
    })
  }
  
  return {
    activeActions,
    doSomething,
    setupListeners
  }
})
```

---

## 📊 架构对比

| **维度** | **传统回调模式** | **事件驱动模式** |
|---------|----------------|----------------|
| **ID 生成时机** | await 完成后 ❌ | 方法开始时 ✅ |
| **Service 职责** | 业务 + IPC 回调 | 纯业务逻辑 ✅ |
| **IPC Handler 职责** | 调用 + 回调传递 | 纯事件转发 ✅ |
| **多窗口支持** | 需手动处理 | 自动广播 ✅ |
| **可测试性** | 需 mock IPC | 只需 mock EventEmitter ✅ |
| **可扩展性** | 改动多处 | 添加监听器 ✅ |
| **循环依赖** | 存在 ❌ | 无 ✅ |

---

## 🎯 实施步骤

### Step 1: 定义事件类型

```typescript
// types.ts
export interface XxxStartEvent { id: string; ... }
export interface XxxProgressEvent { id: string; progress: number; ... }
export interface XxxCompleteEvent { id: string; result: any }
export interface XxxErrorEvent { id: string; error: string }
```

### Step 2: Service 继承 EventEmitter

```typescript
import { EventEmitter } from 'events'

export class MyService extends EventEmitter {
  async action(params: any): Promise<string> {
    const id = generateId()
    this.emit('action:start', { id })
    this.processAsync(id, params)
    return id  // 立即返回
  }
  
  private async processAsync(id: string, params: any) {
    // 业务逻辑
    // 通过 this.emit() 发射事件
  }
}
```

### Step 3: IPC Handler 注册事件监听

```typescript
export function registerHandlers(service: MyService) {
  // 事件监听器
  service.on('action:start', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('service:action-start', data)
    })
  })
  
  // IPC Handlers
  ipcMain.handle('service:action', async (event, args) => {
    const id = await service.action(args)
    return { success: true, id }
  })
}
```

### Step 4: 前端设置监听器

```typescript
// Store 中
function setupListeners() {
  window.api.service.onActionStart((data) => { /* ... */ })
  window.api.service.onActionProgress((data) => { /* ... */ })
  window.api.service.onActionComplete((data) => { /* ... */ })
  window.api.service.onActionError((data) => { /* ... */ })
}

// 组件挂载时调用
onMounted(() => {
  store.setupListeners()
})
```

---

## ⚠️ 注意事项

### 1. 事件监听器只注册一次

```typescript
// ✅ 正确：在 registerHandlers 函数中注册
export function registerHandlers(service: MyService) {
  service.on('action:progress', handleProgress)  // 只执行一次
}

// ❌ 错误：在 IPC Handler 中注册
ipcMain.handle('service:action', async () => {
  service.on('action:progress', handleProgress)  // 每次调用都注册！
})
```

### 2. 事件名称约定

```typescript
// Service 事件：使用冒号分隔
'action:start'
'action:progress'
'action:complete'
'action:error'

// IPC 通道名：使用短横线分隔
'service:action-start'
'service:action-progress'
'service:action-complete'
'service:action-error'
```

### 3. ID 生成策略

```typescript
// ✅ 推荐：时间戳 + 随机字符串
const id = `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`

// ✅ 也可使用 nanoid
import { nanoid } from 'nanoid'
const id = nanoid()
```

### 4. 错误处理

```typescript
private async processAsync(id: string, params: any) {
  try {
    // 业务逻辑
  } catch (error: any) {
    // ✅ 错误也通过事件传递
    this.emit('action:error', {
      id,
      error: error.message
    })
  }
}
```

---

## 🔍 调试技巧

### 1. 添加日志监听器

```typescript
// 在开发环境添加调试监听器
if (process.env.NODE_ENV === 'development') {
  service.on('action:start', (data) => {
    console.log('[Service] Action started:', data)
  })
  service.on('action:progress', (data) => {
    console.log('[Service] Progress:', data)
  })
  service.on('action:complete', (data) => {
    console.log('[Service] Completed:', data)
  })
}
```

### 2. 检查事件监听器数量

```typescript
// 防止内存泄漏
console.log('Listeners count:', service.listenerCount('action:progress'))

// 设置最大监听器数量
service.setMaxListeners(20)
```

---

## 📚 实际案例参考

### 案例：LLM Chat 流式响应

**文件位置**：
- `Nimbria/src-electron/services/llm-chat-service/llm-chat-service.ts`
- `Nimbria/src-electron/ipc/main-renderer/llm-chat-handlers.ts`

**关键代码**：
```typescript
// Service
async sendMessage(conversationId: string, content: string): Promise<string> {
  const messageId = `msg_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`
  this.emit('message:start', { conversationId, messageId })
  this.processStreamAsync(conversationId, messageId, content)
  return messageId
}

// IPC Handler
llmChatService.on('message:chunk', (data) => {
  BrowserWindow.getAllWindows().forEach(win => {
    win.webContents.send('llm-chat:stream-chunk', data)
  })
})
```

---

## 🎓 核心要点总结

1. ✅ **Service 继承 EventEmitter**
2. ✅ **立即生成并返回 ID**
3. ✅ **通过事件发射状态，不用回调**
4. ✅ **IPC Handler 只监听事件并转发**
5. ✅ **事件监听器只注册一次**
6. ✅ **支持多窗口自动广播**
7. ✅ **解耦、可测试、可扩展**

---

**适用场景**：
- ✅ 流式响应（LLM、文件下载、数据处理）
- ✅ 长时间异步任务（构建、编译、转换）
- ✅ 需要进度反馈的操作
- ✅ 多窗口同步状态

**不适用场景**：
- ❌ 简单的同步调用
- ❌ 不需要进度反馈的快速操作

---

**最后更新**: 2025年10月15日  
**版本**: v1.0  
**负责人**: Nimbria 开发团队