# äº‹ä»¶é©±åŠ¨æ¶æ„èŒƒå¼æ€»ç»“æ–‡æ¡£

**ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025å¹´10æœˆ15æ—¥  
**é€‚ç”¨åœºæ™¯**: Electron ä¸»è¿›ç¨‹æœåŠ¡ + IPC é€šä¿¡  

---

## ğŸ“‹ é—®é¢˜æ ¹æº

### ä¼ ç»Ÿå›è°ƒæ¨¡å¼çš„é—®é¢˜

```typescript
// âŒ é—®é¢˜ä»£ç 
ipcMain.handle('service:action', async (event, args) => {
  const result = await service.doSomething(args, {
    onProgress: (data) => {
      // é—®é¢˜ï¼šresult åœ¨ await å®Œæˆå‰æœªåˆå§‹åŒ–
      event.sender.send('service:progress', { id: result.id, data })
    }
  })
  return { success: true, id: result.id }
})
```

**æ ¸å¿ƒé—®é¢˜**ï¼š
1. **å¾ªç¯ä¾èµ–**ï¼šå›è°ƒéœ€è¦ä½¿ç”¨å°šæœªè¿”å›çš„å€¼ï¼ˆå¦‚ `messageId`ï¼‰
2. **èŒè´£æ··ä¹±**ï¼šIPC Handler æ—¢è¦è°ƒç”¨æœåŠ¡ï¼Œåˆè¦å¤„ç†ä¸šåŠ¡å›è°ƒ
3. **å•çª—å£é™åˆ¶**ï¼šå›è°ƒåªèƒ½å‘é€åˆ°å½“å‰çª—å£
4. **éš¾ä»¥æµ‹è¯•**ï¼šService å±‚è€¦åˆäº† IPC é€»è¾‘

---

## âœ… äº‹ä»¶é©±åŠ¨æ¶æ„è§£å†³æ–¹æ¡ˆ

### æ ¸å¿ƒåŸåˆ™

1. **Service å±‚çº¯å‡€**ï¼šåªè´Ÿè´£ä¸šåŠ¡é€»è¾‘ï¼Œé€šè¿‡äº‹ä»¶å‘å°„çŠ¶æ€
2. **IPC å±‚è–„è–„çš„**ï¼šåªè´Ÿè´£ç›‘å¬äº‹ä»¶å¹¶è½¬å‘ï¼Œä¸å‚ä¸ä¸šåŠ¡
3. **ç«‹å³è¿”å›æ ‡è¯†**ï¼šéœ€è¦çš„ ID åœ¨æ–¹æ³•å¼€å§‹æ—¶ç«‹å³ç”Ÿæˆå¹¶è¿”å›
4. **äº‹ä»¶è§£è€¦é€šä¿¡**ï¼šç”¨äº‹ä»¶ä»£æ›¿å›è°ƒä¼ é€’è¿›åº¦/çŠ¶æ€

---

## ğŸ—ï¸ æ ‡å‡†å®ç°æ¨¡æ¿

### 1. Service å±‚è®¾è®¡

```typescript
import { EventEmitter } from 'events'

// å®šä¹‰äº‹ä»¶æ•°æ®ç±»å‹
export interface ActionStartEvent {
  actionId: string
  // ... å…¶ä»–å­—æ®µ
}

export interface ActionProgressEvent {
  actionId: string
  progress: number
  data: any
}

export interface ActionCompleteEvent {
  actionId: string
  result: any
}

export interface ActionErrorEvent {
  actionId: string
  error: string
}

// Service ç»§æ‰¿ EventEmitter
export class MyService extends EventEmitter {
  /**
   * æ‰§è¡Œæ“ä½œï¼ˆç«‹å³è¿”å› actionIdï¼‰
   */
  async doSomething(params: any): Promise<string> {
    // âœ… 1. ç«‹å³ç”Ÿæˆå¹¶è¿”å› ID
    const actionId = `action_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`
    
    // âœ… 2. å‘å°„å¼€å§‹äº‹ä»¶
    this.emit('action:start', {
      actionId,
      ...params
    } as ActionStartEvent)
    
    // âœ… 3. å¼‚æ­¥å¤„ç†ï¼Œä¸é˜»å¡è¿”å›
    this.processAsync(actionId, params)
    
    return actionId
  }
  
  /**
   * ç§æœ‰æ–¹æ³•ï¼šå¼‚æ­¥å¤„ç†ä¸šåŠ¡é€»è¾‘
   */
  private async processAsync(actionId: string, params: any): Promise<void> {
    try {
      // ä¸šåŠ¡é€»è¾‘...
      
      // âœ… é€šè¿‡äº‹ä»¶å‘å°„è¿›åº¦
      this.emit('action:progress', {
        actionId,
        progress: 50,
        data: { /* ... */ }
      } as ActionProgressEvent)
      
      // å®Œæˆæ—¶å‘å°„å®Œæˆäº‹ä»¶
      this.emit('action:complete', {
        actionId,
        result: { /* ... */ }
      } as ActionCompleteEvent)
      
    } catch (error: any) {
      // âœ… é”™è¯¯ä¹Ÿé€šè¿‡äº‹ä»¶ä¼ é€’
      this.emit('action:error', {
        actionId,
        error: error.message
      } as ActionErrorEvent)
    }
  }
}
```

---

### 2. IPC Handler å±‚è®¾è®¡

```typescript
import { ipcMain, BrowserWindow } from 'electron'
import type { MyService } from '../services/my-service'

export function registerMyServiceHandlers(myService: MyService) {
  // ========== äº‹ä»¶ç›‘å¬å™¨ï¼ˆåªåœ¨æ³¨å†Œæ—¶æ‰§è¡Œä¸€æ¬¡ï¼‰ ==========
  
  myService.on('action:start', (data: ActionStartEvent) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('my-service:action-start', data)
    })
  })
  
  myService.on('action:progress', (data: ActionProgressEvent) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('my-service:action-progress', data)
    })
  })
  
  myService.on('action:complete', (data: ActionCompleteEvent) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('my-service:action-complete', data)
    })
  })
  
  myService.on('action:error', (data: ActionErrorEvent) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('my-service:action-error', data)
    })
  })
  
  // ========== IPC Handlersï¼ˆçº¯è°ƒç”¨ï¼‰ ==========
  
  ipcMain.handle('my-service:do-something', async (event, args) => {
    try {
      const actionId = await myService.doSomething(args)
      return { success: true, actionId }
    } catch (error: any) {
      return { success: false, error: error.message }
    }
  })
  
  console.log('MyService IPC handlers registered')
}
```

---

### 3. å‰ç«¯ Store è®¾è®¡

```typescript
// Pinia Store
export const useMyServiceStore = defineStore('myService', () => {
  const activeActions = ref<Map<string, ActionState>>(new Map())
  
  // æ‰§è¡Œæ“ä½œ
  async function doSomething(params: any) {
    const result = await window.api.myService.doSomething(params)
    if (result.success) {
      // åˆå§‹åŒ–æœ¬åœ°çŠ¶æ€
      activeActions.value.set(result.actionId, {
        id: result.actionId,
        status: 'running',
        progress: 0
      })
      return result.actionId
    }
    return null
  }
  
  // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨ï¼ˆåœ¨ onMounted ä¸­è°ƒç”¨ï¼‰
  function setupListeners() {
    window.api.myService.onActionStart((data) => {
      console.log('Action started:', data.actionId)
    })
    
    window.api.myService.onActionProgress((data) => {
      const action = activeActions.value.get(data.actionId)
      if (action) {
        action.progress = data.progress
        action.data = data.data
      }
    })
    
    window.api.myService.onActionComplete((data) => {
      const action = activeActions.value.get(data.actionId)
      if (action) {
        action.status = 'completed'
        action.result = data.result
      }
    })
    
    window.api.myService.onActionError((data) => {
      const action = activeActions.value.get(data.actionId)
      if (action) {
        action.status = 'error'
        action.error = data.error
      }
    })
  }
  
  return {
    activeActions,
    doSomething,
    setupListeners
  }
})
```

---

## ğŸ“Š æ¶æ„å¯¹æ¯”

| **ç»´åº¦** | **ä¼ ç»Ÿå›è°ƒæ¨¡å¼** | **äº‹ä»¶é©±åŠ¨æ¨¡å¼** |
|---------|----------------|----------------|
| **ID ç”Ÿæˆæ—¶æœº** | await å®Œæˆå âŒ | æ–¹æ³•å¼€å§‹æ—¶ âœ… |
| **Service èŒè´£** | ä¸šåŠ¡ + IPC å›è°ƒ | çº¯ä¸šåŠ¡é€»è¾‘ âœ… |
| **IPC Handler èŒè´£** | è°ƒç”¨ + å›è°ƒä¼ é€’ | çº¯äº‹ä»¶è½¬å‘ âœ… |
| **å¤šçª—å£æ”¯æŒ** | éœ€æ‰‹åŠ¨å¤„ç† | è‡ªåŠ¨å¹¿æ’­ âœ… |
| **å¯æµ‹è¯•æ€§** | éœ€ mock IPC | åªéœ€ mock EventEmitter âœ… |
| **å¯æ‰©å±•æ€§** | æ”¹åŠ¨å¤šå¤„ | æ·»åŠ ç›‘å¬å™¨ âœ… |
| **å¾ªç¯ä¾èµ–** | å­˜åœ¨ âŒ | æ—  âœ… |

---

## ğŸ¯ å®æ–½æ­¥éª¤

### Step 1: å®šä¹‰äº‹ä»¶ç±»å‹

```typescript
// types.ts
export interface XxxStartEvent { id: string; ... }
export interface XxxProgressEvent { id: string; progress: number; ... }
export interface XxxCompleteEvent { id: string; result: any }
export interface XxxErrorEvent { id: string; error: string }
```

### Step 2: Service ç»§æ‰¿ EventEmitter

```typescript
import { EventEmitter } from 'events'

export class MyService extends EventEmitter {
  async action(params: any): Promise<string> {
    const id = generateId()
    this.emit('action:start', { id })
    this.processAsync(id, params)
    return id  // ç«‹å³è¿”å›
  }
  
  private async processAsync(id: string, params: any) {
    // ä¸šåŠ¡é€»è¾‘
    // é€šè¿‡ this.emit() å‘å°„äº‹ä»¶
  }
}
```

### Step 3: IPC Handler æ³¨å†Œäº‹ä»¶ç›‘å¬

```typescript
export function registerHandlers(service: MyService) {
  // äº‹ä»¶ç›‘å¬å™¨
  service.on('action:start', (data) => {
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('service:action-start', data)
    })
  })
  
  // IPC Handlers
  ipcMain.handle('service:action', async (event, args) => {
    const id = await service.action(args)
    return { success: true, id }
  })
}
```

### Step 4: å‰ç«¯è®¾ç½®ç›‘å¬å™¨

```typescript
// Store ä¸­
function setupListeners() {
  window.api.service.onActionStart((data) => { /* ... */ })
  window.api.service.onActionProgress((data) => { /* ... */ })
  window.api.service.onActionComplete((data) => { /* ... */ })
  window.api.service.onActionError((data) => { /* ... */ })
}

// ç»„ä»¶æŒ‚è½½æ—¶è°ƒç”¨
onMounted(() => {
  store.setupListeners()
})
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. äº‹ä»¶ç›‘å¬å™¨åªæ³¨å†Œä¸€æ¬¡

```typescript
// âœ… æ­£ç¡®ï¼šåœ¨ registerHandlers å‡½æ•°ä¸­æ³¨å†Œ
export function registerHandlers(service: MyService) {
  service.on('action:progress', handleProgress)  // åªæ‰§è¡Œä¸€æ¬¡
}

// âŒ é”™è¯¯ï¼šåœ¨ IPC Handler ä¸­æ³¨å†Œ
ipcMain.handle('service:action', async () => {
  service.on('action:progress', handleProgress)  // æ¯æ¬¡è°ƒç”¨éƒ½æ³¨å†Œï¼
})
```

### 2. äº‹ä»¶åç§°çº¦å®š

```typescript
// Service äº‹ä»¶ï¼šä½¿ç”¨å†’å·åˆ†éš”
'action:start'
'action:progress'
'action:complete'
'action:error'

// IPC é€šé“åï¼šä½¿ç”¨çŸ­æ¨ªçº¿åˆ†éš”
'service:action-start'
'service:action-progress'
'service:action-complete'
'service:action-error'
```

### 3. ID ç”Ÿæˆç­–ç•¥

```typescript
// âœ… æ¨èï¼šæ—¶é—´æˆ³ + éšæœºå­—ç¬¦ä¸²
const id = `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`

// âœ… ä¹Ÿå¯ä½¿ç”¨ nanoid
import { nanoid } from 'nanoid'
const id = nanoid()
```

### 4. é”™è¯¯å¤„ç†

```typescript
private async processAsync(id: string, params: any) {
  try {
    // ä¸šåŠ¡é€»è¾‘
  } catch (error: any) {
    // âœ… é”™è¯¯ä¹Ÿé€šè¿‡äº‹ä»¶ä¼ é€’
    this.emit('action:error', {
      id,
      error: error.message
    })
  }
}
```

---

## ğŸ” è°ƒè¯•æŠ€å·§

### 1. æ·»åŠ æ—¥å¿—ç›‘å¬å™¨

```typescript
// åœ¨å¼€å‘ç¯å¢ƒæ·»åŠ è°ƒè¯•ç›‘å¬å™¨
if (process.env.NODE_ENV === 'development') {
  service.on('action:start', (data) => {
    console.log('[Service] Action started:', data)
  })
  service.on('action:progress', (data) => {
    console.log('[Service] Progress:', data)
  })
  service.on('action:complete', (data) => {
    console.log('[Service] Completed:', data)
  })
}
```

### 2. æ£€æŸ¥äº‹ä»¶ç›‘å¬å™¨æ•°é‡

```typescript
// é˜²æ­¢å†…å­˜æ³„æ¼
console.log('Listeners count:', service.listenerCount('action:progress'))

// è®¾ç½®æœ€å¤§ç›‘å¬å™¨æ•°é‡
service.setMaxListeners(20)
```

---

## ğŸ“š å®é™…æ¡ˆä¾‹å‚è€ƒ

### æ¡ˆä¾‹ï¼šLLM Chat æµå¼å“åº”

**æ–‡ä»¶ä½ç½®**ï¼š
- `Nimbria/src-electron/services/llm-chat-service/llm-chat-service.ts`
- `Nimbria/src-electron/ipc/main-renderer/llm-chat-handlers.ts`

**å…³é”®ä»£ç **ï¼š
```typescript
// Service
async sendMessage(conversationId: string, content: string): Promise<string> {
  const messageId = `msg_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`
  this.emit('message:start', { conversationId, messageId })
  this.processStreamAsync(conversationId, messageId, content)
  return messageId
}

// IPC Handler
llmChatService.on('message:chunk', (data) => {
  BrowserWindow.getAllWindows().forEach(win => {
    win.webContents.send('llm-chat:stream-chunk', data)
  })
})
```

---

## ğŸ“ æ ¸å¿ƒè¦ç‚¹æ€»ç»“

1. âœ… **Service ç»§æ‰¿ EventEmitter**
2. âœ… **ç«‹å³ç”Ÿæˆå¹¶è¿”å› ID**
3. âœ… **é€šè¿‡äº‹ä»¶å‘å°„çŠ¶æ€ï¼Œä¸ç”¨å›è°ƒ**
4. âœ… **IPC Handler åªç›‘å¬äº‹ä»¶å¹¶è½¬å‘**
5. âœ… **äº‹ä»¶ç›‘å¬å™¨åªæ³¨å†Œä¸€æ¬¡**
6. âœ… **æ”¯æŒå¤šçª—å£è‡ªåŠ¨å¹¿æ’­**
7. âœ… **è§£è€¦ã€å¯æµ‹è¯•ã€å¯æ‰©å±•**

---

**é€‚ç”¨åœºæ™¯**ï¼š
- âœ… æµå¼å“åº”ï¼ˆLLMã€æ–‡ä»¶ä¸‹è½½ã€æ•°æ®å¤„ç†ï¼‰
- âœ… é•¿æ—¶é—´å¼‚æ­¥ä»»åŠ¡ï¼ˆæ„å»ºã€ç¼–è¯‘ã€è½¬æ¢ï¼‰
- âœ… éœ€è¦è¿›åº¦åé¦ˆçš„æ“ä½œ
- âœ… å¤šçª—å£åŒæ­¥çŠ¶æ€

**ä¸é€‚ç”¨åœºæ™¯**ï¼š
- âŒ ç®€å•çš„åŒæ­¥è°ƒç”¨
- âŒ ä¸éœ€è¦è¿›åº¦åé¦ˆçš„å¿«é€Ÿæ“ä½œ

---

**æœ€åæ›´æ–°**: 2025å¹´10æœˆ15æ—¥  
**ç‰ˆæœ¬**: v1.0  
**è´Ÿè´£äºº**: Nimbria å¼€å‘å›¢é˜Ÿ