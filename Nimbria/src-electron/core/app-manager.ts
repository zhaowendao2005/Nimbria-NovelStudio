import { app, ipcMain, dialog, BrowserWindow, type MessagePortMain } from 'electron'
import path from 'node:path'
import fs from 'node:fs'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const isDevEnvironment = !!process.env.DEV || !!process.env.DEBUGGING
const isDebugMode = !!process.env.ELECTRON_DEBUG

import type { WindowTemplate } from '../types/window'
import type { WindowProcess, ProjectWindowProcess, MainWindowProcess } from '../types/process'
import type { IPCRequest, IPCResponse, WindowOperationResult } from '../types/ipc'

import { WindowManager } from '../services/window-service/window-manager'
import { ProjectFileSystem } from '../services/file-service/project-fs'
import { FileWatcherService } from '../services/file-service/file-watcher'
import { ProjectManager } from '../services/project-service/project-manager'
import { getLogger, closeLogSystem, getLogFilePath } from '../utils/shared/logger'
import { getRecentProjects, upsertRecentProject, clearRecentProjects } from '../store/recent-projects-store'
import { registerMarkdownHandlers } from '../ipc/main-renderer/markdown-handlers'
import { registerFileHandlers } from '../ipc/main-renderer/file-handlers'
import { registerDocParserHandlers } from '../ipc/main-renderer/docParser-handlers'
import { registerLlmHandlers } from '../ipc/main-renderer/llm-handlers'
import { registerLlmChatHandlers } from '../ipc/main-renderer/llm-chat-handlers'
import { LlmConfigManager } from '../services/llm-service/llm-config-manager'
import { LlmChatService } from '../services/llm-chat-service/llm-chat-service'
import { ConversationManager } from '../services/llm-chat-service/conversation-manager'
import { ContextManager } from '../services/llm-chat-service/context-manager'
import { DatabaseService } from '../services/database-service/database-service'
import { registerDatabaseHandlers } from '../ipc/main-renderer/database-handlers'
import { StarChartService } from '../services/star-chart-service/star-chart-service'
import { registerStarChartHandlers } from '../ipc/main-renderer/star-chart-handlers'
import { LlmTranslateService } from '../services/llm-translate-service/llm-translate-service'
import { registerLlmTranslateHandlers } from '../ipc/main-renderer/llm-translate-handlers'
import { createApplicationMenu, setupContextMenu } from './menu'

const logger = getLogger('AppManager')

export class AppManager {
  private windowManager: WindowManager | null = null
  private mainProcess: WindowProcess | null = null
  private projectFileSystem!: ProjectFileSystem
  private fileWatcher!: FileWatcherService
  private projectManager!: ProjectManager
  private llmConfigManager!: LlmConfigManager
  private llmChatService!: LlmChatService
  private llmTranslateService!: LlmTranslateService
  private databaseService!: DatabaseService
  private starChartService!: StarChartService
  private transferMap?: Map<string, { sourceWebContentsId: number; tabId: string }>

  async boot() {
    logger.info('='.repeat(80))
    logger.info('Starting Nimbria application...')
    logger.info('Environment:', {
      isDev: isDevEnvironment,
      isDebug: isDebugMode,
      nodeEnv: process.env.NODE_ENV,
      appPath: app.getAppPath(),
      userDataPath: app.getPath('userData')
    })
    logger.info('Log file:', getLogFilePath())
    logger.info('='.repeat(80))
    
    await this.initializeDatabase()
    await this.initializeStarChart()
    this.initializeFileSystem()
    this.setupDatabaseEventListeners() // Ê∑ªÂä†Êï∞ÊçÆÂ∫ì‰∫ã‰ª∂ÁõëÂê¨Âô®
    this.initializeWindowManager()
    this.registerIpcHandlers()
    
    // üî• Âú®Ë∞ÉËØïÊ®°Âºè‰∏ãÂàõÂª∫Â∫îÁî®ËèúÂçï
    if (isDebugMode) {
      createApplicationMenu(true)
      logger.info('Debug menu initialized')
    }
  }

  async shutdown() {
    logger.info('='.repeat(80))
    logger.info('Shutting down Nimbria application...')
    
    // Ê∏ÖÁêÜÊï∞ÊçÆÂ∫ìÊúçÂä°
    if (this.databaseService) {
      await this.databaseService.cleanup()
    }
    
    // Ê∏ÖÁêÜ StarChart ÊúçÂä°
    if (this.starChartService) {
      await this.starChartService.cleanup()
    }
    
    if (this.projectFileSystem) {
      await this.projectFileSystem.cleanup()
    }
    
    logger.info('Application shutdown complete')
    logger.info('='.repeat(80))
    
    // üî• ÂÖ≥Èó≠Êó•ÂøóÁ≥ªÁªü
    closeLogSystem()
  }

  private initializeFileSystem() {
    this.projectFileSystem = new ProjectFileSystem()
    this.fileWatcher = new FileWatcherService()
    this.projectManager = new ProjectManager()
    this.llmConfigManager = new LlmConfigManager()
    
    // ÂàùÂßãÂåñ LLM Chat ÊúçÂä°
    const conversationManager = new ConversationManager()
    const contextManager = new ContextManager()
    
    this.llmChatService = new LlmChatService(
      this.llmConfigManager,
      this.databaseService, // ‰º†ÂÖ•Êï∞ÊçÆÂ∫ìÊúçÂä°
      conversationManager,
      contextManager
    )
    
    // ÂºÇÊ≠•ÂàùÂßãÂåñ LLM Chat ÊúçÂä°Ôºà‰∏çÈòªÂ°ûÂêØÂä®Ôºâ
    void this.llmChatService.initialize().catch(error => {
      logger.error('Failed to initialize LLM Chat service:', error)
    })
    
    // ÂàùÂßãÂåñ LLM Translate ÊúçÂä°
    this.llmTranslateService = new LlmTranslateService(this.llmChatService, this.llmConfigManager)
    logger.info('LLM Translate service initialized')
    
    logger.info('File system, file watcher, project management, LLM config, LLM chat and LLM translate services initialized')
  }

  /**
   * ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìÊúçÂä°
   */
  private async initializeDatabase() {
    logger.info('Initializing database service...')
    
    this.databaseService = new DatabaseService()
    
    // Ë∞ÉÁî®ÂàùÂßãÂåñÊñπÊ≥ïÔºà‰ºöÁ´ãÂç≥ËøîÂõûinitIdÔºåÈÄöËøá‰∫ã‰ª∂ÂèçÈ¶àÁä∂ÊÄÅÔºâ
    const initId = await this.databaseService.initialize()
    
    logger.info('Database service initialization started, initId:', initId)
  }

  /**
   * ÂàùÂßãÂåñ StarChart ÊúçÂä°
   */
  private async initializeStarChart() {
    logger.info('Initializing StarChart service...')
    
    this.starChartService = new StarChartService()
    
    // Ë∞ÉÁî®ÂàùÂßãÂåñÊñπÊ≥ïÔºà‰ºöÁ´ãÂç≥ËøîÂõûinitIdÔºåÈÄöËøá‰∫ã‰ª∂ÂèçÈ¶àÁä∂ÊÄÅÔºâ
    const initId = await this.starChartService.initialize()
    
    logger.info('StarChart service initialization started, initId:', initId)
  }

  /**
   * ËÆæÁΩÆÊï∞ÊçÆÂ∫ì‰∫ã‰ª∂ÁõëÂê¨Âô®
   */
  private setupDatabaseEventListeners() {
    // ÁõëÂê¨È°πÁõÆÊï∞ÊçÆÂ∫ìÂàõÂª∫ÂÆåÊàê‰∫ã‰ª∂
    this.databaseService.on('database:project-created', async (data) => {
      logger.info(`üì¢ [AppManager] È°πÁõÆÊï∞ÊçÆÂ∫ìÂàõÂª∫ÂÆåÊàê: ${data.projectPath}`)
      
      // ÈÄöÁü• LLM Chat ÊúçÂä°ÂàáÊç¢È°πÁõÆ
      if (this.llmChatService) {
        try {
          await this.llmChatService.switchProject(data.projectPath)
          logger.info(`‚úÖ [AppManager] LLM Chat ÊúçÂä°Â∑≤ÂàáÊç¢Âà∞È°πÁõÆ: ${data.projectPath}`)
        } catch (error) {
          logger.error(`‚ùå [AppManager] LLM Chat ÊúçÂä°ÂàáÊç¢È°πÁõÆÂ§±Ë¥•:`, error)
        }
      }
      
      // ÂàùÂßãÂåñ LLM Translate ÊúçÂä°
      if (this.llmTranslateService) {
        try {
          const projectDb = this.databaseService.getProjectDatabase(data.projectPath)
          if (projectDb) {
            await this.llmTranslateService.initialize(data.projectPath, projectDb)
            logger.info(`‚úÖ [AppManager] LLM Translate ÊúçÂä°Â∑≤ÂàùÂßãÂåñ: ${data.projectPath}`)
          }
        } catch (error) {
          logger.error(`‚ùå [AppManager] LLM Translate ÊúçÂä°ÂàùÂßãÂåñÂ§±Ë¥•:`, error)
        }
      }
    })

    // ÁõëÂê¨Êï∞ÊçÆÂ∫ìÈîôËØØ‰∫ã‰ª∂
    this.databaseService.on('database:project-error', (data) => {
      logger.error(`‚ùå [AppManager] È°πÁõÆÊï∞ÊçÆÂ∫ìÈîôËØØ: ${data.projectPath}`, data.error)
    })

    logger.info('Database event listeners setup completed')
  }

  private initializeWindowManager() {
    const templates: Record<'main' | 'project', WindowTemplate> = {
      main: {
        id: 'main-default',
        type: 'main',
        options: {
          width: 1024,
          height: 720,
          minWidth: 900,
          minHeight: 620,
          maxWidth: 1120,
          maxHeight: 820,
          resizable: false,
          useContentSize: true,
          frame: false,
          title: 'Nimbria',
          icon: path.join(__dirname, '../icons/icon.png')
        }
      },
      project: {
        id: 'project-default',
        type: 'project',
        options: {
          width: 1200,
          height: 800,
          minWidth: 960,
          minHeight: 640,
          resizable: true,
          useContentSize: true,
          frame: false,
          title: 'Nimbria Project'
        }
      }
    }

    this.windowManager = new WindowManager({
      templates,
      lifecycleHooks: {
        onReady: (windowProcess) => {
          if (windowProcess.type === 'main') {
            this.mainProcess = windowProcess
            this.loadMainWindow(windowProcess)
          } else if (windowProcess.type === 'project') {
            this.loadProjectWindow(windowProcess)
          }
        }
      }
    })

    const launch = () => {
      if (!this.windowManager) return
      this.mainProcess = this.windowManager.createMainWindow()
    }

    if (app.isReady()) {
      launch()
    } else {
      app.on('ready', () => {
        launch()
      })
    }

    app.on('activate', () => {
      if (!this.mainProcess) {
        void launch()
      }
    })

    app.on('window-all-closed', () => {
      if (process.platform !== 'darwin') {
        app.quit()
      }
    })
  }

  private loadMainWindow(windowProcess: WindowProcess) {
    if (isDevEnvironment) {
      const url = process.env.APP_URL
      if (url) void windowProcess.window.loadURL(url)
      windowProcess.window.webContents.openDevTools({ mode: 'detach' })
      return
    }

    // üî• ‰øÆÂ§çÁîü‰∫ßÁéØÂ¢ÉË∑ØÂæÑÈóÆÈ¢ò
    // Electron ÂèØ‰ª•Áõ¥Êé•‰ªé asar ‰∏≠Âä†ËΩΩÊñá‰ª∂
    // app.asar ‰ºöË¢´Ëá™Âä®Ëß£ÂéãÂà∞ÂÜÖÂ≠ò‰∏≠ÔºåÊâÄ‰ª•Áõ¥Êé•‰ΩøÁî® app.getAppPath() + 'index.html'
    const indexPath = path.join(app.getAppPath(), 'index.html')
    
    logger.info('Loading main window from:', indexPath)
    logger.info('Current __dirname:', __dirname)
    logger.info('App path:', app.getAppPath())
    logger.info('Is in asar:', __dirname.includes('app.asar'))
    logger.info('Debug mode:', isDebugMode)
    logger.info('Index.html exists (in asar):', fs.existsSync(indexPath))
    
    // Ê∑ªÂä†ÈîôËØØÁõëÂê¨Âô®
    windowProcess.window.webContents.on('did-fail-load', (event, errorCode, errorDescription, validatedURL) => {
      logger.error('Failed to load window:', { errorCode, errorDescription, validatedURL })
    })
    
    windowProcess.window.webContents.on('did-finish-load', () => {
      logger.info('Main window finished loading')
      // üî• Ë∞ÉËØïÊ®°Âºè‰∏ã‰πüÂºÄÂêØ DevTools
      if (isDebugMode) {
        windowProcess.window.webContents.openDevTools({ mode: 'detach' })
        logger.info('DevTools opened in debug mode')
      }
    })
    
    windowProcess.window.webContents.on('dom-ready', () => {
      logger.info('DOM ready for main window')
    })
    
    // üî• F12Âø´Êç∑ÈîÆÁé∞Âú®Áî±process-manager.tsÁªü‰∏ÄÂ§ÑÁêÜ
    
    // üî• Âú®Ë∞ÉËØïÊ®°Âºè‰∏ãÊ∑ªÂä†Âè≥ÈîÆËèúÂçï
    if (isDebugMode) {
      setupContextMenu(windowProcess.window, true)
    }
    
    void windowProcess.window.loadFile(indexPath)
  }

  private loadProjectWindow(windowProcess: WindowProcess) {
    if (isDevEnvironment) {
      const baseUrl = process.env.APP_URL
      if (baseUrl) {
        const projectUrl = `${baseUrl}#/project`  // ÂØºËà™Âà∞È°πÁõÆÈ°µË∑ØÁî±
        void windowProcess.window.loadURL(projectUrl)
      }
      windowProcess.window.webContents.openDevTools({ mode: 'detach' })
      return
    }

    // üî• ‰øÆÂ§çÁîü‰∫ßÁéØÂ¢ÉË∑ØÂæÑÈóÆÈ¢òÔºà‰∏é‰∏ªÁ™óÂè£ÈÄªËæë‰∏ÄËá¥Ôºâ
    const indexPath = path.join(app.getAppPath(), 'index.html')
    
    logger.info('Loading project window from:', indexPath)
    logger.info('File exists (in asar):', fs.existsSync(indexPath))
    
    // üî• Ë∞ÉËØïÊ®°Âºè‰∏ãËá™Âä®ÊâìÂºÄ DevTools
    if (isDebugMode) {
      windowProcess.window.webContents.on('did-finish-load', () => {
        windowProcess.window.webContents.openDevTools({ mode: 'detach' })
        logger.info('DevTools opened for project window in debug mode')
      })
    }
    
    // üî• F12Âø´Êç∑ÈîÆÁé∞Âú®Áî±process-manager.tsÁªü‰∏ÄÂ§ÑÁêÜ
    
    // üî• Âú®Ë∞ÉËØïÊ®°Âºè‰∏ãÊ∑ªÂä†Âè≥ÈîÆËèúÂçï
    if (isDebugMode) {
      setupContextMenu(windowProcess.window, true)
    }
    
    void windowProcess.window.loadFile(indexPath, {
      hash: '/project'
    })
  }

  /**
   * ÂàõÂª∫ÂàÜÁ¶ªÁ™óÂè£ÔºàÊ†áÁ≠æÈ°µÊãÜÂàÜÂà∞Êñ∞Á™óÂè£Ôºâ
   */
  private async createDetachedWindow(config: {
    projectPath: string
    transferId: string
    tabData: { title?: string; [key: string]: unknown }
    ui: 'minimal'
  }): Promise<BrowserWindow> {
    // üî• Ëß£ÊûêÊ≠£Á°ÆÁöÑ preload ËÑöÊú¨Ë∑ØÂæÑÔºà‰∏éÈ°πÁõÆÁ™óÂè£Áõ∏ÂêåÔºâ
    const preloadPath = this.resolvePreloadPath('project')
    
    const detachedWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      minWidth: 800,
      minHeight: 600,
      resizable: true,
      useContentSize: true,
      frame: false,
      title: config.tabData.title || 'Nimbria - Detached Window',
      icon: path.join(__dirname, '../icons/icon.png'),
      webPreferences: {
        contextIsolation: true,
        nodeIntegration: false,
        sandbox: false, // üî• ‰∏éÈ°πÁõÆÁ™óÂè£‰øùÊåÅ‰∏ÄËá¥
        nodeIntegrationInWorker: true, // üî• ‰∏éÈ°πÁõÆÁ™óÂè£‰øùÊåÅ‰∏ÄËá¥
        preload: preloadPath
      }
    })

    // ËÆæÁΩÆÁ™óÂè£Ê†áÈ¢ò
    detachedWindow.setTitle(config.tabData.title || 'Nimbria - Detached Window')

    // ÊûÑÂª∫URLÂèÇÊï∞
    const params = new URLSearchParams({
      newWindow: 'true',
      ui: config.ui,
      transferId: config.transferId,
      projectPath: config.projectPath,
      tabData: encodeURIComponent(JSON.stringify(config.tabData))
    })

    // Âä†ËΩΩÂàÜÁ¶ªÁ™óÂè£È°µÈù¢
    if (isDevEnvironment) {
      const baseUrl = process.env.APP_URL
      if (baseUrl) {
        const detachedUrl = `${baseUrl}#/project-detached?${params.toString()}`
        await detachedWindow.loadURL(detachedUrl)
      }
      detachedWindow.webContents.openDevTools({ mode: 'detach' })
    } else {
      // üî• ‰øÆÂ§çÁîü‰∫ßÁéØÂ¢ÉË∑ØÂæÑÈóÆÈ¢òÔºà‰∏é‰∏ªÁ™óÂè£ÈÄªËæë‰∏ÄËá¥Ôºâ
      const indexPath = path.join(app.getAppPath(), 'index.html')
      logger.info('Loading detached window from:', indexPath)
      logger.info('File exists (in asar):', fs.existsSync(indexPath))
      
      // üî• Ë∞ÉËØïÊ®°Âºè‰∏ãËá™Âä®ÊâìÂºÄ DevTools
      if (isDebugMode) {
        detachedWindow.webContents.on('did-finish-load', () => {
          detachedWindow.webContents.openDevTools({ mode: 'detach' })
          logger.info('DevTools opened for detached window in debug mode')
        })
      }
      
      await detachedWindow.loadFile(indexPath, {
        hash: `/project-detached?${params.toString()}`
      })
    }

    // üî• ‰∏∫ÂàÜÁ¶ªÁ™óÂè£‰πüÊ∑ªÂä†Âø´Êç∑ÈîÆÂíåÂè≥ÈîÆËèúÂçïÊîØÊåÅ
    // ÂàõÂª∫‰∏Ä‰∏™‰∏¥Êó∂ÁöÑ WindowProcess ÂØπË±°Áî®‰∫éËÆæÁΩÆÂø´Êç∑ÈîÆ
    const detachedProcess: ProjectWindowProcess = {
      id: config.transferId,
      type: 'project',
      window: detachedWindow,
      port: null as unknown as MessagePortMain, // ÂàÜÁ¶ªÁ™óÂè£‰∏ç‰ΩøÁî® MessagePort
      processId: detachedWindow.webContents.getProcessId(),
      projectPath: config.projectPath,
      createdAt: new Date(),
      lastActive: new Date()
    }
    // üî• ÂàÜÁ¶ªÁ™óÂè£ÁöÑF12ÂäüËÉΩÈúÄË¶ÅÂçïÁã¨ËÆæÁΩÆÔºà‰∏çÈÄöËøáprocess-managerÔºâ
    detachedWindow.webContents.on('before-input-event', (event, input) => {
      if (input.key === 'F12') {
        if (detachedWindow.webContents.isDevToolsOpened()) {
          detachedWindow.webContents.closeDevTools()
        } else {
          detachedWindow.webContents.openDevTools({ mode: 'detach' })
        }
      }
    })
    if (isDebugMode) {
      setupContextMenu(detachedWindow, true)
    }

    logger.info('Detached window loaded:', config.transferId)

    return detachedWindow
  }


  /**
   * Ëß£Êûê preload ËÑöÊú¨Ë∑ØÂæÑ
   * üî• ‰øÆÂ§çÁîü‰∫ßÁéØÂ¢ÉË∑ØÂæÑÈóÆÈ¢ò
   */
  private resolvePreloadPath(type: 'main' | 'project'): string {
    const preloadBaseName = type === 'main' ? 'main-preload' : 'project-preload'

    if (isDevEnvironment) {
      const devPath = path.join(app.getAppPath(), 'preload', `${preloadBaseName}.cjs`)
      logger.info(`Development preload path for ${type}:`, devPath)
      return devPath
    }

    // üî• Áîü‰∫ßÁéØÂ¢ÉË∑ØÂæÑ‰øÆÂ§ç
    const preloadFolder = process.env.QUASAR_ELECTRON_PRELOAD_FOLDER || 'electron-preload'
    const preloadExtension = process.env.QUASAR_ELECTRON_PRELOAD_EXTENSION || '.cjs'
    const prodPath = path.join(app.getAppPath(), preloadFolder, `${preloadBaseName}${preloadExtension}`)
    
    logger.info(`Production preload path for ${type}:`, prodPath)
    logger.info('App path:', app.getAppPath())
    logger.info('Preload folder:', preloadFolder)
    logger.info('Preload extension:', preloadExtension)
    
    // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
    if (!fs.existsSync(prodPath)) {
      logger.error(`Preload script not found at: ${prodPath}`)
      // Â∞ùËØïÂ§áÁî®Ë∑ØÂæÑ
      const altPath = path.join(__dirname, '../preload', `${preloadBaseName}${preloadExtension}`)
      logger.info(`Trying alternative preload path: ${altPath}`)
      if (fs.existsSync(altPath)) {
        return altPath
      } else {
        logger.error(`Alternative preload path also not found: ${altPath}`)
      }
    }

    return prodPath
  }

  private registerIpcHandlers() {
    // Ê≥®ÂÜå Markdown IPC Â§ÑÁêÜÂô®
    registerMarkdownHandlers()
    logger.info('Markdown IPC handlers registered')
    
    // Ê≥®ÂÜåÊñá‰ª∂/ÁõÆÂΩïÂàõÂª∫ IPC Â§ÑÁêÜÂô®Ôºà‰º†ÂÖ•‰æùËµñÔºâ
    registerFileHandlers({
      projectFileSystem: this.projectFileSystem,
      processManager: this.windowManager!.getProcessManager(),
      fileWatcher: this.fileWatcher
    })
    logger.info('File IPC handlers registered')
    
    // Ê≥®ÂÜå DocParser IPC Â§ÑÁêÜÂô®
    registerDocParserHandlers()
    logger.info('DocParser IPC handlers registered')
    
    // Ê≥®ÂÜå LLM ÈÖçÁΩÆ IPC Â§ÑÁêÜÂô®
    registerLlmHandlers({
      llmConfigManager: this.llmConfigManager
    })
    logger.info('LLM IPC handlers registered')
    
    // Ê≥®ÂÜå LLM Chat IPC Â§ÑÁêÜÂô®
    registerLlmChatHandlers(this.llmChatService)
    logger.info('LLM Chat IPC handlers registered')
    
    // Ê≥®ÂÜå LLM Translate IPC Â§ÑÁêÜÂô®
    registerLlmTranslateHandlers(this.llmTranslateService)
    logger.info('LLM Translate IPC handlers registered')
    
    // Ê≥®ÂÜå Database IPC Â§ÑÁêÜÂô®
    registerDatabaseHandlers(this.databaseService)
    logger.info('Database IPC handlers registered')
    
    // Ê≥®ÂÜå StarChart IPC Â§ÑÁêÜÂô®
    registerStarChartHandlers(this.starChartService)
    logger.info('StarChart IPC handlers registered')

    ipcMain.handle('window:minimize', (event, request: IPCRequest<'window:minimize'>) => {
      return this.handleWindowOperationFromEvent(event, 'minimize', request)
    })

    ipcMain.handle('window:maximize', (event, request: IPCRequest<'window:maximize'>) => {
      return this.handleWindowOperationFromEvent(event, 'maximize', request)
    })

    ipcMain.handle('window:unmaximize', (event, request: IPCRequest<'window:unmaximize'>) => {
      return this.handleWindowOperationFromEvent(event, 'unmaximize', request)
    })

    ipcMain.handle('window:close', (event, request: IPCRequest<'window:close'>) => {
      return this.handleWindowOperationFromEvent(event, 'close', request)
    })

    ipcMain.handle('window:focus', (event, request: IPCRequest<'window:focus'>) => {
      return this.handleWindowOperationFromEvent(event, 'focus', request)
    })

    ipcMain.handle('window:is-maximized', (event, request: IPCRequest<'window:is-maximized'>) => {
      const process = this.resolveWindowProcessFromEvent(event, request.windowId)
      if (!process) {
        return { success: false, value: false }
      }

      return {
        success: true,
        value: process.window.isMaximized()
      }
    })

    // üî• ÂàÜÁ¶ªÁ™óÂè£‰∏ìÁî®È¢ëÈÅìÔºàÁ°Æ‰øùÊìç‰ΩúÂΩìÂâçÁ™óÂè£Ôºâ
    ipcMain.on('detached-window:minimize', (event) => {
      const window = BrowserWindow.fromWebContents(event.sender)
      if (window) {
        window.minimize()
        console.log('üîΩ [AppManager] Detached window minimized')
      }
    })

    ipcMain.on('detached-window:maximize', (event) => {
      const window = BrowserWindow.fromWebContents(event.sender)
      if (window) {
        window.maximize()
        console.log('üî≥ [AppManager] Detached window maximized')
      }
    })

    ipcMain.on('detached-window:unmaximize', (event) => {
      const window = BrowserWindow.fromWebContents(event.sender)
      if (window) {
        window.unmaximize()
        console.log('üî≤ [AppManager] Detached window unmaximized')
      }
    })

    ipcMain.on('detached-window:close', (event) => {
      const window = BrowserWindow.fromWebContents(event.sender)
      if (window) {
        window.close()
        console.log('‚ùå [AppManager] Detached window closed')
      }
    })

    ipcMain.on('detached-window:query-maximized', (event) => {
      const window = BrowserWindow.fromWebContents(event.sender)
      if (window) {
        event.sender.send('detached-window:maximized-state', window.isMaximized())
      }
    })

    ipcMain.handle('project:create-window', async (_event, request: IPCRequest<'project:create-window'>) => {
      if (!this.windowManager) {
        return { success: false, errorCode: 'window-manager-not-ready' }
      }

      const process = this.windowManager.createProjectWindow(request.projectPath)
      
      // Ëá™Âä®ÂàùÂßãÂåñÈ°πÁõÆÊñá‰ª∂Á≥ªÁªü‰∏ä‰∏ãÊñá
      if (process.type === 'project') {
        this.projectFileSystem.initProject(process.projectPath, process.id)
        logger.info(`Auto-initialized project filesystem for ${process.projectPath}`)
        
        // ‚úÖ Ëá™Âä®ÂàõÂª∫È°πÁõÆÊï∞ÊçÆÂ∫ì
        const operationId = await this.databaseService.createProjectDatabase(process.projectPath)
        logger.info(`Auto-started project database creation, operationId: ${operationId}`)
        
        // ‚úÖ Ëá™Âä®Âä†ËΩΩÈ°πÁõÆ StarChartÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
        const starChartPath = await this.starChartService.loadProjectStarChart(process.projectPath)
        if (starChartPath) {
          logger.info(`Auto-loaded StarChart for project: ${process.projectPath}`)
        }
        
        // Ê≥®ÊÑèÔºöLLM Chat ÊúçÂä°ÁöÑÈ°πÁõÆÂàáÊç¢Â∞ÜÂú®Êï∞ÊçÆÂ∫ìÂàõÂª∫ÂÆåÊàê‰∫ã‰ª∂‰∏≠Â§ÑÁêÜ
      }
      
      return {
        success: true,
        processId: process.id
      }
    })

    ipcMain.handle('project:close-window', async (_event, request: IPCRequest<'project:close-window'>) => {
      if (!this.windowManager) {
        return { success: false, errorCode: 'window-manager-not-ready' }
      }

      const process = this.getProjectProcessByPath(request.projectPath)
      if (!process) {
        return { success: false, message: 'Project window not found' }
      }

      await this.windowManager.destroyProcess(process.id)
      return { success: true }
    })

    ipcMain.handle('project:save', (_event, request: IPCRequest<'project:save'>) => {
      logger.info('Project save requested', request.projectData.id)
      // TODO: Ë∞ÉÁî®ÂÆûÈôÖ‰øùÂ≠òÈÄªËæë
      return { success: true } satisfies IPCResponse<'project:save'>
    })

    ipcMain.handle('project:get-recent', () => {
      return getRecentProjects()
    })

    ipcMain.handle('project:update-recent', (_event, payload: { projectPath: string; projectName?: string }) => {
      upsertRecentProject(payload.projectPath, payload.projectName)
      return { success: true }
    })

    ipcMain.handle('project:clear-cache', () => {
      console.log('üóëÔ∏è  [Electron Main] Êî∂Âà∞Ê∏ÖÁ©∫ÁºìÂ≠òËØ∑Ê±Ç')
      console.log('üóëÔ∏è  [Electron Main] Ê∏ÖÁ©∫ÊúÄËøëÈ°πÁõÆÂàóË°®...')
      clearRecentProjects()
      console.log('‚úÖ [Electron Main] ÊúÄËøëÈ°πÁõÆÂàóË°®Â∑≤Ê∏ÖÁ©∫')
      return { success: true }
    })

    ipcMain.handle('window:show-main', () => {
      if (!this.windowManager) {
        return { success: false, error: 'Window manager not ready' }
      }

      let mainProcess = this.windowManager.getMainProcess()
      
      // Â¶ÇÊûú‰∏ªÁ™óÂè£‰∏çÂ≠òÂú®ÔºåÂàôÂàõÂª∫ÂÆÉ
      if (!mainProcess) {
        mainProcess = this.windowManager.createMainWindow()
        logger.info('Main window created from show-main request')
      }
      
      // ÊòæÁ§∫Âπ∂ËÅöÁÑ¶‰∏ªÁ™óÂè£
      if (mainProcess.window.isMinimized()) {
        mainProcess.window.restore()
      }
      mainProcess.window.show()
      mainProcess.window.focus()
      
      logger.info('Main window shown and focused')
      return { success: true }
    })

    // üî• Ê†áÁ≠æÈ°µÊãÜÂàÜÂà∞Êñ∞Á™óÂè£
    ipcMain.handle('project:detach-tab-to-window', async (event, payload: { 
      tabId: string
      tabData: {
        id: string
        title: string
        filePath: string
        content: string
        isDirty: boolean
      }
      projectPath: string 
    }) => {
      try {
        const transferId = `transfer-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`
        
        logger.info('Creating detached window for tab:', payload.tabId)
        
        // ËÆ∞ÂΩïÊ∫êÁ™óÂè£Êò†Â∞ÑÔºàÁî®‰∫éÊè°ÊâãÂÖ≥Èó≠Ôºâ
        if (!this.transferMap) {
          this.transferMap = new Map()
        }
        this.transferMap.set(transferId, {
          sourceWebContentsId: event.sender.id,
          tabId: payload.tabId
        })
        
        // ÂàõÂª∫ÂàÜÁ¶ªÁ™óÂè£
        const detachedWindow = await this.createDetachedWindow({
          projectPath: payload.projectPath,
          transferId,
          tabData: payload.tabData,
          ui: 'minimal'
        })
        
        logger.info('Detached window created successfully, transferId:', transferId)
        
        return { success: true, windowId: detachedWindow.id }
      } catch (error) {
        logger.error('Failed to create detached window:', error)
        return { 
          success: false, 
          error: { 
            code: 'DETACH_FAILED', 
            message: (error as Error).message 
          } 
        }
      }
    })

    // üî• ÂàÜÁ¶ªÁ™óÂè£Â∞±Áª™Êè°Êâã
    ipcMain.on('project:detached-ready', (_event, data: { transferId: string }) => {
      if (!this.transferMap) return
      
      const rec = this.transferMap.get(data.transferId)
      if (rec) {
        logger.info('Detached window ready, closing source tab:', rec.tabId)
        const sourceWindow = BrowserWindow.getAllWindows().find(
          win => win.webContents.id === rec.sourceWebContentsId
        )
        if (sourceWindow && !sourceWindow.isDestroyed()) {
          sourceWindow.webContents.send('project:close-source-tab', { 
            transferId: data.transferId, 
            tabId: rec.tabId 
          })
        }
        this.transferMap.delete(data.transferId)
      }
    })

    ipcMain.handle('process:broadcast', (_event, request: IPCRequest<'process:broadcast'>) => {
      this.windowManager?.broadcast(request.message)
      return undefined
    })

    // Êñá‰ª∂ÂØπËØùÊ°ÜÂ§ÑÁêÜÂô®
    ipcMain.handle('file:open-dialog', async (_event, request: IPCRequest<'file:open-dialog'>) => {
      const dialogOptions: Electron.OpenDialogOptions = {
        title: request.title || 'ÈÄâÊã©Êñá‰ª∂ÊàñÊñá‰ª∂Â§π',
        properties: request.properties
      }
      if (request.defaultPath) {
        dialogOptions.defaultPath = request.defaultPath
      }
      if (request.filters) {
        dialogOptions.filters = request.filters
      }
      const result = await dialog.showOpenDialog(dialogOptions)

      return {
        canceled: result.canceled,
        filePaths: result.filePaths
      } satisfies IPCResponse<'file:open-dialog'>
    })

    ipcMain.handle('file:save-dialog', async (_event, request: IPCRequest<'file:save-dialog'>) => {
      const dialogOptions: Electron.SaveDialogOptions = {
        title: request.title || '‰øùÂ≠òÊñá‰ª∂'
      }
      if (request.defaultPath) {
        dialogOptions.defaultPath = request.defaultPath
      }
      if (request.filters) {
        dialogOptions.filters = request.filters
      }
      const result = await dialog.showSaveDialog(dialogOptions)

      return {
        canceled: result.canceled,
        filePath: result.filePath
      } satisfies IPCResponse<'file:save-dialog'>
    })

    // Êñá‰ª∂Á≥ªÁªüÂ§ÑÁêÜÂô®
    this.registerFileSystemHandlers()

    // È°πÁõÆÁÆ°ÁêÜÂ§ÑÁêÜÂô®
    this.registerProjectManagementHandlers()
  }

  private registerFileSystemHandlers() {
    // È°πÁõÆÊñá‰ª∂Á≥ªÁªüÂàùÂßãÂåñÂíåÊ∏ÖÁêÜ
    ipcMain.handle('fs:project-init', (_event, request: IPCRequest<'fs:project-init'>) => {
      const result = this.projectFileSystem.initProject(request.projectPath, request.windowId)
      return result
    })

    ipcMain.handle('fs:project-cleanup', async (_event, request: IPCRequest<'fs:project-cleanup'>) => {
      const result = await this.projectFileSystem.cleanupProject(request.windowId)
      return result
    })

    // Âü∫Á°ÄÊñá‰ª∂Êìç‰Ωú
    ipcMain.handle('fs:read-file', async (_event, request: IPCRequest<'fs:read-file'>) => {
      const result = await this.projectFileSystem.readFile(request.path, request.projectId, request.encoding as BufferEncoding)
      return result
    })

    ipcMain.handle('fs:write-file', async (_event, request: IPCRequest<'fs:write-file'>) => {
      const result = await this.projectFileSystem.writeFile(request.path, request.content, request.projectId, request.encoding as BufferEncoding)
      return result
    })

    ipcMain.handle('fs:read-dir', async (_event, request: IPCRequest<'fs:read-dir'>) => {
      const result = await this.projectFileSystem.readDir(request.path, request.projectId)
      return result
    })

    ipcMain.handle('fs:create-dir', async (_event, request: IPCRequest<'fs:create-dir'>) => {
      const result = await this.projectFileSystem.createDir(request.path, request.projectId)
      return result
    })

    ipcMain.handle('fs:delete', async (_event, request: IPCRequest<'fs:delete'>) => {
      const result = await this.projectFileSystem.delete(request.path, request.projectId, request.recursive)
      return result
    })

    ipcMain.handle('fs:copy', async (_event, request: IPCRequest<'fs:copy'>) => {
      const result = await this.projectFileSystem.copy(request.source, request.dest, request.projectId)
      return result
    })

    ipcMain.handle('fs:move', async (_event, request: IPCRequest<'fs:move'>) => {
      const result = await this.projectFileSystem.move(request.source, request.dest, request.projectId)
      return result
    })

    // È´òÁ∫ßÂäüËÉΩ
    ipcMain.handle('fs:glob', async (_event, request: IPCRequest<'fs:glob'>) => {
      const result = await this.projectFileSystem.glob(request.pattern, request.projectId, request.options)
      return result
    })

    ipcMain.handle('fs:watch-start', async (_event, request: IPCRequest<'fs:watch-start'>) => {
      const result = await this.projectFileSystem.startWatch(request.path, request.projectId, request.options)
      return result
    })

    ipcMain.handle('fs:watch-stop', async (_event, request: IPCRequest<'fs:watch-stop'>) => {
      const result = await this.projectFileSystem.stopWatch(request.watcherId)
      return result
    })

    logger.info('File system IPC handlers registered')
  }

  private registerProjectManagementHandlers() {
    // ÂàõÂª∫È°πÁõÆ
    ipcMain.handle('project-mgmt:create', async (_event, request: IPCRequest<'project-mgmt:create'>) => {
      const result = await this.projectManager.createProject(request)
      return result
    })

    // È™åËØÅÈ°πÁõÆ
    ipcMain.handle('project-mgmt:validate', async (_event, request: IPCRequest<'project-mgmt:validate'>) => {
      const result = await this.projectManager.validateProject(request.projectPath)
      return result
    })

    // Âø´ÈÄüÈ™åËØÅÈ°πÁõÆ
    ipcMain.handle('project-mgmt:quick-validate', async (_event, request: IPCRequest<'project-mgmt:quick-validate'>) => {
      const result = await this.projectManager.quickValidateProject(request.projectPath)
      return result
    })

    // Ëé∑ÂèñÈ°πÁõÆÊ®°Êùø
    ipcMain.handle('project-mgmt:get-templates', async () => {
      const result = await this.projectManager.getTemplates()
      return result
    })

    // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ÂàùÂßãÂåñ
    ipcMain.handle('project-mgmt:can-initialize', async (_event, request: IPCRequest<'project-mgmt:can-initialize'>) => {
      const result = await this.projectManager.canInitialize(request.directoryPath, request.templateId)
      return result
    })

    // ÂàùÂßãÂåñÁé∞ÊúâÁõÆÂΩï
    ipcMain.handle('project-mgmt:initialize-existing', async (_event, request: IPCRequest<'project-mgmt:initialize-existing'>) => {
      const initOptions = {
        directoryPath: request.directoryPath,
        projectName: request.projectName,
        novelTitle: request.novelTitle,
        author: request.author,
        genre: request.genre,
        timestamp: request.timestamp
      }
      if (request.description) {
        Object.assign(initOptions, { description: request.description })
      }
      if (request.customConfig) {
        Object.assign(initOptions, { customConfig: request.customConfig })
      }
      const result = await this.projectManager.initializeExistingDirectory(initOptions)
      return result
    })

    // ‰øÆÂ§çÈ°πÁõÆ
    ipcMain.handle('project-mgmt:repair', async (_event, request: IPCRequest<'project-mgmt:repair'>) => {
      const result = await this.projectManager.repairProject(request.projectPath)
      return result
    })

    // Ëé∑ÂèñÈ°πÁõÆÁªüËÆ°
    ipcMain.handle('project-mgmt:get-stats', async (_event, request: IPCRequest<'project-mgmt:get-stats'>) => {
      const result = await this.projectManager.getProjectStats(request.projectPath)
      return result
    })

    logger.info('Project management IPC handlers registered')
  }

  /**
   * ‰ªéevent.senderËØÜÂà´Á™óÂè£Âπ∂ÊâßË°åÊìç‰ΩúÔºàÊé®ËçêÊñπÂºèÔºâ
   */
  private handleWindowOperationFromEvent(
    event: Electron.IpcMainInvokeEvent,
    operation: 'minimize' | 'maximize' | 'unmaximize' | 'close' | 'focus',
    request: { windowId?: string }
  ): WindowOperationResult {
    const process = this.resolveWindowProcessFromEvent(event, request.windowId)
    if (!process) {
      return { success: false, error: 'Window not found' }
    }

    switch (operation) {
      case 'minimize':
        process.window.minimize()
        break
      case 'maximize':
        process.window.maximize()
        break
      case 'unmaximize':
        process.window.unmaximize()
        break
      case 'close':
        process.window.close()
        break
      case 'focus':
        process.window.focus()
        break
    }

    return { success: true }
  }

  /**
   * ÊóßÁâàÊú¨Ôºö‰ΩøÁî®request.windowIdËØÜÂà´Á™óÂè£Ôºà‰øùÁïôÁî®‰∫éÂÖºÂÆπÔºâ
   */
  private handleWindowOperation(
    operation: 'minimize' | 'maximize' | 'unmaximize' | 'close' | 'focus',
    request: { windowId?: string }
  ): WindowOperationResult {
    const process = this.resolveWindowProcess(request.windowId)
    if (!process) {
      return { success: false, error: 'Window not found' }
    }

    switch (operation) {
      case 'minimize':
        process.window.minimize()
        break
      case 'maximize':
        process.window.maximize()
        break
      case 'unmaximize':
        process.window.unmaximize()
        break
      case 'close':
        process.window.close()
        break
      case 'focus':
        process.window.focus()
        break
    }

    return { success: true }
  }

  /**
   * ‰ªéevent.senderËØÜÂà´Á™óÂè£ËøõÁ®ãÔºàÊé®ËçêÊñπÂºèÔºâ
   * ‰ºòÂÖà‰ΩøÁî®windowIdÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÈÄöËøáevent.senderÊü•Êâæ
   */
  private resolveWindowProcessFromEvent(
    event: Electron.IpcMainInvokeEvent,
    windowId?: string
  ): WindowProcess | null {
    if (!this.windowManager) return null

    // Â¶ÇÊûúÊèê‰æõ‰∫ÜwindowIdÔºå‰ºòÂÖà‰ΩøÁî®
    if (windowId) {
      return this.windowManager.getProcess(windowId)
    }

    // ‰ªéevent.senderËé∑ÂèñÂèëÈÄÅËØ∑Ê±ÇÁöÑÁ™óÂè£
    const senderWindow = BrowserWindow.fromWebContents(event.sender)
    if (!senderWindow) {
      return null
    }

    // ÈÄöËøáÁ™óÂè£IDÊü•ÊâæÂØπÂ∫îÁöÑËøõÁ®ã
    return this.windowManager.getProcessByWindowId(senderWindow.id)
  }

  /**
   * ÊóßÁâàÊú¨Ôºö‰ΩøÁî®windowIdËØÜÂà´Á™óÂè£Ôºà‰øùÁïôÁî®‰∫éÂÖºÂÆπÔºâ
   */
  private resolveWindowProcess(windowId?: string): WindowProcess | null {
    if (!this.windowManager) return null
    if (!windowId) {
      return this.getMainProcess()
    }
    return this.windowManager.getProcess(windowId)
  }

  private getMainProcess(): MainWindowProcess | null {
    const direct = this.windowManager?.getMainProcess?.()
    const process = direct ?? this.windowManager?.getProcess('main')
    return process && process.type === 'main' ? process : null
  }

  private getProjectProcessByPath(projectPath: string): ProjectWindowProcess | null {
    if (!this.windowManager) return null
    const direct = this.windowManager.getProjectProcessByPath?.(projectPath)
    if (direct) {
      return direct
    }

    const process = this.windowManager.getProcess(projectPath)
    if (process && process.type === 'project' && process.projectPath === projectPath) {
      return process
    }

    return null
  }
}
