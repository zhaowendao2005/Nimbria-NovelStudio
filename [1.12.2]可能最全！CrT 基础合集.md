[1.12.2]可能最全！CrT 基础合集
 目录:
1 前言
2 ZenScript 基础
2.1 编写第一个脚本
2.2 日志文件格式
2.3 注释
2.4 特殊术语
3 信息技术基础
3.1 局部变量
3.2 基本数据类型
3.2.1 整型
3.2.2 浮点型
3.2.3 布尔型
3.2.4 无类型
3.2.5 其余事项
3.3 基本运算
3.3.1 赋值
3.3.2 数学运算
3.3.3 逻辑运算
3.3.4 运算错误
4 Crafttweaker 基础
4.1 尖括号调用
4.2 普通数据类型
4.3 导入模块
4.4 数组
4.5 多维数组
4.6 关联数组
4.6.1 简单映射
4.6.2 IData和DataMap
4.6.3 NBT操作
4.7 循环和遍历
4.7.1 for 循环
4.7.2 while 循环
4.7.3 foreach 循环
4.7.4 break 与 continue
4.8 in/has 操作符
4.9 条件函数
4.9.1 单 if 结构
4.9.2 if - else 结构
4.9.3 if - else - if 结构
4.10 三元操作符
4.11 全局函数
4.12 全局和静态变量
4.12.1 声明全局和静态变量
4.12.2 可修改的全局和静态变量
4.13 预处理器
4.14 自定义函数
4.15 扩展方法
4.16 跨脚本调用
5 配方修改
5.1 工作台配方
5.1.1 添加有序合成配方
5.1.2 添加无序合成配方
5.1.3 移除工作台配方
5.2 熔炉配方
5.2.1 添加熔炉配方
5.2.2 移除熔炉配方
5.2.3 熔炉燃料
5.3 矿物辞典
5.3.1 矿辞诞生
5.3.2 矿辞用法
6 事件导论
6.1 事件概念
6.2 事件管理器
6.3 查阅官方文档的方法
6.4 部分实例展示
6.4.1 禁止爬行者生成
6.4.2 禁止玩家使用指令
6.4.3 作弊模组检测
7 CraftTweaker 游戏内命令
7.1 前缀及作用
7.2 命令列表
8 模组联动
8.1 Content Tweaker
8.1.1 ContentTweaker 游戏内命令
8.1.2 资源文件夹
8.1.3 材质学基础
8.1.4 创建一个方块
8.1.5 创建一个物品
8.1.6 创建一个流体
8.1.7 创建匠魂材料
8.1.8 自定义匠魂材料特性
8.1.9 自定义匠魂盔甲材料特性
8.1.9.1 事件总览 - ArmorTraitBuilder 提供
8.2 ModTweaker
8.2.1 教程格式
8.2.2 实用拓展 - Actually Additions
8.2.3 Better With Mods
8.2.4 血魔法2 - Blood Magic 2
8.2.5 植物魔法 - Botania
8.2.5.1 植物魔法相关命令
8.2.5.2 植物魔法辞典
8.2.5.3 植物魔法配方修改
8.2.6 凿子 - Chisel
8.2.7 更多实用设备2 - Extra Utilities 2
8.2.8 林业 - Forestry
8.2.9 灵感 - Inspirations
8.2.10 精致存储 - Refined Storage
8.2.11 匠魂2 - Tinkers' Construct 2
8.2.11.1 匠魂2相关命令
8.2.11.2 匠魂2相关尖括号调用
8.2.11.3 匠魂2配方修改
8.2.12 匠魂补充 - Tinkers' Complement
8.2.13 神秘时代6 - Thaumcraft 6
8.2.13.1 要素与要素类
8.2.13.2 神秘时代相关命令
8.2.13.3 神秘时代配方修改
8.2.14 热力膨胀5 - Thermal Expansion 5
8.2.14.1 各类能源炉配方修改
8.2.14.2 冷却剂管理
8.2.14.3 热力机器配方修改
9 更新说明
10 参考资料 特别致谢
本篇教程由作者设定使用 CC BY-NC-SA 协议。

前言

本教程目的在于一次性讲清楚crt的基础知识。

如果你吃透了本篇教程，相信你一定可以自己动手写脚本了，而且不是简单的配方添加，是更高级的运用。

详细的参考资料见文末！

ZenScript 基础

ZenScript 是一种脚本语言，可以看做 C++ 和 Java 等编程语言的同类。

以“;”表示一个代码语句的完成。

编写第一个脚本

在对应版本文件夹的根目录下找到 scripts 文件夹，新建 txt 文件，随后把后缀改为 .zs

使用 VScode 或其他文本编辑器打开文件，并输入下列语句：

1
print("Hello world!");
现在加载 Minecraft，可在 crafttweaker.log 文件中看到该语句的执行效果(即在日志中输出 Hello world!)

日志文件格式

日志文件在其输出中使用特定的格式，该格式为：

[LOADERSTAGE(加载阶段)][SIDE(加载端)][TYPE(严重程度)] <message>

加载端分为：客户端(CLIENT) 和 服务端(SERVER)

严重程度由轻到重依次为：一般信息(INFO)，警告(WARN)，错误(ERROR)，致命(FATAL)

使用上文的示例，输出将是：

1
[PREINITIALIZATION][CLIENT][INFO] Hello world!
意思是说在预初始化阶段，客户端输出了一条一般信息，内容为 Hello world!

日志格式的目的是便于调试，唯一不使用该格式的时候是用于命令转储，在这种情况下，它只是打印消息，这样做是为了复制粘贴转储更容易。

注释

注释可使脚本文件更具可读性和更易于理解！

ZenScript 支持3种类型的注释，分别是：

单行注释：

1
// 我是单行注释
另一种单行注释：

1
# 我也是单行注释
多行注释（斜杠和星号间没有空格）：

1
2
/ * 我是
多行注释 * /
注释的语句是给人阅读的，程序加载时不会读取注释语句！

有些代码写出来会报错，但可能是你好长一段时间的奋斗成果，如果还想继续下去，不想直接删去，就可以先把代码注释掉。

特殊术语

ZenGetter

一种从对象中获取信息的方式。

例如获取物品铁锭的显示名字，就要用 ZenGetter：

1
<minecraft:iron_ingot>.displayName
ZenSetter

ZenSetter 的工作方式与 ZenGetter 几乎相同，唯一的区别是ZenSetter是设置属性，而ZenGetter是获取信息。

例如将铁锭的显示名设置为“silver”，就要用 ZenSetter：

1
<minecraft:iron_ingot>.displayName = "silver";
ZenMethod

ZenMethod 就是实打实的方法，需要参数，会执行一些特殊的东西。可能不返回值，也可能会返回。具体看各个 ZenMethod 的描述。

信息技术基础

局部变量

程序中，许多数据都会以“变量”的形式出现。

如果说数据是一辆辆车，那么变量就是一个个停车位。变量是用来存储数据的。

在 ZenScript 中，我们可以使用如下代码声明局部变量：

1
var a as int = 0;
其中，var 是声明局部变量的关键字，告诉程序我们要开始声明局部变量了。

a 是变量的名字，每个变量都需要起名。变量的命名具有一定的规范性，可以使用“小驼峰”命名，也可以使用下划线将单词间隔开。

小驼峰命名：myFirstName

下划线命名：my_first_name

有关变量命名的规范性可以自行查阅相关资料。

变量名不要出现中日韩统一表意文字中的任意字符！

0 是一个数据，在这里是变量 a 的初始值。初始值可以按照需要任意赋值，但是声明变量必须具有初始值！

as int 是 ZenScript 中转换数据类型的方法，可以将数据的类型转为 int 类型。

局部变量只能在当前脚本中使用，在其他脚本文件中无法调用局部变量。

基本数据类型

刚刚我们声明局部变量时接触到了数据类型的概念，在此我们简单介绍一下基本数据类型。

基本数据类型为最最基础的，直接存储一个值的。它们没有任何方法、ZenGetter、ZenSetter可用。

每一个数据都有其各自的类型，在 ZenScript 中，有下面八种基本数据类型：

整型

表示整数，有byte, short, int, long四种类型，整数默认就是int类型

byte: 使用1个字节，8位，256种形态，值域为[-128, 127] ∈Z

short: 使用2个字节，16位，65536种形态，值域为[-32768, 32767] ∈Z

int：使用4个字节，32位，4294967296种形态，值域为[-2147483648, 2147483647] ∈Z

long：使用8个字节，64位，18446744073709551616种形态，值域为[-9223372036854775808, 9223372036854775807] ∈Z

浮点型

表示小数，有float, double两种类型，小数默认就是double类型

float：使用4个字节，32位，单精度，能精确到6-7位小数，值域为 {-∞}∪[-2^128, -2^-149]∪{0}∪[2^-149, 2^128]∪{+∞}

double：使用8个字节，64位，双精度，能精确到15-16位小数，值域为{-∞}∪[-2^1024, -2^-1074]∪{0}∪[2^-1074, 2^1024]∪{+∞}

注意：令0.0除以0.0会导致计算错误，返回NaN非数值

布尔型

表示真假，只有true和false两个值，有bool一种类型

无类型

表示null，用于函数或方法以表明该函数或方法无返回值，有void一种类型

其余事项

在定义变量的时候，多使用“as 数据类型”这样的语句来避免不必要的报错。

可以在一些数据后面加上字段来表明该数据的数据类型，例如：

0.0f就表示float类型的0.0，同理：d表示double类型，l表示long类型。

基本运算

赋值

在 zenScript 中，使用“=”进行赋值。

赋值就是将变量的值设为指定值的操作，是一个“设置”的动作，和数学中的“等于”有一定区别。

数学运算

在 zenScript 中，使用“+”，“-”，“*”，“/”，“%”，“~”来完成加、减、乘、除、取余、连接字符串的运算操作。

在运算符后面跟一个“=”，变成类似于“+=”，“-=”之类的符号，称为赋值运算符，进行自运算。

a += 1 等价于 a = a + 1

使用自运算可大幅度简化一些脚本。

逻辑运算

在 zenScript 中，使用“&&”，“||”，“^”，“!”，“==”，“!=”，“<”，“<=”，“>”，“>=”

来完成与、或、异或、非、相等、不等于、小于、小于等于、大于、大于等于的逻辑运算操作。

运算错误

当数学运算结果发生意外时，很有可能是你使用不同类型的数字。 比如 13 % 6.5 结果为 1，可是正确结果应该是 0 啊，究竟发生了什么？

ZenScript 总是会对运算的两个数据类型进行处理，使其成为相同类型。在上述例子中，它就会将第二个数据转换，用以匹配第一个数据。

在上述例子中，计算就会处理成 13 % 6，第二个数字（双精度浮点型）就会被强制转换为第一个数字的类型（整型）。

可以将13转为 double 类型以避免运算出错。

Crafttweaker 基础

尖括号调用

Zenscript 用<>来表示游戏的一个对象。比如物品、矿辞。

通过在尖括号内的字符串，可以获取游戏内的特定物品、矿辞。

例子：

1
2
3
4
5
<item:minecraft:apple>  // 获取苹果物品(IItemStack) 这里的 item: 可省略
<ore:ingotIron> //获取铁锭矿辞(IOreDictEntry)
<entity:minecraft:creeper> //获取原版苦力怕实体定义(IEntityDefinition)
<blockstate:minecraft:stone> //获取原版石头方块状态(IBlockState)
<potion:minecraft:speed> //获取原版速度效果(IPotion)
可以在 id 后加上 Meta 值，Meta 值就是使用 /give 指令需要的特殊值。

例如 <minecraft:wool:14> 就表示红色羊毛，而非白色羊毛。

工具的耐久也属于 Meta 值。

Meta 值允许使用 * 通配符，以表示所有 Meta 值。

在尖括号后加上 .withTag()，可在小括号中写入该物品的 NBT 数据。

普通数据类型

和基本数据类型类似，但是普通数据类型一般可以对其使用 ZenGetter、ZenSetter 和 ZenMethod。

对于原版 Minecraft 的所有普通数据类型，可以在 CraftTweaker 官方文档的 vanlia 子目录中找到：https://docs.blamejared.com/1.12/zh/index

常见的普通类型有：

字符串(string)：文本，可以使用“==”等逻辑运算符

物品栈(IItemStack)：一个物品，如<minecraft:stone>

材料(IIngredient)：一个或多个物品，如<minecraft:stone>、<ore:ingotIron>

矿物辞典(IOreDictEntry)：一个矿辞代表的多个物品，如<ore:ingotIron>

流体栈(ILiquidStack)：一种流体，如<liquid:water>

导入模块

一般地，使用除 string 类型外的其他普通类型，非全局函数，以及事件函数等等，都需要导入模块。

导入模块使用 import 关键字，并且必须处在脚本文件的开头。

例如：

1
import mods.jei.JEI;
这将从模组Just Enough Items中导入JEI模块。

导入 JEI 整个模块后，我们就能够使用这个模块下的所有函数(方法)了，当然在使用 JEI 模块的函数是需要指定模块。

例如：

1
JEI.hide(<minecraft:diamond>);
这将从JEI显示页面中隐藏钻石。

我们也可以在导入模块的时候直接导入hide函数，这样就不需要在使用时指定模块了

例如：

1
import mods.jei.JEI.hide;
如此一来，上述脚本可以直接写成：

1
hide(<minecraft:diamond>);
在导入模块时使用as关键字，可以自定义该模块的名称。

1
import mod.jei.JEI.hide as h;
这样就把hide函数重命名为h函数，上述脚本便可直接写成：

1
h(<minecraft:diamond>);
数组

在高中数学必修一中，我们接触到集合这一概念，实际上在信息技术中，集合可以类比数组。

数组是一个容器，一个数组存储的元素的类型都是相同的。

你可以往数组里存取数据，也可以修改数组里的数据。

你可以为数组指定初始元素，也可以不指定。

与集合不一样的是，数组里的元素具有顺序，可重复。

举例：

1
2
3
4
var array1 as int[] = [];   //定义一个 int 类型的数组，没有初始元素
var array2 as int[] = [10,20,30];   //定义一个 int 类型的数组，有三个初始元素
var strings as string[] = ["apple","carrot"];   //定义一个 string 类型的数组，有两个初始元素
var items as IItemStack[] = [<minecraft:apple>,<minecraft:carrot>];   //定义一个 IItemStack 类型的数组，有两个初始元素
数组里的元素都具有下标，你可以通过下面的方式为数组添加元素，或修改数据。

1
2
3
var numbers as int[] = [10,20,20];   // 定义一个 int 类型的数组，有三个初始元素
numbers[2] = 30;   // 将下标为 2 的元素修改为 30 
numbers += 40;   // 往数组的末尾添加一个元素
这样修改后的数组就变为：[10,20,30,40]

注：数组第一个元素的下标为 0，往后为 1, 2, 3......以此类推。

数组有一个length属性，返回数组的元素个数。

1
2
var array as int[] = [2,4,6,8];
print(array.length); // array 的元素个数为 4，输出 4
多维数组

在集合中，我们见过这种东西：{{1,2,3},{0,-1,-2}}

可以看到，一个大集合中有着两个小集合。

这个概念类比到数组上就是多维数组，简而言之就是数组套数组。

举例：

1
2
3
4
5
var array as int[][] = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
关联数组

简单映射

关联数组是一种特殊的数组，内部存储的是“键值对”，目的是令键(key)和值(value)一一对应。

关联数组没有下标，取代下标的是 key(键)。

你可以用 ZenScript 的任何数据类型作为 key (除了数组)。

键值对的形式为 key: value，键在前，值在后。

可使用变量作为 key，变量名会被解析为字符串。

数组可以作为 value，但不可以作为 key。

举例：

1
2
3
4
5
6
var map as IItemStack[string] = {
    gold : <minecraft:gold_ingot>,
    iron : <minecraft:iron_ingot>,
    diamond : <minecraft:diamond>
};
// 定义一个名称为 map 的关联数组，key 为 string 类型，value 为 IItemStack 类型
这样每个字符串就和物品堆一一对应，我们就可以使用 map[iron] 来获得 <minecraft:iron_ingot>。

使用 ZenSetter 就可以更改关联数组内键所对应的值了。

有人说，我老是在定义关联数组时把键和值的数据类型写反，怎么巧记？

很简单，联系一下我们之前将的下标，既然所谓的“键”取代了原来的下标，那么方括号里的自然是键的数据类型，而不在方括号内的就是值的数据类型。

IData和DataMap

以下内容在尽量掌握本章其他内容以后，再进行阅读！

说关联数组却不说NBT操作，如同隔靴搔痒，没有灵魂。

IData数据有其特定的访问规则，涉及NBT数据的修改需要依赖IData。

你可以使用声明局部变量的语句来声明IData变量，但请注意，必须在等号的左右两端都加上“as IData”。

示例：

1
var whitelist as IData = ["help", "say", "msg"] as IData;
Crafttweaker中的IData类是较为特殊的一种数据类型，其内部包装了很多数据类型，可谓包罗万象。

IData类包含的数据类型及其对应的原数据类型如下表：

DataType	Type
DataInt
int
DataFloat
float
DataDouble
double
DataBool
bool
DataString
string
DataByte
byte
DataShort
short
DataLong
long
DataInt[]
int[]
DataByte[]
byte[]
DataList
list
DataMap
map
同时，这些数据可以进行运算操作，但具体支持哪些运算操作需查看官方文档：https://docs.blamejared.com/1.12/en/Vanilla/Data/IData/

而DataMap就是IData类中比较特殊的一种数据类型，其本质上是一个关联数组，但它的键必须是字符串，值可以是任意IData类内的数据类型。

请注意，在DataMap的键中，不带有[]和.的关键字会直接被解读为字符串，而不会调用该变量！请避免用变量向DataMap传入键。

大多数NBT结构是DataMap的多层嵌套，尽管DataMap允许嵌套，但不允许使用递归。如下实例：

1
2
3
4
5
6
7
8
9
10
var map1 as IData = {
    "key0": {
        "key1": "value1"
    } as IData
} as IData;
// 以上为嵌套结构, 合法
var map2 as IData = {
    "key": map2
} as IData;
// 以上为递归结构，非法
你可以通过 <IData>.memberGet(key) 和 <IData>.key 来访问DataMap内部的数据。

第一种方法相较于第二种方法更为稳妥，其中key为字符串，表示目标键名

如果需要访问的目标键不存在，程序会抛出空指针异常，所以在访问前必须进行空指针检查！

你可以使用 !isNull(DataMap.memberGet(key)) 和 !(DataMap has key) 来进行空指针检查。

DataMap类型本身可以进行+和-的运算操作，二者运算规则如下：

+：检查两个DataMap中的键，保留所有非共有键的键值对，而后对共有键的值进行对比，若不均为DataMap则后者的值覆盖前者，否则保留该键，并将两个DataMap相加（回到第一步）的结果作为新的值

-：检查不存在于第二个DataMap的第一个DataMap里的键，保留其键值对，而后对共有键的值进行对比，若不均为DataMap则前者裁去此键对应的键值对，直至所有共有键对应的键值对被裁去或自身为“空”的DataMap，否则保留该键，并将两个DataMap相减（回到第一步）的结果作为新的值

IData还提供了一个update()函数，其返回更新后的IData，在DataMap运算时相当于+操作。

NBT操作

对于NBT中的数据，我们不能通过赋值操作直接修改它的值，但是可搭载NBT的对象所提供的update函数可以更新该对象的NBt

我们需要做的，是在逐一进行空指针检查后，探清楚目标NBT的结构，仿照该结构写出自己的IData，然后通过update来更新NBT数据。

此处的update操作可以理解为，将原DataMap和新DataMap进行+操作，因为键相同，所以实现了替换操作。

通过安装Zen Utils模组来获得更深度的NBT修改效果！

实例：修改凋灵的最大生命值并通过NBT修改的方式使凋灵的初始生命值等于最大生命值（省略导包）：

1
2
3
4
5
6
7
8
9
10
11
12
static map as IData[string] = {
    "minecraft:wither" : 8000.0
} as IData;
events.onEntityJoinWorld(function(event as EntityJoinWorldEvent) {
    var definition = event.entity.definition;
    if(!isNull(definition) && !isNull(map[definition.id]) && map[definition.id] > 0 && event.entity instanceof IEntityLiving) {
        var living as IEntityLiving = event.entity;
        living.getAttribute("generic.maxHealth").setBaseValue(map[definition.id]);
        living.updateNBT({Health: map[definition.id]});
        // Health 是每个生物实体都有的NBT数据，省略空指针检查
    }
});
实例：拥有匠魂进化电力装载词条的物品在主手时可以消耗 640RF 来修复 1 点耐久（省略导包）：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
function isTconstructElectricityItem(item as IItemStack) as bool {
    if (!isNull(item.tag) && !isNull(item.tag.memberGet("TinkerData")) && !isNull(item.tag.memberGet("EnergizedEnergy"))) {
        return true;
    }
    return false;
}
function getTconstructElectricity(item as IItemStack) as int {
    if (isTconstructElectricityItem(item)) {
        return item.tag.memberGet("EnergizedEnergy").asInt();
    }
}
function setTconstructElectricity(item as IItemStack, amount as int) as void {
    if (isTconstructElectricityItem(item)) {
        var electricityData as IData = {"EnergizedEnergy": amount} as IData;
        item.mutable().updateTag(electricityData);
    }
}
events.onPlayerTick(function(event as crafttweaker.event.PlayerTickEvent){
    var player as IPlayer = event.player;
    if (!isNull(player.currentItem)) {
        var handItem as IItemStack = player.currentItem;
        if (isTconstructElectricityItem(handItem) && (handItem.tag.memberGet("EnergizedEnergy") >= 640) && (handItem.damage > 0)) {
            var newElectricity as int = getTconstructElectricity(handItem) - 640;
            setTconstructElectricity(handItem, newElectricity);
            handItem.mutable().attemptDamageItem(-1);
        } else {
            return;
        }
    }
});
循环和遍历

for 循环

for 循环又叫“计数循环”，允许一段代码多次执行，同时能增强脚本的可读性。

让我们看看一个普通 for 循环如何使用：

1
2
3
4
5
6
7
8
for i in 0 .. 10 {
    print(i);
}
for i in 0 to 10 {
    print(i);
}
// print() 函数都会被执行 10 次，依次输出： 0, 1, 2, 3, 4, 5, 6, 7, 8, 9。
// 第一种书写和第二种书写没有区别，你可以任意选择，我个人喜欢用 to。
以上两个例子的执行结果都相同，其中：

i 是一个变量，每次循环结束，它的数值都会 +1。从 0 开始，直到 10 结束，但不包括 10，处于一个左闭右开的区间中。

每次循环都会执行大括号内的语句，你也可以写多条语句。

通过 for 循环，我们可以进行遍历数组的操作：

1
2
3
4
5
var numbers as int[] = [2, 4, 8, 16, 32, 64];
for i in 0 to numbers.length {
    print(numbers[i]);
}
// 输出 2, 4, 8, 16, 32, 64
while 循环

while 循环又叫“条件循环”，也可以多次执行代码。

当小括号内的判断表达式为 true 时，便会执行大括号内的语句，然后再次判断表达式，true 则继续循环，false 则不执行循环。

让我们看看一个普通 while 循环如何使用：

1
2
3
4
5
6
var i as int = 0;
while (i <= 10) {
    print(i);
    i += 1;
}
// print() 函数会执行 11 次，依次输出 i 为: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
foreach 循环

foreach 循环又叫“增强 for 循环”，用来遍历数组，可读性高，不需要下标，遍历数组中的每一个元素。

定义一个数组并遍历：

1
2
3
4
var numbers as int[] = [2, 4, 8];
for number in numbers {
    print(number); // 输出 2, 4, 8
}
定义一个关联数组并遍历：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
var map as string[int] = {
    1 : "一",
    2 : "二",
    3 : "三",
    4 : "四"
};
// key 遍历法
for key in map {
    print(key); // 输出 1, 2, 3, 4
}
// key-value 遍历法
for key, value in map {
    print(key ~ "-->" ~ value); // 输出 1-->一, 2-->二, 3-->三, 4-->四
}
// entry 遍历法
for entry in map.entrySet {
    print(entry.key ~ "-->" ~ entry.value); // 输出 1-->一, 2-->二, 3-->三, 4-->四
}
break 与 continue

break 与 continue 都可以在 for 循环和 while 循环中使用。

执行到 break 语句后将直接结束当前循环。

1
2
3
4
5
6
7
8
for i in 0 to 5 {
    if (i == 3) {
        break;
    } 
    print(i);
}
// i 等于 3 时，执行 break，结束循环
// 输出 0, 1, 2
执行到 continue 语句后，跳出本次循环，并进入下一次循环。

1
2
3
4
5
6
7
8
for i in 0 to 5 {
    if (i == 3) {
        continue;
    }
    print(i);
}
// i 等于 3 时，执行 continue，跳出当前循环，并进入下一次循环
// 输出 0, 1, 2, 4, 5
in/has 操作符

你可以用 in/has 操作符来判断 A 是否包含 B。下列的示例中的 in 均可以替换为 has。

1
2
3
4
5
6
7
8
//检测加载模组
if (loadedMods in "thermalfoundation") {
    print("热力基本mod已被加载");
}
//检测材料对象
if (<ore:ingotIron> in <minecraft:iron_ingot>) {
    print("铁锭的矿物词典是正确的！");
}
请注意分清左右两个参数：只有当所有在 in 之后的对象可以在 in 之前的对象找到时，结果才为 true。用 has 可能更符合英语语法，更加便于理解。

条件函数

if 关键字是书写条件语句判定条件的部分，当小括号内的表达式为 true 时，就会执行 if 大括号内的代码块。

注意，两个等号才是比较运算符，一个等号是赋值运算符！

单 if 结构

if 小括号内的表达式也叫判断表达式。

代码块由语句组成。代码块可以有多条语句，可以只有一条语句，也可以没有语句。

1
2
3
4
5
6
7
8
9
10
11
12
//第一个例子
if (1 >= 0) {   // 判断表达式为 true
    print("1大于等于0！");   // 执行 if 大括号内的语句
}
//第二个例子
if (1 == 1) {   // 判断表达式为 true
    print("1等于1！");   // 执行 if 大括号内的语句
}
//第三个例子
if (1 < 0) {   // 判断表达式为 false
    print("1小于0！");   // 不执行 if 大括号内的语句
}
if - else 结构

else 关键字可以作为条件语句的后半部分，当 if 判断表达式为 false 时，就会执行else大括号内的代码块。

1
2
3
4
5
6
7
8
9
10
11
12
//第一个例子
if (1 >= 0) {  // 判断表达式为true
    print("1大于等于0！");  // 执行 if 大括号内的语句
} else {
    print("1小于0！");   // 不执行 else 大括号内的语句
}
//第二个例子
if (1 < 0) {  // 判断表达式为false
    print("1小于0！");  // 不执行 if 大括号内的语句
} else {
    print("1不小于0！");  // 执行 else 大括号内的语句
}
if - else - if 结构

如果else后再接着判断条件呢？你可以使用 if-else-if。

1
2
3
4
5
6
7
8
9
var mark as int = 90;   // 定义一个成绩，分数为90
if (mark < 60) {   // 第一次判断，分数是否低于60
    print("成绩不及格");   // 90不低于60，不执行此处语句
}
else if (mark < 90) {   // 第一次判断为false，进行第二次判断，分数是否低于90
    print("成绩及格");   // 90不低于90，不执行此处语句
} else {
    print("成绩优秀");   //执行此处语句，输出"成绩优秀"
}
所有的条件控制语句都可以嵌套使用，你可以在一个条件控制语句的代码块里再写条件控制。

嵌套三层以上的if可读性会越来越差，不推荐使用过多的嵌套。

三元操作符

对于一些简单的判断，却需要用 if else 写好几行，不嫌麻烦吗？可以用三元操作符，简化操作。

举例：

1
2
c = flag ? a : b;
//如果 flag 为 true，则将 c 赋值为 a，反之为 b
全局函数

全局函数是无需导入即可调用的函数。

以下是所有的全局函数：

print

将字符串信息打印到 CraftTweaker 的日志中。

格式：print(String message);

举例：print("Hello World!");

无返回值

totalActions

返回一个 int，显示注册了多少个全局函数。

格式：totalActions();

举例：totalActions();

enableDebug

启用调试模式。

不过，最好使用调试预处理器。

格式：enableDebug();

举例：enableDebug();

无返回值

isNull

检测对象是否为 null，经常用这个规避空指针异常。

对基本数据类型对象(int，float 等)无效。

格式：isNull(Object);

举例：isNull(<minecraft:dirt>);

返回一个 bool

instanceof

检测对象是否为某数据类型

格式：variable instanceof type;

举例：entity instanceof IEntity;

返回一个 bool

max

返回较大的数

格式：max(int number1, int number2);

举例：max(10, 11);  //得到 11

min

返回较小的数

格式：min(int number1, int number2);

举例：min(10, 11);  //得到 10

pow

返回一个double，值为 number1 的 number2 次方

格式：pow(double number1, double number2);

举例：pow(2.0, 4.0);  //得到 16

全局和静态变量

声明全局和静态变量

声明全局变量或静态变量非常简单。注意 “as 数据类型” 不能省略，且已定义的全局、静态变量之后不能再次定义，修改其类型或值。

全局变量可以直接在其他脚本中使用，静态变量还需要跨脚本调用。

1
2
3
4
// 定义一个全局变量
global stone as IItemStack = <minecraft:stone>;
// 定义一个静态变量
static dirt as IItemStack = <minecraft:dirt>;
含有全局变量的脚本需要用优先级预加载器保证其优先加载。

局部变量可以覆盖全局变量。

全局变量可以在任何地方直接调用，但坏处就是你可能不记得该变量的定义处在哪里。

静态变量的使用需跨脚本引用，但好处就是很容易知道该变量是在哪个脚本里定义的，容易维护。

可修改的全局和静态变量

有一个方法可以绕过全局、静态变量定义后不能再次修改的窘境。

1
2
3
4
5
6
// 在脚本中定义一个静态数组
static array as int[] = [1];
// 修改数组内第一个元素的值
array[0] = 10;
// 输出数组第一个元素的值
print(array[0]);
尽管 array as int[] 这个数组不能再次定义和修改其类型，但数组内部的元素还是可以修改的。

不只是数组，你也可以定义一个静态的关联数组，尽管该关联数组不能再次定义和修改类型，但是同样可以多次修改其内部的数据。

预处理器

预处理器会在脚本执行之前执行。

它们可以执行各种行动：比如启用调试模式或者不显示尖括号调用错误。

预处理器需要用 # 注释 函数来调用。

因而写注释一定要注意，因为可能会写一条包含预处理器关键字的注释。

注：全局使用表示只需要一个脚本有该预处理器，所有脚本均会受到该处理器的影响。

#debug

将会在 generated 文件夹内输出所有脚本编译出的 class 文件

可全局使用

#ignoreBracketErrors

忽略尖括号引用错误(当物品ID什么的打错不会报错，而是改为null)

不可全局使用

#loader loaderName

设定脚本加载器，默认脚本自带#loader crafttweaker

不可全局使用

#modloaded modID

只有指定的 mod 加载时这个脚本才会加载，可以设定多个 modID，也可以取非值(modid前面加感叹号)

不可全局使用

#norun

脚本将不会加载，虽然使用/ct syntax命令还是会检测其的语法错误

不可全局使用

#priority number

设定脚本加载优先级，数字越大越先加载。优先度一样的脚本，将按字母顺序依次加载

不可全局使用

#ikwid

脚本产生的警告和错误将只在日志中打印出来，不会在游戏中显示

可全局使用

#sideonly sideName

sideName 可使用 client 或 server，指定该脚本只在客户端或服务端中运行

不可全局使用

#profile

会在日志打印出每次修改配方的花费的时间

可全局使用

#disable_search_tree

禁用加载脚本前的配方表的重新计算，可能能加快脚本加载速度

可全局使用

自定义函数

有时 CraftTweaker 本身以及它的附属提供的函数根本不够用。接下来我们将会讲解如何构建自定义函数！你甚至可以在函数中嵌套函数。

基本格式：

1
2
3
4
function 函数名(参数表) as 返回类型名 {
    [代码]
    return 函数返回值;
}
然而事实上，只有 function 关键字和函数名是必要的，若是一个不需要参数的函数，则不需要参数表，只有一对小括号。

若不需要返回值，则不需要 “as 返回类型名” 和 “return” 。

如果这个函数需要的代码只需要一行，直接写在 return 所在的一行即可，不需要其他代码。

return 关键字将会把指定的值返回至函数的调用点上，执行后续操作。

若函数处理时碰到 return，程序将跳出函数，不再执行之后的函数内操作。所以一般 return 会在函数代码的最下方。

举例：

1
2
3
4
5
6
7
8
9
10
//自定义一个函数，将删除配方和添加配方一体化
function recipeTweak(isShaped as bool, out as IItemStack, input as IIngredient[][]) {
    val recipeName as string = getItemName(out);
    recipes.remove(out, true);
    if (isShaped) {
        recipes.addShaped(recipeName, out, input);
    } else {
        recipes.addShapeless(recipeName, out, input[0]);
    }
}
扩展方法

扩展方法可以向现有类添加更多方法。

扩展方法和自定义函数很像，有关函数和方法的区别议论纷纷，各个语言的规定都不太一样。

在 CraftTweaker 中，它们的区别或许在于：扩展方法在类中，而自定义函数在类外。

由于扩展方法在现有类里，因此声明完扩展方法后，只需要导入其所属的类就可以直接调用，而不需要像自定义函数那样使用跨脚本调用。

注意，扩展方法是静态的。按照如下格式声明扩展方法：

1
2
3
4
$expand 类名$方法名(参数 as 参数数据类型) as 返回值数据类型 {
    [代码]
    return 返回值;
}
在声明扩展方法时，要先导入模块，也就是导入其所属的类。

注：类是一个信息技术概念，在 CraftTweaker 中，除了 string 以外的其他普通数据类型都是一个个类。

举例：

1
2
3
4
5
6
7
8
9
10
11
import crafttweaker.item.IItemStack;
// 为 IItemStack 类扩展了一个方法，方法名为 show
// 无返回值，使用后会在日志中输出某物品的命令字符串。
$expand IItemStack$show() as void {
    print(this.commandString);
    // this 关键字指向的是当前对象的引用
    // 命令字符串(commandString)是你在 ZenScript 中调用此项的方式。这可以是尖括号调用或与其类似的东西。
}
// 使用 show 方法
<minecraft:apple>.show();
// 最终在日志中输出 “<minecraft:apple>”
跨脚本调用

跨脚本调用主要是针对静态变量，但自定义函数和类也需要它！

跨脚本调用需要以 scripts. 开头，匹配相对路径。先匹配目录，再匹配脚本和值。

举例：

在a.zs脚本中声明了一个静态变量，并自定义了一个函数

1
2
3
4
static myVal as string = "myVal";
function makeLine() {
    print("---------------");
}
在b.zs中调用a.zs的静态变量和函数

1
2
print(scripts.a.myVal);
scripts.a.makeLine();
我们还以使用 import 来将其作为一个模块导入，例如在c.zs中调用a.zs中的内容

1
2
3
import scripts.a;
print(a.myVal);
a.makeLine();
配方修改

工作台配方

添加有序合成配方

基本格式：

1
recipes.addShaped(recipeName, output, inputbox);
1.12 中 Mojang 修改了合成的注册系统，每个配方以一个 json 文件储存，同时每个配方有一个ID。

当你打开高级提示框(F3+H)时，可以在 JEI 中看见每一个配方的ID。

但实际上，你也可以省略配方ID，就像旧版本那样，这样 CrT 会使用 hash 值自动指定配方ID。配方名不能重复。

output 即为配方输出。inputbox 即为需要的物品。比如我们拿铁护腿举个例子。

它在 CrT 是这么表示的:

1
2
3
4
5
6
//配方名略去
recipes.addShaped(<minecraft:iron_leggings>, [
    [<ore:ingotIron>, <ore:ingotIron>, <ore:ingotIron>],
    [<ore:ingotIron>, null, <ore:ingotIron>],
    [<ore:ingotIron>, null, <ore:ingotIron>]
]);
可以看到，output 必须是一个 IItemStack，而 input 是一个二维数组，内部是三个一维数组，表示工作台中每一层放的物品。

每个一维数组内部是三个 IIngredient，没有物品的地方用 null 表示。

什么？到现在还不知道 IItemStack 和 IIngredient 是什么？第四部分第二章欢迎您

如此一来就可以添加工作台的配方了。

添加无序合成配方

基本格式：

1
recipes.addShapeless(recipeName, output, inputbox);
以末影之眼为例，它在 CrT 是这么表示的：

1
2
3
4
//配方名略去
recipes.addShapeless(<minecraft:ender_eye>, [
    <minecraft:ender_pearl>, <minecraft:blaze_power>
]);
这里个 inputbox 只是一个简单的一维数组，因为是无序配方，无所谓物品放在哪一行，自然就不需要二维数组来确定是工作台中的哪一行了。

可用：

1
recipes.addHiddenShapeless(recipeName, output, inputBox);
添加隐藏无序合成。

移除工作台配方

1
recipes.remove(item, NBTMatch);
删除物品的所有配方，NBTMatch（可省略）为布尔值（true/false）。

如果为true，删除配方的物品将匹配NBT。默认（即省略的话）为false，不匹配NBT。

1
recipes.removeShaped(item, inputBox);
删除物品的一个特定有序配方，inputBox可省略，这样指删除物品的所有有序配方。

1
recipes.removeShapeless(item,inputBox);
删除物品的一个特定无序配方，inputBox可省略，这样指删除物品的所有无序配方。

1
recipes.removeByRecipeName(recipeName);
以配方ID为依据删除配方。可以使用正则表达式。

1
recipes.removeByMod(ModID);
删除一个mod的所有配方。

1
recipes.removeAll();
删除游戏内所有配方。

熔炉配方

添加熔炉配方

基本格式：

1
furnace.addRecipe(output, input, xp);
其中，output 输出，input 输入，xp 为给予经验(使用双精度浮点数，即可用小数，可以省略)。

移除熔炉配方

基本格式：

1
furnace.remove(output, input);
移除将 input 烧成 output 的熔炉配方，input 可省略，这样指删除所有烧成 output 的配方。

熔炉燃料

基本格式：

1
furnace.setFuel(input, burnTime);
将一个物品设置为燃料，并且设定时间，时间单位采用游戏刻。煤炭为1600，烧一个物品需要 200。将 burnTime 设置为 0 即为删除该燃料。

矿物辞典

矿辞诞生

forge 矿物辞典(forge ore dictionary，简称OD) 来源于 RedPower2 的作者 eloraam 的一个帖子，

当时有人争议 rp (红石力量) 和 ic (工业) 添加同类的矿物(铜矿、锡矿)引起的混乱，于是 forge 矿物辞典随之诞生了。

forge 矿物辞典就是一种让不同模组的矿物通用的系统，例如在世界中采集到不同的铜矿，可以用来合成同样的物品，甚至可以混搭使用！

矿辞用法

矿辞名称.add(物品名称);

将某物品加入到某 OD 中

1
2
3
<ore:sand>.add(<minecraft:stone>);
//将石头添加入沙子的矿物辞典中
//如果加入的矿辞不存在，那样就会创建一个新的矿辞
矿辞名称.remove(物品名称);

将某物品从某 OD 中删除

1
2
<ore:sand>.remove(<minecraft:sand>); 
//将沙子从沙子的矿物辞典中删除
矿辞名称.addAll(矿辞名称);

将某个矿物辞典中所有物品列入到另一个矿物辞典下

矿辞名称A.mirror(矿辞名称B);

将A的物品全部映射到B下面，也就代表B包含原有的B和A，但是A中不包含B

事件导论

事件概念

事件，顾名思义，游戏中每个时刻的每个动作都是一个事件。

例如：玩家登入世界，实体受到伤害，玩家合成物品等等。

它们都是一个个事件。

我们可以通过事件管理器(IEventManager)监听事件，即检测“当...发生时”，

随后就可以通过事件所面向的对象，编写语句，实现对游戏内容的更改！

事件管理器

通过事件管理器，我们可以添加一个表示事件的函数，从那里我们可以决定发生某事件后，CrT 会执行的操作。

要记住最重要的事情是，需要给事件指定对应类！否则，将无法访问获取事件包含的信息。

如果您只是想在不需要访问事件的地方打印一些东西，就不需要转类型了。

事件函数格式如下：

1
2
3
events.on事件(function (event as 事件类) {
    [代码]
});
其中，事件为游戏内所以能调用的事件，可以在 https://docs.blamejared.com/1.12/zh/Vanilla/Events/IEventManager 页面上

找到所有可以调用的事件，及使用他们需要导入的相关模块！

实例：

1
2
3
4
5
6
7
8
9
import crafttweaker.events.IEventManager; //导入事件管理器
import crafttweaker.event.PlayerCraftedEvent; //导入玩家合成事件的类
// onPlayerCrafted 当玩家合成时
events.onPlayerCrafted(function(event as PlayerCraftedEvent) {
    // 获取是哪个玩家合成了物品
    var player = event.player;
    // 让玩家受到 1 点魔法伤害
    player.attackEntityFrom(<damageSource:MAGIC>, 1.0f);
});
部分事件可以通过 event.cancel(); 来取消事件，相当于该事件没发生。

查阅官方文档的方法

在编写事件函数时，查阅官方文档是必不可少的。要记住官方文档比一切教程都更权威！

在查看具体文档之前，请确认你翻阅的官方文档是 1.12.2 的版本。

由于 CrT 在高低版本的区别很大，因此翻阅错误版本的官方文档必定导致报错！

确认完毕后，我们在左侧目录中找到 vanlia，打开。

然后往下翻，找到 Events，打开。

然后再找到 Events 目录里面的 Events，下拉打开，可以看到所有事件都在其中。

以实体受到伤害为例，假如我们需要编写一个事件函数，让实体受伤时检测伤害来源，如果来源为凋灵，就将伤害调为 100。

我们就要首先找到“实体受到伤害”这个事件，在官方文档中找到 EntityLivingHurtEvent 页面。

进入页面，我们立马就知道了调用这个事件需要导入的类，如此一来，事件函数的总框架便瞬间确定下来！

如下：

1
2
3
4
5
import crafttweaker.events.IEventManager;
import crafttweaker.event.EntityLivingHurtEvent;
events.onEntityLivingHurt(function(event as EntityLivingHurtEvent) {
    [代码]
});
接下来，我们只需要在大括号内部写上语句皆可。

在 EntityLivingHurtEvent 页面，我们可以知道这个事件面向两个能够使用 ZenGetter 的对象，分别为：

damageSource，类型为 IDamageSource，表示实体受到的伤害的伤害源。

amount，类型为 float，表示实体受到伤害的值。

并且，其中的 amount 可以通过 ZenSetter 重新赋值。

很明显，我们要判断伤害来源是否为凋灵，肯定要使用 damageSource。

但是这个对象的数据类型是 IDamageSource，和凋灵这一实体并不属于同一个数据类型。

因此，我们需要通过 damageSource 所面向的对象，继续寻找办法。

可以看见，该页面上的 IDamageSource 是标蓝的，这表示超链接，可以直接链接到 IDamageSource 这一类型。

在 IDamageSource 的页面上，可以看到有好多对象。

按照上述步骤，逐个对比，如法炮制。

最终我们发现，可以通过比较：

IDamageSource 面向的 trueSource(IEntity类型) 面向的 definition(IEntityDefinition类型) 面向的 id 是否等于凋灵的 id 来进行判断

因此我们填补代码，当然可以使用声明局部变量，让语句更加简单。

如下：

1
2
3
4
5
6
7
8
import crafttweaker.events.IEventManager;
import crafttweaker.event.EntityLivingHurtEvent;
events.onEntityLivingHurt(function(event as EntityLivingHurtEvent) {
    var source as IEntity = event.damageSource.trueSource;
    if (source.definition.id == <entity:minecraft:wither>.definition.id) {
        event.amount = 100.0f;
    }
});
但是我们还没有写完，仔细想想，我们发现并不是所有伤害都有实体来源，如果受到岩浆等伤害，没有实体来源，程序就会抛出空指针异常！

因此，我们还需要进行 isNull 检查，在其前面加上非符号，表示检查的值不为空时输出 true。

随后，我们使用了多个普通数据类型，每个普通数据类型都别忘记导入模块！

最终，我们完成了事件函数的编写：

1
2
3
4
5
6
7
8
9
10
11
import crafttweaker.events.IEventManager;
import crafttweaker.event.EntityLivingHurtEvent;
import crafttweaker.damage.IDamageSource;
import crafttweaker.entity.IEntity;
import crafttweaker.entity.IEntityDefinition;
events.onEntityLivingHurt(function(event as EntityLivingHurtEvent) {
    var source as IEntity = event.damageSource.trueSource;
    if (!isNull(source) && !isNull(source.definition) && source.definition.id == <entity:minecraft:wither>.definition.id) {
        event.amount = 100.0f;
    }
});
部分实例展示

禁止爬行者生成

1
2
3
4
5
6
7
8
9
10
import crafttweaker.events.IEventManager;
import crafttweaker.event.EntityJoinWorldEvent;
import crafttweaker.entity.IEntity;
import crafttweaker.entity.IEntityDefinition;
events.onEntityJoinWorld(function(event as EntityJoinWorldEvent) {
    var definition = event.entity.definition;
    if (!isNull(definition) && definition.id == "minecraft:creeper") {
        event.cancel();
    }
});
禁止玩家使用指令

1
2
3
4
5
6
7
8
9
10
11
12
import crafttweaker.events.IEventManager;
import crafttweaker.command.ICommand;
import crafttweaker.event.CommandEvent;
import crafttweaker.player.IPlayer;
events.onCommand(function(event as CommandEvent) {
    if (event.commandSender instanceof IPlayer) {
        var player as IPlayer = event.commandSender;
        if (!player.creative && !event.commandSender.world.remote) {
            event.cancel();
        }
    }
});
作弊模组检测

代码是这样写得！这么喜欢玩加速火把？那就吧加速火把cha进你的py里，给你的py加速加速！

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
import crafttweaker.events.IEventManager;
import crafttweaker.event.IPlayerEvent;
import crafttweaker.event.PlayerLoggedInEvent;
import crafttweaker.player.IPlayer;
import crafttweaker.text.ITextComponent;
static disallowedMods as string[] = [
    "torcherino", "lastsword", "lolipickaxe", "manaita"
];
function badModLoaded() as bool {
    for mod in disallowedMods {
        if (loadedMods has mod) {
            return true;
        }
    }
    return false;
}
events.onPlayerLoggedIn(function (event as PlayerLoggedInEvent) {
    var player as IPlayer = event.player;
    if (badModLoaded()) {
        player.sendRichTextMessage(ITextComponent.fromTranslation("test.cheatmod"));
        for mod in disallowedMods {
            if (loadedMods has mod) {
                player.sendChat(loadedMods[mod].name + loadedMods[mod].version);
            }
        }
    }
});
//loadedMods 是全局关键字，作用是将当前加载的模组囊括为一个数组
//test.cheatmod 并不是游戏内显示的内容，需要配合 Resource Loader 模组，在对应文件夹创建 .lang 语言文件
CraftTweaker 游戏内命令

前缀及作用

CraftTweaker 添加了一些命令，这些命令可以帮助你创建脚本，并减少编写脚本的开发时间。

命令的前缀是:  /crafttweaker 或 /ct

你也可以使用这些别名： /minetweaker 或 /mt

游戏中的所有命令都可以通过以下方式找到: /ct help

命令列表

命令	语法	说明
生物群系	/ct biomes
列出游戏中的所有生物群系。
生物群系类型
/ct biomeTypes
列出游戏中的所有生物群系类型。
方块信息
/ct blockinfo
启用或禁用方块信息读取器。在启用方块信息模式下，右键点击方块，将输出方块的名称、元数据和 TileEntity 数据。
方块	/ct blocks	将游戏中所有的方块名称输出到 crafttweaker.log 文件(即日志文件)中。
问题追踪
/ct bugs
在浏览器中打开 GitHub 错误跟踪器。
合成表冲突
/ct conflict
将所有冲突的制作表配方的列表输出到 crafttweaker.log 文件(仅在安装 JEI 后有效)。
Discord 便捷访问
/ct discord
在浏览器中打开 CraftTweaker 的官方 discord 频道。
官方文档
/ct docs
在浏览器中打开官方文档页面 (与 /ct wiki 相同)。
导出脚本修改内容
/ct dumpzs
将 ZenScript 转储为 HTML 文件输出到 minecraft 目录中的 crafttweaker_dump 文件夹。
实体	/ct entities	将游戏中所有的实体输出到 crafttweaker.log 文件。
给予物品
/ct give <IItemStack>
使用 CraftTweaker 的尖括号调用语法为玩家提供项，因此可以通过附加 .withTag() 调用来应用标签(非特殊情况不需要使用)。
查询手中物品	/ct hand	查看自己手上所拿着物品的id及其nbt标签(如果有的话)，会直接提供剪切板，让你快速进行复制粘贴。
物品栏内物品
/ct inventory
将物品栏中所有的物品输出到 crafttweaker.log 文件。
JEI 类	/ct jeiCategories	将所有已注册的 jei 类输出到 crafttweaker.log 文件中(仅在安装 JEI 后有效)。
Json 格式
/ct json
将手中物品的 nbt 数据作为 JSON 输出到聊天栏中。这种格式与 CraftTweaker 使用的 IData 格式不同。会直接提供剪切板，让你快速进行复制粘贴。
流体	/ct liquids	将游戏中所有的流体输出到 crafttweaker.log 文件。
打开日志	/ct log
输出一个可以直接打开 crafttweaker.log 文件的链接。
模组	/ct mods	将游戏中所有模组及其版本输出到 crafttweaker.log 文件，并在聊天栏中显示。
物品
/ct names [category]
将游戏中所有的物品输出到 crafttweaker.log 文件。其中 category 参数是可选的，你可以填入附录表内参数，让输出到日志中的物品信息更加全面。
NBT	/ct nbt	将你目光看向方块或手持物品的 NBT 数据输出到 crafttweaker.log 文件中。
矿物辞典
/ct oredict <name>
将游戏中所有的矿物辞典及这个矿辞包含的物品输出到 crafttweaker.log 文件。若指定 name 参数，则只输出该 name 代表矿物辞典下的物品。
状态效果	/ct potions	将游戏中所有的状态效果输出到 crafttweaker.log 文件。
配方名	/ct recipeNames <modid>	将游戏中所有的配方名输出到 crafttweaker.log文件。可以指定 modid 参数来过滤结果。
配方	/ct recipes
将游戏中所有的合成配方以 recipes 函数的形式输出到 crafttweaker.log 文件。
熔炉配方	/ct recipes furnace
将游戏中所有的熔炉配方以 recipes 函数的形式输出到 crafttweaker.log 文件。
手持物品配方
/ct recipes hand
将游戏中所有的能合成手持物品的配方以 recipes 函数的形式输出到 crafttweaker.log 文件。
打开脚本文件夹
/ct scripts
打开游戏目录下的 scripts 文件夹，可以由服务端控制台执行。
种子注册表
/ct seeds
将种子注册表中所有的物品输出到 crafttweaker.log 文件。
语句检查
/ct syntax
检查所有脚本，并输出发现的所有语法错误。这不是热重载指令。CraftTweaker 在 Minecraft 1.12.2 不支持热重载。
Wiki
/ct wiki
在浏览器中打开官方文档页面 (与 /ct docs 相同)。
ZsLint
/ct zslint
启动 zslint 套接字。
附录：/ct names 参数表

参数	内容
burntime
物品作为燃料的燃烧时间
creativetabs
物品所属的创造背包栏
damageable
物品可否被损坏(是否有耐久)
display
物品的显示名
enchantability
物品的附魔能力(详见 Minecraft-Wiki 的 "附魔台机制")
foodvalue
食物的营养价值
maxdamage
物品的最大耐久值
maxstack
物品的最大堆栈数量
maxuse
物品的使用时长(单位: tick)
modid	物品所属的 mod
rarity
物品的稀有度，影响物品显示名的颜色
repairable
物品可否使用铁砧
repaircost
物品在铁砧上操作而获得的操作数
saturationvalue
食物的饱食度值
unloc
物品的未本地化名称
模组联动

Content Tweaker

ContentTweaker 允许通过 ZenScript 创建方块，物品，流体和其他内容。

ContentTweaker 游戏内命令

ContentTweaker 扩展了 CraftTweaker 提供的命令。

要访问这些命令，你需要执行与 CraftTweaker 命令相同的操作，使用 /crafttweaker 或 /ct 前缀。

命令	语法	说明
方块材料
/ct blockmaterial
将游戏中所有的方块材料输出到 crafttweaker.log 文件。
创造模式物品栏
/ct creativetab
将游戏内所有的创造模式物品栏输出到 crafttweaker.log 文件。
声音事件
/ct soundevent
将游戏中所有的声音事件输出到 crafttweaker.log 文件
声音类型
/ct soundtype
将游戏中所有的声音类型输出到 crafttweaker.log 文件。
资源文件夹

安装 ContentTweaker 后的第一件事不是急着看教程写脚本，而是赶快启动一遍 Minecraft。

启动完毕后退出。我们发现，在根目录下多出了一个 resources 文件夹。

Tip: 该 resources 文件夹同 资源加载(Resource Loader) 模组的 resources 文件夹兼容，教程十分推荐一起安装该模组。

进入 resources 文件夹，里面还有一个 contenttweaker 文件夹，进入。

可以发现，contenttweaker 文件夹内有着五个文件夹，分别为：blockstates, lang, models, sounds, textures。

这五个文件夹分别负责存储：方块状态文件，语言文件，模型文件，声音文件，材质文件。

材质学基础

虽然教程主要教学脚本，但是这些 Minecraft 材质学的基础内容是必须掌握的。

方块状态文件(blockstate)是进一步定义一个方块所需的附加数据，包括方块的外观和行为，文件格式是 Json。在大多数情况下，一个方块对应一个方块状态，但也有个例。

例如在 1.12.2 版本，熔炉就有“熄灭的熔炉”和“燃烧的熔炉”两种方块状态。而火把也具有“火把”和“墙上的火把”两种方块状态，因此实际方块和方块状态不是一一对应的。

模型则分为方块模型和物品模型，文件格式也是 Json。

方块状态需要调用方块模型，但是方块状态和方块模型依然不是一一对应关系。

例如墙上的火把这一方块状态，其内部包含了"facing=east"，"facing=west"，"facing=south"以及"facing=north"四个变种，对应着四个方块模型。

而这四个变种都只调用一个示例文件：wall_torch.json，但在其基础上进行了旋转。

对于物品而言，没有物品状态，只有物品模型、物品材质和物品名称三种文件。因此，对于物品，只需要在 models/items, lang, textures/items 三个文件夹中存放文件就行了。

材质分为方块材质和物品材质，文件格式是 png。

方块模型需要调用方块材质，但你肯定有明白了，方块模型和方块材质依旧不是一一对应的关系。

比如草方块，它底部、侧面、表面有三张不同的贴图，一个模型就对应着三张材质。

方块状态也可以直接调用方块材质，而跳过方块模型。

物品模型调用物品材质。

材质可以是静态的，可以是动态的。但始终都是 .png 格式，否则会导致材质错误。

要让方块或物品纹理正常显示，那么它们的宽度和高度必须相等(如果是动态纹理，那么高度要是宽度的倍数)；否则，只会显示黑紫方格交错的纹理。对于其他多数纹理，文件会被拉伸以符合所需的尺寸。

语言文件的格式是 lang。

内部存储的都是键值对。别告诉我现在还不知道键值对是什么。如果这样，建议重学第四部分。

键就是本地化键名，值就是物品或者方块在游戏里要显示的名字，也叫本地化名称。

方块的本地化键名格式：tile.contenttweaker.blockName.name，其中 blockName 是该方块的未本地化名称。

物品的本地化键名格式：item.contenttweaker.itemName.name，其中 itemName 是该物品的未本地化名称。

创建一个方块

使用 ContentTweaker 创建新事物，你需要使用 #loader contenttweaker 预处理器，保证该脚本由 ContentTweaker 加载，而不是原来的 CraftTweaker。

创建方块需要从 ContentTweaker 导入两个模块，分别为 VanillaFactory 和 Block。

通过如下实例，我们可以创建一个方块：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
#loader contenttweaker
import mods.contenttweaker.VanillaFactory;
import mods.contenttweaker.Block;
var antiIceBlock = VanillaFactory.createBlock("anti_ice", <blockmaterial:ice>);
// 以下在定义方块的各个性质，有哪些性质可以定义？
// 请自行参阅官方文档：https://docs.blamejared.com/1.12/zh/Mods/ContentTweaker/Vanilla/Creatable_Content/Block
antiIceBlock.setLightOpacity(3);   // 不透明度
antiIceBlock.setLightValue(0);   // 自身亮度
antiIceBlock.setBlockHardness(5.0);   // 硬度
antiIceBlock.setBlockResistance(5.0);   // 爆炸抗性
antiIceBlock.setToolClass("pickaxe");   // 采集工具
antiIceBlock.setToolLevel(0);   // 挖掘等级
antiIceBlock.setBlockSoundType(<soundtype:snow>);   // 声音类型
antiIceBlock.setSlipperiness(0.3);   // 光滑度
antiIceBlock.register();
其中，第 4 行的 anti_ice 是该方块的未本地化名称。

如此一来，这个方块在游戏内确实被注册了，可是现在的它没有材质也没有名字。

通过指令 /give @s contenttweaker:anti_ice 可以获得该方块。我们看到，不仅材质全是紫黑块，名字也是乱的。

这就需要我们准备一张合适的，长宽一致的 png 图片，将这张图片的名字重命名为方块的未本地化名称，在这里就是 anti_ice。

随后将这张图片移动到 resources/contenttweaker/textures/blocks 中。这样，方块的材质就显现出来了。

至于名字，我们就需要在 resources/contenttweaker/lang 文件夹下新建一个文件，文件名为 zh_CN

Tip: zh_CN 是简体中文的意思，如果要编写英语(美式)名字，就要把文件名设为 en_US

进入这个文件，写下如下的键值对，让本地化键名和本地化名称建立起一一对应关系：

1
tile.contenttweaker.anti_ice.name=反冰
保存后重新进入游戏，一个方块创建完成。

创建一个物品

对于物品，创建过程和方块非常相似。

只不过语言文件中二者的本地化键名格式不同，以及物品材质需要放在 textures 下的 items 文件夹中，而不是 blocks 文件夹。

下面举个实例：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
#loader contenttweaker
import mods.contenttweaker.VanillaFactory;
import mods.contenttweaker.Item;
var zsItem = VanillaFactory.createItem("zs_item");
// 物品性质：https://docs.blamejared.com/1.12/zh/Mods/ContentTweaker/Vanilla/Creatable_Content/Item
zsItem.maxStackSize = 8;   // 最大堆栈数
zsItem.rarity = "rare";   // 稀有度
zsItem.creativeTab = zsCreativeTab;   // 所属创造背包栏
zsItem.smeltingExperience = 10;   // 熔炼获得经验
zsItem.toolClass = "pickaxe";   // 工具类型
zsItem.toolLevel = 5;   // 挖掘等级
zsItem.beaconPayment = true;   // 是否可用于信标
zsItem.itemRightClick = function(stack, world, player, hand) {
    Commands.call("scoreboard players set @p name 5", player, world);
    return "Pass";
    //手持物品右键执行以上代码
};
zsItem.register();
创建一个流体

如法炮制，不需要教了。直接上实例：

1
2
3
4
5
6
7
8
9
#loader contenttweaker
import mods.contenttweaker.VanillaFactory;
import mods.contenttweaker.Fluid;
import mods.contenttweaker.Color;
var zsFluid = VanillaFactory.createFluid("zs_fluid", Color.fromHex("FF69B4"));
// 流体性质：https://docs.blamejared.com/1.12/zh/Mods/ContentTweaker/Vanilla/Creatable_Content/Fluid
zsFluid.material = <blockmaterial:lava>;   // 流体材料
zsFluid.temperature = 1300;   // 流体温度
zsFluid.register();
不需要给流体提供材质，因为流体材质无非就是水或熔岩换个色。而流体的颜色在上述脚本的第五行定义了。

都给你提供三次官方文档的链接了，总会自己查阅了吧！以后就自己去查吧。

创建匠魂材料

ContentTweaker 联动了匠魂，你可以使用它自定义匠魂材料。

格式就像创建方块、物品、流体一样，十分简单。

匠魂材料只需要在 recourses 文件夹中提供其本地化名称，除此以外不需要提供任何材质、模型等等。

1
2
3
4
5
6
7
8
9
10
11
12
13
14
#loader contenttweaker
#modloaded tconstruct
val testMat = mods.contenttweaker.tconstruct.MaterialBuilder.create("flower");
testMat.color = 0x8e661b;   // 材料颜色
testMat.craftable = true;   // 是否使用部件加工台
testMat.liquid = <liquid:lava>;   // 熔融后形成的流体(若 testMat.castable = false 可省略)
testMat.castable = false;   // 是否使用冶炼炉
testMat.addItem(<item:minecraft:red_flower:4>);   // 部件加工台或冶炼炉需要的物品
testMat.representativeItem = <item:minecraft:red_flower:4>;   // 匠魂宝典上显示的物品
testMat.addHeadMaterialStats(100, 1.5f, 5.5f, 1);   // 材料作为顶端时的属性(依次为：耐久，攻击速度，攻击力，挖掘等级)
testMat.addHandleMaterialStats(0.3, 500);   // 材料作为手柄时的属性(依次为：手柄系数，耐久)
testMat.addBowStringMaterialStats(0.5f);   // 材料作为弓弦时的属性(依次为：强化)
testMat.localizedName = "Flower";   // 本地化名称，可以用 game.localize() 函数来调用本地化键名 
testMat.register();
结合上述知识，有如下实例(来自整合包: GreedyCraft 中的"聚合矩阵")：

首先创建一个新流体，然后创建一个材料，最后为材料添加特性。

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
#loader contenttweaker
#modloaded tconstruct
// 导入模块
import crafttweaker.liquid.ILiquidStack;
import crafttweaker.game.IGame;
import mods.contenttweaker.tconstruct.Material;
import mods.contenttweaker.tconstruct.MaterialBuilder;
import mods.contenttweaker.Fluid;
import mods.contenttweaker.VanillaFactory;
import mods.contenttweaker.Color;
// 创建一个新流体
val molten_fusion_matrix = VanillaFactory.createFluid("fusion_matrix", Color.fromHex("4a148c").getIntColor());
molten_fusion_matrix.material = <blockmaterial:lava>;
molten_fusion_matrix.viscosity = 2000;
molten_fusion_matrix.density = 4000;
molten_fusion_matrix.rarity = "EPIC";
molten_fusion_matrix.colorize = true;
molten_fusion_matrix.temperature = 2800;
molten_fusion_matrix.luminosity = 15;
molten_fusion_matrix.color = Color.fromHex("4a148c").getIntColor();
molten_fusion_matrix.stillLocation = "base:fluids/molten";
molten_fusion_matrix.flowingLocation = "base:fluids/molten_flowing";
molten_fusion_matrix.register();
// 创建一个匠魂材料
val fusion_matrix = MaterialBuilder.create("fusion_matrix");
fusion_matrix.color = Color.fromHex("4a148c").getIntColor(); 
fusion_matrix.craftable = false;
fusion_matrix.castable = true;
fusion_matrix.representativeItem = <item:tconevo:material:0>;
fusion_matrix.addItem(<item:tconevo:material:0>);
fusion_matrix.liquid = <liquid:fusion_matrix>;
fusion_matrix.localizedName = "聚合矩阵";
fusion_matrix.addHeadMaterialStats(12000, 13.6, 18.9, 8);
fusion_matrix.addHandleMaterialStats(1.8, 625);
fusion_matrix.addExtraMaterialStats(820);
fusion_matrix.addBowMaterialStats(getDrawSpeed(1.2) as float, 1.2, 9.6);
fusion_matrix.addArrowShaftMaterialStats(1.75, 40);
fusion_matrix.addProjectileMaterialStats();
// 为该材料添加特性
fusion_matrix.addMaterialTrait("tconevo.overwhelm", "head");
fusion_matrix.addMaterialTrait("dense", "head");
fusion_matrix.addMaterialTrait("dense", "handle");
fusion_matrix.addMaterialTrait("dense", "extra");
fusion_matrix.addMaterialTrait("dense_armor", "core");
fusion_matrix.addMaterialTrait("shielding_armor", "core");
fusion_matrix.addMaterialTrait("first_guard_armor", "core");
fusion_matrix.addMaterialTrait("dense_armor", "plates");
fusion_matrix.addMaterialTrait("first_guard_armor", "plates");
fusion_matrix.addMaterialTrait("dense_armor", "trim");
fusion_matrix.addMaterialTrait("first_guard_armor", "trim");
fusion_matrix.addMaterialTrait("tconevo.overwhelm", "bow");
fusion_matrix.addMaterialTrait("dense", "bow");
fusion_matrix.addMaterialTrait("hovering", "shaft");
fusion_matrix.register();
自定义匠魂材料特性

创建材料特性可就不是上面那几个流水线工艺了。

除了基本格式和创建匠魂材料差不多外，我们需要结合事件函数了。

简单来说，特性的显示颜色，描述等等这些表面的东西，和上面的那四个家伙差不多，很容易处理。

但是特性的具体效果可不一样，这是需要通过函数书写的，本质上讲，其实是一个类似事件函数的东西。

我们从老朋友贪婪整合包中取一个例子(省略导入模块和本地化键名)：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
val gambleTrait = TraitBuilder.create("gamble");
gambleTrait.color = Color.fromHex("ffa000").getIntColor(); 
gambleTrait.localizedName = "赌博";
gambleTrait.localizedDescription = "这是个看脸的世界";
gambleTrait.calcDamage = function(trait, tool, attacker, target, originalDamage, newDamage, isCritical) {
    var dmg = newDamage;
    var rand as double = Math.random();
    if (rand < 0.15) {
        dmg = newDamage * 2 as float; 
    } else if (rand < 0.45) {
        dmg = newDamage / 2 as float; 
    }
    return dmg;
};
gambleTrait.register();
我们从上面的实例可以看到，第 1 至 4 行和自定义匠魂材料的格式几乎一致，没什么好说的。

然而从第 5 行开始，我们仿佛看到了事件函数的影子。

只不过，这不是真的事件函数，这个函数调用的不是 crafttweaker 的事件，而是 contenttweaker 的事件。

contenttweaker 所支持监听的事件较少，但也完全足够了。

你可以在：https://docs.blamejared.com/1.12/zh/Mods/ContentTweaker/Tinkers_Construct/TraitBuilder 页面上找到所有 ContentTweaker 支持的工具材料事件。

具体怎么编写创新，就看你个人的编程能力和脑洞了。

自定义匠魂盔甲材料特性

匠魂2有一个名叫匠魂盔甲的附属模组，其向匠魂添加了盔甲，ContentTweaker 可以自定义匠魂盔甲的材料特性。

参考贪婪整合包，匠魂盔甲的材料特性一般格式如下(省略导入模块和本地化键名)：

1
2
3
4
5
6
7
8
9
10
val visionTrait = ArmorTraitBuilder.create("vision");
visionTrait.color = Color.fromHex("ffeb3b").getIntColor();
visionTrait.localizedName = game.localize("视域");
visionTrait.localizedDescription = game.localize("正道的光，照在了大地上！");
visionTrait.onAbility = function(trait, level, world, player) {
if (!isNull(player)) {
player.addPotionEffect(<potion:minecraft:night_vision>.makePotionEffect(330, 2, false, false));
}
};
visionTrait.register();
前四行没什么技术含量，分别自定义了特性的注册名、颜色、显示名、描述，如法炮制即可。

第五行开始编写事件。注意，虽然 ContentTweaker 提供了对匠魂盔甲的支持，但事件系统依然是独立提供的。

也就是说，此处的事件系统既不是 CraftTweaker 提供的，也不是上面工具材料特性 TraitBuilder 提供的，而是由 ArmorTraitBuilder 独立提供的！

很遗憾，官方文档没有提供 ArmorTraitBuilder 的详细信息，你只能在 ContentTweaker 的 GitHub Wiki 上查找。

你可以在: https://github.com/illusivesoulworks/constructsarmory/wiki/ContentTweaker 页面上找到所有 ContentTweaker 支持的盔甲特性事件。

打不开 GitHub 的可以尝试下载软件 FastGithub，加速访问网站，重复刷新有概率成功。

如果实在没有办法阅读 GitHub Wiki，可参考本教程提供的汉化文档，但不保证 100% 准确，有错误欢迎勘误！

事件总览 - ArmorTraitBuilder 提供

注意，参数表的书写格式为: 数据类型 参数名 参数表示的内容

onUpdate 事件

该事件在玩家物品栏中有盔甲时每游戏刻都会触发一次

无返回值

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

IWorld world 当前世界信息

IEntity owner 该特性使用者

int itemSlot 盔甲物品所处在物品栏中的位置

bool isSelected 是否手持盔甲

格式:

1
2
3
myTrait.onUpdate = function(trait, armor, world, owner, itemSlot, isSelected) {
//CODE
};
onArmorRepair 事件

该事件在盔甲使用修复材料进行修复之前被调用

请勿与 afterArmorHealed 混淆，后者是在修复之后被调用的

如果同时使用多个物品进行修复，则会被多次调用

无返回值

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

int amount 修复增加的耐久

格式:

1
2
3
myTrait.onArmorRepair = function(trait, armor, amount) {
        //CODE
};
onArmorTick 事件

该事件在玩家装备盔甲时每游戏刻都会触发一次

无返回值

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

IWorld world 当前世界信息

IPlayer player 穿戴盔甲的玩家

格式:

1
2
3
myTrait.onArmorTick = function(trait, armor, world, player) {
        //CODE
};
getModifications 事件

该事件在计算盔甲降低伤害的值时触发

返回 ArmorModification

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IPlayer player 穿戴盔甲的玩家

ArmorModification mods 盔甲对伤害进行的修改

IItemStack armor 盔甲物品

IDamageSource damegeSource 伤害的伤害来源

double damege 伤害值

int index 盔甲所处的槽位

注意: ArmorModification 类(数据类型)包含 5 个 public (Java 概念, 公开的) 对象

float armor 盔甲的护甲值

float toughness 盔甲的护甲韧性

float armorMod 盔甲的护甲值乘数

float toughnessMod 盔甲的护甲韧性乘数

float effective that 盔甲的总体乘数

格式:

1
2
3
myTrait.getArmorModifications = function(trait, player, mods, armor, damageSource, damage, index) {
        //CODE
};
onItemPickup 事件

该事件在拾取物品时触发

无返回值

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

IEntityItem item 拾取的掉落物实体

EntityItemPickupEvent evt 实体拾取物品事件

格式:

1
2
3
myTrait.onItemPickup = function(trait, armor, item, evt) {
        //CODE
};
onHurt 事件

该事件在穿戴盔甲的实体受到伤害时触发

该事件在盔甲和药水效果的伤害防御计算前触发

返回 float 作为新的伤害值, 否则返回 newDamage

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

IPlayer player 穿戴盔甲的玩家

IDamageSource source 伤害的伤害来源

float damage 计算前的原始伤害值

float newDamage 返回的新伤害值

LivingHurtEvent evt 生物受到攻击事件

格式:

1
2
3
myTrait.onHurt = function(trait, armor, player, source, damage, newDamage, evt) {
        //CODE
};
onDamaged 事件

该事件在穿戴盔甲的实体受到伤害时触发

该事件在盔甲和药水效果的伤害防御计算后触发

返回 float 作为新的伤害值, 否则返回 newDamage

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

IPlayer player 穿戴盔甲的玩家

IDamageSource source 伤害的伤害来源

float damage 将受到的原始伤害值

float newDamage 返回的新伤害值

LivingDamageEvent evt 生物受到伤害事件

格式:

1
2
3
myTrait.onDamaged = function(trait, armor, player, source, damage, newDamage, evt) {
        //CODE
};
onKnockback 事件

该事件在穿戴盔甲的实体被击退时触发

无返回值

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

IPlayer player 穿戴盔甲的玩家

LivingKnockbackEvent evt 生物受到击退事件

格式:

1
2
3
myTrait.onKnockback = function(trait, armor, player, evt) {
        //CODE
};
onFalling 事件

该事件在玩家自由落体时触发

无返回值

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

IPlayer player 穿戴盔甲的玩家

LivingFallEvent evt 生物摔落事件

格式:

1
2
3
myTrait.onFalling = function(trait, armor, player, evt) {
        //CODE
};
onJumping 事件

该事件在玩家跳跃时触发

无返回值

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

IPlayer player 穿戴盔甲的玩家

LivingJumpEvent evt 生物跳跃事件

格式:

1
2
3
myTrait.onJumping = function(trait, armor, player, evt) {
        //CODE
};
onAbility 事件

该事件在词条特性生效时每游戏刻触发一次

无返回值

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

int level 词条特性的等级

IWorld world 当前世界信息

IPlayer player 穿戴盔甲的玩家

格式:

1
2
3
myTrait.onAbility = function(trait, level, world, player) {
        //CODE
};
onArmorEquip 事件

该事件在盔甲被装备时触发

无返回值

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

IPlayer player 穿戴盔甲的玩家

int index 盔甲所处的槽位

格式:

1
2
3
myTrait.onArmorEquip = function(trait, armor, player, index) {
        //CODE
};
onArmorDamaged 事件

该事件在盔甲耐久被损伤时触发

返回 int 作为新的损伤值, 否则返回 newAmount

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

IDamageSource damegeSource 伤害的伤害来源

int amount 原始的损伤值

int newAmount 返回的新损伤值

IPlayer player 穿戴盔甲的玩家

int index 盔甲所处的槽位

格式:

1
2
3
myTrait.onArmorDamaged = function(trait, armor, damageSource, amount, newAmount, player, index) {
        //CODE
};
onArmorHealed 事件

该事件在盔甲耐久回复时触发

返回 int 作为新的回复值, 否则返回 newAmount

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

IItemStack armor 盔甲物品

IDamageSource damegeSource 回复的伤害来源

int amount 原始的损伤值

int newAmount 返回的新损伤值

IPlayer player 穿戴盔甲的玩家

int index 盔甲所处的槽位

格式:

1
2
3
myTrait.onArmorHealed = function(trait, armor, healSource, amount, newAmount, player, index) {
        //CODE
};
getAbilityLevel 事件

该事件在需要知晓材料特性的等级时被调用

返回 int 作为材料特性的等级, 否则返回 1

事件函数接受的参数:

ArmorTrait trait 触发该事件的材料特性

ModifierNBT data 材料特性的数据

格式:

1
2
3
myTrait.getAbilityLevel = function(trait, data) {
        //CODE
};
ModTweaker

教程格式

ModTweaker 能够自定义其他模组的合成配方。是 CraftTweaker 对其他模组进行联动的首选利器！

教程格式: module.function(type variable, type variable, ...);

其中，module 表示导入的模块；function 表示添加修改或删除配方的函数，比如 addRecipe，removeRecipe 等；

type 表示变量的数据类型；variable 表示变量，变量的名字代表着它在配方内的作用，比如 input 表示配方需要的物品， output 表示配方得到的物品等。

教程除了告诉你格式以外，会给你举实例的，因此看不懂格式也没关系，理解实例也不失为一种方法。

修改配方最基础的就是先删后增，不懂的重学第 5 章。

一定注意导入模块！

实用拓展 - Actually Additions

原子再构机

1
2
3
4
5
6
7
8
9
import mods.actuallyadditions.AtomicReconstructor;
// 添加配方格式:
// AtomicReconstructor.addRecipe(IItemStack output, IItemStack input, int energyUsed);
// 如下实例表示原子再构机消耗 1000 个单位的能量将煤炭转化为火焰弹
AtomicReconstructor.addRecipe(<minecraft:fire_charge>, <minecraft:coal:1>, 1000);
// 删除配方格式:
// AtomicReconstructor.removeRecipe(IItemStack output);
// 如下实例表示删除所有通过原子再构机合成煤炭的配方
AtomicReconstructor.removeRecipe(<minecraft:coal>);
毛球

1
2
3
4
5
6
7
8
9
import mods.actuallyadditions.BallOfFur;
// 添加配方格式:
// BallOfFur.addReturn(IItemStack output, int chance);
// 如下实例表示使用毛球有 5 的权重获得线
BallOfFur.addReturn(<minecraft:string>, 5);
// 删除配方格式:
// BallOfFur.removeReturn(IItemStack output);
// 如下实例表示删除使用毛球可能获得煤炭的配方
BallOfFur.removeReturn(<minecraft:coal>);
堆肥机

1
2
3
4
5
6
7
8
9
import mods.actuallyadditions.Compost;
// 添加配方格式:
// Compost.addRecipe(IItemStack output, IItemStack outputDisplay, IItemStack input, IItemStack inputDisplay);
// 如下实例表示使用堆肥机可以将糖发酵为泥土，糖在堆肥机里显示的材质是方块雪，泥土在堆肥机里显示的材质是方块泥土
Compost.addRecipe(<minecraft:dirt>, <minecraft:dirt>, <minecraft:sugar>, <minecraft:snow>);
// 删除配方格式:
// Compost.removeRecipe(IItemStack output);
// 如下实例表示删除所有通过堆肥机发酵得到油菜种子的配方
Compost.removeRecipe(<actuallyadditions:item_canola_seed>);
磨粉机

1
2
3
4
5
6
7
8
9
import mods.actuallyadditions.Crusher;
// 添加配方格式(@Optional 表示可选项):
// Crusher.addRecipe(IItemStack output, IItemStack input, @Optional IItemStack outputSecondary, @Optional int outputSecondaryChance);
// 如下实例表示磨粉机磨碎一个铁矿得到一个铁锭，同时有 50% 的概率产出副产物石头
Crusher.addRecipe(<minecraft:iron_ingot>, <minecraft:iron_ore>, <minecraft:stone>, 50);
// 删除配方格式:
// Crusher.removeRecipe(IItemStack output);
// 如下实例表示删除所有通过磨粉机得到金锭的配方
Crusher.removeRecipe(<minecraft:gold_ingot>);
充能台

1
2
3
4
5
6
7
8
9
10
import mods.actuallyadditions.Empowerer;
// 添加配方格式:
// 格式 1 : Empowerer.addRecipe(IItemStack output, IItemStack input, IItemStack modifier1, IItemStack modifier2, IItemStack modifier3, IItemStack modifier4, int energyPerStand, int time);
// 格式 2 : Empowerer.addRecipe(IItemStack output, IItemStack input, IItemStack modifier1, IItemStack modifier2, IItemStack modifier3, IItemStack modifier4, int energyPerStand, int time, float[] particleColourArray);
// 如下实例表示充能台在 4 个物品展示框中存在红石的情况下，将树叶转化为铁锭，每个物品展示框消耗 500 个单位的能量，充能时间长达 100 tick (即 5 秒)
Empowerer.addRecipe(<minecraft:iron_ingot>, <minecraft:leaves>, <minecraft:redstone>, <minecraft:redstone>, <minecraft:redstone>, <minecraft:redstone>, 500, 100);
// 删除配方格式:
// Empowerer.removeRecipe(IItemStack output);
// 如下实例表示删除所有通过充能台得到充能铁晶的配方
Empowerer.removeRecipe(<actuallyadditions:item_crystal_empowered:5>);
矿工透镜

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
import mods.actuallyadditions.MiningLens;
// 添加配方格式:
// 将石头转化为矿石: MiningLens.addStoneOre(IOreDictEntry ore, int weight);
// 将地狱岩转化为矿石: MiningLens.addNetherOre(IOreDictEntry ore, int weight);
// 如下实例 1 表示使用矿工透镜有 2 的权重将石头转化为铁矿石
// 如下实例 2 表示使用矿工透镜有 5 的权重将地狱岩转化为金矿石
MiningLens.addStoneOre(<ore:oreIron>, 2);
MiningLens.addNetherOre(<ore:oreGold>, 5);
// 删除配方格式:
// 删除转化石头配方: MiningLens.removeStoneOre(IOreDictEntry ore);
// 删除转化地狱岩配方: MiningLens.removeNetherOre(IOreDictEntry ore);
// 如下实例 1 表示删除所有通过矿工透镜将石头转化为铁矿石的配方
// 如下实例 2 表示删除所有通过矿工透镜将地狱岩转化为金矿石的配方
MiningLens.removeStoneOre(<ore:oreIron>);
MiningLens.removeNetherOre(<ore:oreGold>);
原油发电机

1
2
3
4
5
6
7
8
9
10
import mods.actuallyadditions.OilGen;
// 添加配方格式(@Optional 表示可选项):
// OilGen.addRecipe(ILiquidStack fluid, int genAmount, @Optional int genTime);
// genTime 留空则默认为 100
// 如下实例表示原油发电机每 10 tick 消耗 50 mB 岩浆，每 tick 发电 1000 个单位的能量
OilGen.addRecipe(<liquid:lava>, 1000, 10);
// 删除配方格式:
// OilGen.removeRecipe(ILiquidStack fluid);
// 如下实例表示删除所有通过原油发电机消耗水发电的配方
OilGen.removeRecipe(<liquid:water>);
藏宝箱

1
2
3
4
5
6
7
8
9
import mods.actuallyadditions.TreasureChest;
// 添加配方格式:
// TreasureChest.addLoot(IItemStack returnItem, int chance, int minAmount, int maxAmount);
// 如下实例表示打开藏宝箱有 50 的权重获得最小数量为 1，最大数量为 64 的泥土
TreasureChest.addLoot(<minecraft:dirt>, 50, 1, 64);
// 删除配方格式:
// TreasureChest.removeLoot(IItemStack returnItem);
// 如下实例表示删除打开藏宝箱可能会获得金粒的配方
TreasureChest.removeLoot(<minecraft:gold_nugget>);
Better With Mods

熔魂钢钢砧

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
import mods.betterwithmods.Anvil;
// 由于 ModTweaker 的旧 BUG，写在脚本里的配方和实际的配方会沿对角线翻折
// 新版的 ModTweaker 增加了新的方法修复了这个 BUG，因此本教程只会讲解新方法
// 添加配方格式:
// Anvil.addShapedFixed(IItemStack output, IIngredient[][] inputs);
// 如下实例表示根据其二维数组内的物品，生成一个合成泥土的配方
Anvil.addShapedFixed(<minecraft:dirt>, [
    [<minecraft:stone>, <minecraft:stone>, <minecraft:stone>, <minecraft:dirt>],
    [<minecraft:stone>, <minecraft:stone>, <minecraft:stone>, <minecraft:stone>],
    [<minecraft:stone>, <minecraft:stone>, <minecraft:stone>, <minecraft:stone>],
    [<minecraft:stone>, <minecraft:stone>, <minecraft:stone>, <minecraft:stone>]
]);
// 删除配方格式(@Optional 表示可选项):
// Anvil.removeShapedFixed(IItemStack output, @Optional IIngredient[][] inputs);
// 若 input 留空，则按照 output，删除所有通过熔魂钢钢砧合成 output 的配方
// 如下实例表示删除通过熔魂钢钢砧由该二维数组内物品合成指定物品的单一配方
Anvil.removeShapedFixed(<minecraft:dirt>,[
    [<minecraft:stone>, <minecraft:stone>, <minecraft:stone>, <minecraft:dirt>],
    [<minecraft:stone>, <minecraft:stone>, <minecraft:stone>, <minecraft:stone>],
    [<minecraft:stone>, <minecraft:stone>, <minecraft:stone>, <minecraft:stone>],
    [<minecraft:stone>, <minecraft:stone>, <minecraft:stone>, <minecraft:stone>]
]);
风箱

1
2
3
4
5
6
import mods.betterwithmods.Bellows;
// 该配方能让你自定义物品被风箱吹远的距离，以格为单位，格式如下:
// Bellows.set(IItemStack stack, float value);
// 其中，value 的取值范围是 (0, 128]
// 如下实例表示树叶将会被风扇吹动 5 格
Bellows.set(<minecraft:leaves:*>, 5.0f);
浮力

1
2
3
4
5
6
7
import mods.betterwithmods.Buoyancy;
// 该配方只在 Better With Mods 启用 HCBuoy 时有效
// 该配方能让你自定义物品受到的浮力，格式如下:
// Buoyancy.set(IItemStack stack, float value);
// 其中，value 的取值范围是 [-1, 1]，数字越大浮力越大，-1 表示完全沉没，1 表示浮在水面
// 如下实例表示铁块在水中会沉没水底
Buoyancy.set(<minecraft:iron_block>, -1.0f);
热源注册器

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
import mods.betterwithmods.HeatRegistry;
// 热源注册器能为与釜锅，坩埚和窑炉交互的方块分配整数值，即自定义可用于加热其的方块。
// 默认情况下: 1 表示原版火，2 表示蓝火
// 添加自定义热源(方法 1):
// HeatRegistry.addHeatSource(IItemStack stack, int heat);
// stack 这一物品栈必须有其对应的方块
// 如下实例表示将下界岩作为等级为 1 的热源(等级与原版火相等)
HeatRegistry.addHeatSource(<minecraft:netherrack>, 1);
// 添加自定义热源(方法 2):
// HeatRegistry.addHeatSource(IBlockState stack, int heat);
// 如下实例表示将下界岩作为等级为 1 的热源(等级与原版火相等)
HeatRegistry.addHeatSource(<blockstate:minecraft:netherrack>, 1);
// 添加自定义热源(方法 3):
// HeatRegistry.addHeatSource(IBlockState[] stacks, IItemStack displayStack, int heat);
// 多用于某物品对应方块有多个方块状态的时候，有关方块状态的概念详见 8.2 的材质学基础
// 暂无实例
釜锅

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
import mods.betterwithmods.Cauldron
// 添加基础配方格式:
// 需要原版火: Cauldron.addUnstoked(IIngredient[] inputs, IItemStack[] outputs);
// 需要蓝火: Cauldron.addStoked(IIngredient[] inputs, IItemStack[] outputs);
// 如下实例表示釜锅将圆石炼制成石头
Cauldron.addStoked([<ore:cobblestone>],[<minecraft:stone>]);
// 删除配方格式:
// Cauldron.remove(IItemStack[] outputs);
// 如下实例表示删除所有通过釜锅炼得石头的配方
Cauldron.remove([<minecraft:stone>]);
// 如下实例表示删除釜锅的所有配方
Cauldron.removeAll();
// 添加高级配方格式:
// Cauldron.builder()
//     .buildRecipe(IIngredient[] inputs, IItemStack[] outputs)
//     .setPriority(int priority)
//     .setHeat(int heat)
//     .setIgnoreHeat(boolean ignoreHeat)
//     .build();
// 如下实例表示在蓝火的加热下，釜锅将石头炼制成泥土
// setHeat 表示需要的热量等级，可通过热源注册器自定义热源和热量等级
Cauldron.builder()
    .buildRecipe([<ore:stone>], [<minecraft:dirt>])
    .setHeat(2)
    .setPriority(-1)
    .build();
坩埚

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
import mods.betterwithmods.Crucible;
// 添加基础配方格式:
// 需要原版火: Crucible.addUnstoked(IIngredient[] inputs, IItemStack[] outputs);
// 需要蓝火: Crucible.addStoked(IIngredient[] inputs, IItemStack[] outputs);
// 如下实例表示坩埚将圆石炼制成石头
Crucible.addStoked([<ore:cobblestone>],[<minecraft:stone>]);
// 删除配方格式:
// Crucible.remove(IItemStack[] outputs);
// 如下实例表示删除所有通过坩埚炼得石头的配方
Crucible.remove([<minecraft:stone>]);
// 如下实例表示删除坩埚的所有配方
Crucible.removeAll();
// 添加高级配方格式:
// Crucible.builder()
//     .buildRecipe(IIngredient[] inputs, IItemStack[] outputs)
//     .setPriority(int priority)
//     .setHeat(int heat)
//     .setIgnoreHeat(boolean ignoreHeat)
//     .build();
// 如下实例表示在蓝火的加热下，坩埚将石头炼制成泥土
// setHeat 表示需要的热量等级，可通过热源注册器自定义热源和热量等级
Crucible.builder()
    .buildRecipe([<ore:stone>], [<minecraft:dirt>])
    .setHeat(2)
    .setPriority(-1)
    .build();
窑炉

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
import mods.betterwithmods.Kiln;
// 添加基础配方格式:
// Kiln.add(IIngredient inputs, IItemStack[] outputs);
// 如下实例表示窑炉将圆石炼制成石头
Kiln.add(<ore:cobblestone>,[<minecraft:stone>]);
// 删除配方格式(根据输出删除):
// Kiln.remove(IItemStack[] outputs);
// 如下实例表示删除所有通过窑炉炼得石头的配方
Kiln.remove([<minecraft:stone>]);
// 如下实例表示删除窑炉的所有配方
Kiln.removeAll();
// 删除配方格式(根据输入删除)
// Kiln.remove(IIngredient input);
// 如下实例表示删除所有在窑炉输入圆石的配方
Kiln.remove(<ore:cobblestone>);
// 添加高级配方格式:
// Kiln.builder()
//     .buildRecipe(IIngredient inputs, IItemStack[] outputs)
//     .setPriority(int priority)
//     .setHeat(int heat)
//     .setIgnoreHeat(boolean ignoreHeat)
//     .build();
// 如下实例表示在蓝火的加热下，窑炉将石头炼制成泥土
// setHeat 表示需要的热量等级，可通过热源注册器自定义热源和热量等级
Kiln.builder()
    .buildRecipe(<ore:stone>, [<minecraft:dirt>])
    .setHeat(2)
    .setPriority(-1)
    .build();
滤筛漏斗

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
import mods.betterwithmods.FilteredHopper;
// 添加过滤规则，并为此规则添加代表物
// 格式如下: FilteredHopper.addFilter(String name, IIngredient item)
// 如下实例表示，添加一个名叫"modtweaker:myFilter"的过滤规则，并在漏斗插槽中装有木板时触发
FilteredHopper.addFilter("modtweaker:myFilter", <minecraft:planks>);
// 为某一规则添加允许通过的物品
// 格式如下: FilteredHopper.addFilteredItem(String name, IIngredient item)
// 如下实例表示，当滤筛漏斗使用"modtweaker:myFilter"过滤规则时，铁锭可以通过
FilteredHopper.addFilteredItem("modtweaker:myFilter",<ore:ingotIron>);
// 添加配方格式:
// FilteredHopper.addFilterRecipe(String name, IIngredient input, IIngredient[] insideOutput , IIngredient[] outsideOutput);
// 其中，insideOutput 表示输出到漏斗库存中的产物，outsideOutput 表示弹出到漏斗上方的产物
// 注意，insideOutput 和 outsideOutput 并不是可选项，想要留空需填入空数组 []
// 如下实例表示，当滤筛漏斗使用"modtweaker:myFilter"过滤规则遇到草方块时，会将其变为燧石储存在漏斗中，并在其上方弹出 9 个钻石
FilteredHopper.addFilterRecipe("modtweaker:myFilter",<minecraft:grass>,[<minecraft:flint>],[<minecraft:diamond>*9]);
// 移除某一规则下所有可通过的物品
// 格式如下: FilteredHopper.clearFilter(String name);
// 如下实例表示，移除规则"betterwithmods:wicker"的所有允许通过的物品
FilteredHopper.clearFilter("betterwithmods:wicker");
// 删除配方格式:
// 根据输出删除: FilteredHopper.removeRecipe(IIngredient[] insideOutput, IIngredient[] outsideOutput);
// 根据输入删除: FilteredHopper.removeRecipeByInput(IIngredient input);
// 如下实例表示删除所有通过滤筛漏斗在库存中输出沙子并在上方弹出燧石的配方
FilteredHopper.removeRecipe([<minecraft:sand>],[<minecraft:flint>]);
// 如下实例表示删除所有通过滤筛漏斗输入沙子的配方
FilteredHopper.removeRecipeByInput(<minecraft:sand>);
熔炉烧制时间

1
2
3
4
5
6
import mods.betterwithmods.Misc;
// 设置物品的燃烧时间
// 格式如下: Misc.setFurnaceSmeltingTime(IIngredient ingredient, int time)
// time 的单位为 tick
// 如下实例表示烤一个土豆大约需要 83 分钟
Misc.setFurnaceSmeltingTime(<minecraft:potato>,100000);
方块上移动速度

1
2
3
4
5
6
7
import mods.betterwithmods.Movement;
// 设置玩家在方块上行走时受到的速度效果
// 格式如下: Movement.set(IItemStack stack, float value);
// 其中 stack 这一物品栈必须有其对应的方块
// value 的取值范围是 [0, 2]，1 为正常速度
// 如下实例表示将玩家在冰块上的移动速度变为正常速度的 1.5 倍
Movement.set(<minecraft:ice>, 1.5);
磨石

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
import mods.betterwithmods.Mill;
// 添加基础配方格式:
// Mill.addRecipe(IIngredient[] inputs, IItemStack[] outputs);
// 如下实例表示磨石将泥土磨制成石头
Mill.addRecipe([<minecraft:dirt>],[<minecraft:stone>]);
// 删除配方格式:
// Mill.remove(IItemStack[] outputs);
// 如下实例表示删除所有通过磨石制得石头的配方
Mill.remove([<minecraft:stone>]);
// 如下实例表示删除磨石的所有配方
Mill.removeAll();
// 添加高级配方格式:
// Mill.builder()
//     .buildRecipe(IIngredient[] inputs, IItemStack[] outputs)
//     .setPriority(int priority)
//     .setGrindType(String soundLocation)
//     .setTicks(int ticks)
//     .build();
// 如下实例表示磨石研磨 3 秒将泥土磨制成石头，期间发出恶魂叫声
// setGrindType 表示研磨时发出的声音
Mill.builder()
    .buildRecipe([<minecraft:dirt>], [<minecraft:stone>])
    .setGrindType("minecraft:entity.ghast.scream")
    .setTicks(60);
    .build();
滑车管理器

1
2
3
4
5
import mods.betterwithmods.PulleyManager;
// 设置滑车和滑车锚可以拉动的方块
// 格式如下: PulleyManager.addPulleyBlock(IBlockState state);
// 如下实例表示让黑曜石可以被滑车锚拉动
PulleyManager.addPulleyBlock(<blockstate:minecraft:obsidian>);
螺杆锯

1
2
3
4
5
6
7
8
9
10
11
12
import mods.betterwithmods.Saw;
// 添加基础配方格式:
// Saw.add(IIngredient input, IItemStack[] output);
// input 必须具有与其对应的方块状态
// 如下实例表示螺杆锯将栅栏切割成木棍
Saw.add(<minecraft:fence>,[<minecraft:stick>,<minecraft:stick>]);
// 删除配方格式(根据输入删除):
// Saw.remove(IIngredient input);
// 如下实例表示删除所有在螺杆锯中输入为栅栏的配方
Saw.remove(<minecraft:fence>);
// 删除配方格式(根据输出删除):
// Saw.remove(IItemStack[] outputs);
螺杆旋转台

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
import mods.betterwithmods.Turntable;
// 添加基础配方格式:
// Turntable.add(IIngredient input, @Optional IItemStack productState, IItemStack[] output);
// input 必须具有与其对应的方块状态, productState 是在配方完成后会被放置的方块(选填)
// 如下实例表示使用螺杆旋转台加工草方块，完成后放置泥土并输出种子
Turntable.add(<minecraft:grass>, <minecraft:dirt>, [<minecraft:seed>]);
// 删除配方格式(根据输入删除):
// Turntable.remove(IIngredient input);
// 删除配方格式(根据 productState 删除):
// Turntable.removeRecipe(IItemStack productState);
// 删除所有配方:
// Turntable.removeAll();
// 配方构建器格式:
// Turntable.builder()
//    .OptionalBulider
//    .build();
// 以下为可用的 OptionalBulider:
// (1)设置配方的输入和输出: .buildRecipe(IIngredient[] inputs, IItemStack[] outputs)
// (2)设置配方所需的旋转速度(默认为8): .setRotations(int rotations)
// (3)设置配方完成时被放置的方块: .setProductState(IItemStack productState)
// 如下实例表示使用螺杆旋转台加工草方块，完成后放置泥土并输出种子，且需要10的旋转速度
Turntable.builder()
    .buildRecipe([<minecraft:grass>], [<minecraft:seed>])
    .setProductState(<minecraft:dirt>)
    .setRotations(10)
    .build();
装饰方块

1
2
3
4
5
6
7
8
9
import mods.betterwithmods.MiniBlocks;
// 这个函数用于获取特定装饰方块的 IIngredient
// 获取装饰方块的格式:
// MiniBlocks.getMiniBlock(String type, IIngredient parentBlock);
// type 必须为"siding", "moulding", "corner"中的一个
// "siding"是半板, "moulding"是条, "corner"是边角
// parentBlock 是 miniblock 从中获取纹理的块, parentBlock 是一个 IIngredient, 因此可以用 oredictionary
// 如下实例表示获取所有以木板(无论是橡木还是其他种类的木板)为基地的半板:
MiniBlocks.getMiniBlock("siding", <ore:plankWood>);
血魔法2 - Blood Magic 2

炼金矩阵

1
2
3
4
5
6
7
8
9
10
import mods.bloodmagic.AlchemyArray;
// 添加配方格式:
// AlchemyArray.addRecipe(IItemStack output, IItemStack input, IItemStack catalyst, @Optional string textureLocation);
// catalyst 是配方所需的催化剂
// 如下实例表示以草为催化剂, 将木棍转为钻石:
AlchemyArray.addRecipe(<minecraft:diamond>, <minecraft:stick>, <minecraft:grass>);
// 删除配方格式:
// AlchemyArray.removeRecipe(IItemStack input, IItemStack catalyst);
// 如下实例表示删除输入为红石, 催化剂为恶魔石板的配方:
AlchemyArray.removeRecipe(<minecraft:redstone>, <bloodmagic:slate:3>);
炼金术桌

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
import mods.bloodmagic.AlchemyTable;
// 添加配方格式:
// AlchemyTable.addRecipe(IItemStack output, IItemStack[] inputs, int syphon, int ticks, int minTier);
// inputs 数组最多可以有 6 个元素, syphon 为配方所需的 LP 值
// ticks 为配方所需的时间, minTier 为气血宝珠要满足的最低等级
// 如下实例表示用 3 个泥土, 使用 0 级气血宝珠, 消耗 20 LP, 经过 10 游戏刻, 合成钻石:
AlchemyTable.addRecipe(<minecraft:diamond>, [<minecraft:dirt>, <minecraft:dirt>, <minecraft:dirt>], 20,10,0);
// 添加药水效果配方格式:
// AlchemyTable.addPotionRecipe(IItemStack[] inputs, IPotionEffect effects, int syphon, int ticks, int minTier)
// inputs 数组最多可以有 5 个元素, syphon 为配方所需的 LP 值
// ticks 为配方所需的时间, minTier 为气血宝珠要满足的最低等级
// 如下实例先定义了一个 力量I(6000 tick) 的药水效果
// 表示用 1 个药剂瓶, 1 个胡萝卜, 1 个马铃薯, 使用 0 级气血宝珠, 消耗 20 LP, 经过 10 游戏刻, 得到该药水效果的药剂瓶:
var pot = <potion:minecraft:strength>.makePotionEffect(6000, 1);
AlchemyTable.addPotionRecipe([<bloodmagic:potion_flask>, <minecraft:carrot>,<minecraft:potato>], pot, 20, 10, 0);
// 删除配方格式(与删除药水配方格式一致):
// AlchemyTable.removeRecipe(IItemStack[] inputs);
// inputs 数组最多可以有 6 个元素
// 如下实例表示删除所有在炼金术桌中输入 3 个胡萝卜和 1 个骨粉的配方:
AlchemyTable.removeRecipe([<minecraft:carrot>,<minecraft:carrot>,<minecraft:carrot>,<minecraft:dye:15>]);
血之祭坛

1
2
3
4
5
6
7
8
9
10
11
import mods.bloodmagic.BloodAltar;
// 添加配方格式:
// BloodAltar.addRecipe(IItemStack output, IItemStack input, int minimumTier, int syphon, int consumeRate, int drainRate);
// minimumTier 为血之祭坛需要满足的最低等级, 这个数字应比你在 JEI 中查询到的血之祭坛等级数小 1, 因为它从 0 开始
// syphon 为配方所需的 LP 值, consumeRat 为配方吸取 LP 值的速率, drainRate 为 LP 耗尽后, 配方完成进度下降的速率
// 如下实例表示使用 1 级血之祭坛, 消耗 20 LP, 消耗速率为 30, LP 耗尽后进度丧失速率为 40, 用木棍合成玻璃:
BloodAltar.addRecipe(<minecraft:glass>, <minecraft:stick>, 0, 20, 30, 40);
// 删除配方格式:
// BloodAltar.removeRecipe(IItemStack input);
// 如下实例表示删除所有在血之祭坛中输入石头的配方:
BloodAltar.removeRecipe(<minecraft:stone>);
狱火熔炉

1
2
3
4
5
6
7
8
9
10
import mods.bloodmagic.TartaricForge;
// 添加配方格式:
// TartaricForge.addRecipe(IItemStack output, IItemStack[] inputs, double minSouls, double soulDrain);
// inputs 数组最多可以有 4 个元素, minSouls 为配方要求的最少意志量, soulDrain 为配方实际消耗的意志量
// 如下实例表示使用狱火熔炉, 在达到 10 意志量的条件下, 消耗 10 意志量, 将 4 个泥土转化为钻石:
TartaricForge.addRecipe(<minecraft:diamond>,[<minecraft:dirt>, <minecraft:dirt>, <minecraft:dirt>, <minecraft:dirt>], 10,10);
// 删除配方格式:
// TartaricForge.removeRecipe(IItemStack[] inputs);
// 如下实例表示删除所有在狱火熔炉中输入 1 个恶魂之泪和 2 个羽毛的配方:
TartaricForge.removeRecipe([<minecraft:ghast_tear>,<minecraft:feather>, <minecraft:feather>]);
植物魔法 - Botania

植物魔法相关命令

名称	语法	作用
酿造
/ct botbrews
将所有已注册的酿造的列表输出到 crafttweaker.log 文件
凝矿兰生成
/ct botorechid
将所有已注册的凝矿兰生成的矿石及其生成机会的列表输出到 crafttweaker.log 文件
花药台配方
/ct botania apothecary
将所有已注册的植物魔法花药台配方的列表输出到 crafttweaker.log 文件
酿造配方
/ct botania brews
将所有已注册的植物魔法酿造配方的列表输出到 crafttweaker.log 文件
精灵门交易配方
/ct botania trades
将所有已注册的精灵门交易配方的列表输出到 crafttweaker.log 文件
魔力池配方
/ct botania infusions
将所有已注册的魔力池配方的列表输出到 crafttweaker.log 文件
白雏菊配方
/ct botania daisy
将所有已注册的白雏菊配方的列表输出到 crafttweaker.log 文件
符文祭坛配方
/ct botania altar
将所有已注册的符文祭坛配方的列表输出到 crafttweaker.log 文件
植物魔法辞典
/ct botlexcats/botlexentries/botlextypes/botlexpages
将所有已注册的植物魔法辞典的类别/条目/知识种类/页面列表输出到 crafttweaker.log 文件
植物魔法辞典

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
import mods.botania.Lexicon;
// 添加辞典页面格式:
// Lexicon.addBrewPage(String name, String entry, int page_number, String brew, IIngredient[] recipe, String bottomText);
// Lexicon.addCraftingPage(String name, String entry, int page_number, String... recipeNames);
// Lexicon.addElvenPage(String name, String entry, int page_number, IItemStack[] outputs, IIngredient[][] inputs);
// Lexicon.addEntityPage(String name, String entry, int page_number, String entity, int size);
// Lexicon.addImagePage(String name, String entry, int page_number, String resource);
// Lexicon.addLorePage(String name, String entry, int page_number);
// Lexicon.addInfusionPage(String name, String entry, int page_number, IItemStack[] outputs, IIngredient[] inputs, int[] mana);
// Lexicon.addAlchemyPage(String name, String entry, int page_number, IItemStack[] outputs, IIngredient[] inputs, int[] mana);
// Lexicon.addConjurationPage(String name, String entry, int page_number, IItemStack[] outputs, IIngredient[] inputs, int[] mana);
// Lexicon.addPetalPage(String name, String entry, int page_number, IItemStack[] outputs, IIngredient[][] inputs);
// Lexicon.addRunePage(String name, String entry, int page_number, IItemStack[] outputs, IIngredient[][] inputs, int[] mana);
// Lexicon.addTextPage(String name, String entry, int page_number);
// 删除辞典页面格式:
// Lexicon.removePage(String entry, int page_number);
// 添加辞典条目格式:
// Lexicon.addEntry(String entry, String catagory, IItemStack stack);
// 删除辞典条目格式:
// Lexicon.removeEntry(String entry);
// 添加辞典类别格式:
// Lexicon.addCategory(String name);
// 删除辞典类别格式:
// Lexicon.removeCategory(String name);
// 设置类别的图标:
// Lexicon.setCategoryIcon(String name, String icon);
// 在辞典里添加配方映射:
// Lexicon.addRecipeMapping(IItemStack stack, String Entry, int page);
// 在辞典里删除配方映射:
// Lexicon.removeRecipeMapping(IItemStack stack);
植物魔法配方修改

酿造配方修改

1
2
3
4
5
6
7
8
9
10
11
import mods.botania.Brew;
// 在修改酿造配方前, 你需要明白植物魔法注册了哪些酿造效果
// 你可以使用 /ct botbrews 指令来查看, 详情见教程第8章第2节第4部分第1框
// 添加酿造配方格式:
// Brew.addRecipe(IIngredient[] input, String brewName);
// 如下实例表示用地狱疣, 甘蔗, 红石酿造速度效果:
Brew.addRecipe([<minecraft:nether_wart>, <minecraft:reeds>, <minecraft:redstone>], "speed");
// 删除酿造配方格式:
// Brew.removeRecipe(String brewName);
// 如下实例表示删除所有酿造伤害吸收效果的配方:
Brew.removeRecipe("absorption");
精灵门交易配方修改

1
2
3
4
5
6
7
8
9
import mods.botania.ElvenTrade;
// 添加精灵门交易配方格式:
// ElvenTrade.addRecipe(IIngredient[] outputs, IIngredient[] input);
// 如下实例表示泥土和玻璃在精灵门中交易得到铁锭:
ElvenTrade.addRecipe([<minecraft:iron_ingot>], [<minecraft:dirt>, <minecraft:glass>]);
// 删除精灵门交易配方格式:
// ElvenTrade.removeRecipe(IIngredient output);
// 如下实例表示删除所有通过精灵门交易得到梦之木的配方:
ElvenTrade.removeRecipe(IIngredient output);
魔力池配方修改

1
2
3
4
5
6
7
import mods.botania.ManaInfusion;
// 添加魔力池配方格式:
// ManaInfusion.addInfusion(IItemStack output, IIngredient input, int mana);
// ManaInfusion.addAlchemy(IItemStack output, IIngredient input, int mana);
// ManaInfusion.addConjuration(IItemStack output, IIngredient input, int mana);
// 删除魔力池配方格式:
// ManaInfusion.removeRecipe(IIngredient output);
凝矿兰生成配方修改

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import mods.botania.Orechid;
// 对于矿辞对象, 你可以使用 IOreDictEntry 或者用 String 格式书写矿辞的 id
// 同时注册两个权重相同的配方会使游戏崩溃!
// 添加凝矿兰生成配方格式(用 IOreDictEntry):
// Orechid.addOre(IOreDictEntry oreDict, int weight);
// 如下实例表示让凝矿兰生成原木, 权重为 500:
Orechid.addOre(<ore:logWood>, 500);
// 添加凝矿兰生成配方格式(用 String):
// Orechid.addOre(String oreDict, int weight);
// 如下实例表示让凝矿兰生成原木, 权重为 500:
Orechid.addOre("logWood", 500);
// 删除凝矿兰生成配方格式(用 IOreDictEntry):
// Orechid.removeOre(IOreDictEntry oreDict);
// 如下实例表示让凝矿兰不再生成金矿石:
Orechid.removeOre(<ore:oreGold>);
// 删除凝矿兰生成配方格式(用 String):
// Orechid.removeOre(String oreDict);
// 如下实例表示让凝矿兰不再生成金矿石:
Orechid.removeOre("oreGold");
炎矿兰生成配方修改

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import mods.botania.OrechidIgnem;
// 对于矿辞对象, 你可以使用 IOreDictEntry 或者用 String 格式书写矿辞的 id
// 同时注册两个权重相同的配方会使游戏崩溃!
// 添加炎矿兰生成配方格式(用 IOreDictEntry):
// OrechidIgnem.addOre(IOreDictEntry oreDict, int weight);
// 如下实例表示让炎矿兰生成原木, 权重为 500:
OrechidIgnem.addOre(<ore:logWood>, 500);
// 添加炎矿兰生成配方格式(用 String):
// OrechidIgnem.addOre(String oreDict, int weight);
// 如下实例表示让炎矿兰生成原木, 权重为 500:
OrechidIgnem.addOre("logWood", 500);
// 删除炎矿兰生成配方格式(用 IOreDictEntry):
// OrechidIgnem.removeOre(IOreDictEntry oreDict);
// 如下实例表示让炎矿兰不再生成金矿石:
OrechidIgnem.removeOre(<ore:oreGold>);
// 删除炎矿兰生成配方格式(用 String):
// OrechidIgnem.removeOre(String oreDict);
// 如下实例表示让炎矿兰不再生成金矿石:
OrechidIgnem.removeOre("oreGold");
花药台配方修改

1
2
3
4
5
6
7
8
9
10
11
12
13
14
import mods.botania.Apothecary;
// 可以使用返回的 IItemStack 作为输出参数添加配方, 也可以使用植物花的名称作为字符串添加配方
// 字符串名称仅适用于 Botania Flowers
// 注意: 花药台被硬编码, 只能接受植物魔法的花瓣, 其他的物品无法丢进花药台
// 添加花药台配方格式:
// Apothecary.addRecipe(IItemStack output, IIngredient[] input);
// Apothecary.addRecipe(String output, IIngredient[] input);
// 如下实例表示用花瓣合成西瓜:
Apothecary.addRecipe(<minecraft:melon>, [<ore:petalLime>, <ore:petalLime>, <ore:petalLime>]);
// 删除花药台配方格式:
// Apothecary.removeRecipe(IItemStack output);
// Apothecary.removeRecipe(String output);
// 如下实例表示删除通过花药台合成太阳花的配方:
Apothecary.removeRecipe("daybloom");
白雏菊配方修改

1
2
3
4
5
6
7
8
9
10
import mods.botania.PureDaisy;
// 添加配方格式:
// PureDaisy.addRecipe(IIngredient blockInput, IItemStack blockOutput, @Optional int time);
// time 为白雏菊催化方块所需的时间, 默认为 150 ticks
// 如下实例表示白雏菊消耗 50 ticks 将泥土转化成草方块:
PureDaisy.addRecipe(<minecraft:dirt>, <minecraft:grass>, 50);
// 删除配方格式:
// PureDaisy.removeRecipe(IIngredient output);
// 如下实例表示删除通过白雏菊转化得到黑曜石的配方:
PureDaisy.removeRecipe(<minecraft:obsidian>);
符文祭坛配方修改

1
2
3
4
5
6
7
8
9
import mods.botania.RuneAltar;
// 添加符文祭坛配方格式:
// RuneAltar.addRecipe(IItemStack output, IIngredient[] input, int mana);
// 如下实例表示通过符文祭坛, 将木板和草方块用 200 Mana 转化为木板:
RuneAltar.addRecipe(<minecraft:planks>,[<minecraft:grass>, <minecraft:dirt>], 200);
// 删除符文祭坛配方格式:
// RuneAltar.removeRecipe(IIngredient output);
// 如下实例表示删除通过符文祭坛合成符文的配方:
RuneAltar.removeRecipe(<Botania:rune>);
凿子 - Chisel

雕刻修改

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
import mods.chisel.Carving;
// 添加雕刻组, 处在雕刻组内的方块可被雕刻成各种纹理, 格式如下:
// Carving.addGroup(String name);
// 向某一雕刻组添加方块, 格式如下:
// Carving.addVariation(String groupName, IItemStack stack);
// 如下实例表示新建一个"test"雕刻组, 并向该组内添加石头:
Carving.addGroup("test");
Carving.addVariation("test", <minecraft:stone>);
// 删除雕刻组, 可使用命令"/ct chiselGroups"查询组名, 格式如下:
// Carving.removeGroup(String name);
// 将方块从某一雕刻组中移除, 格式如下:
// Carving.removeVariation(String groupName, IItemStack stack);
// 如下实例表示把石头移出"test"组, 并把该组删除:
Carving.removeVariation("test", <minecraft:stone>);
Carving.removeGroup("test");
更多实用设备2 - Extra Utilities 2

粉碎机

1
2
3
4
5
6
7
8
9
10
import mods.extrautils2.Crusher;
// 添加粉碎机配方格式(@Optional 表示可选项):
// Crusher.add(IItemStack output, IItemStack input, @Optional IItemStack secondaryOutput, @Optional float secondaryChance);
// 其中 secondaryOutput 表示副产物, secondaryChance 表示副产物生成的概率(其值不小于 0, 不大于 1)
// 如下实例表示使用粉碎机将 1 个金块粉碎为 9 个金锭, 并有 10% 的概率生成 1 个铁锭的副产物:
Crusher.add(<minecraft:gold_ingot> * 9, <minecraft:gold_block>, <minecraft:iron_ingot>, 0.1f);
// 删除粉碎机配方格式:
// Crusher.remove(IItemStack output);
// 如下实例表示删除所有通过粉碎机得到红石的配方:
Crusher.remove(<minecraft:redstone>);
共振仪

1
2
3
4
5
6
7
8
9
10
import mods.extrautils2.Resonator;
// 添加共振仪配方格式(@Optional 表示可选项):
// Resonator.add(IItemStack output, IItemStack input, int energy, @Optional boolean addOwnerTag);
// 其中 energy 表示消耗的能量, 1 GP = 100 energy
// 如下实例表示使用共振仪消耗 2 GP 将 1 个铁块转化为 1 个金块, 且不添加拥有者标签:
Resonator.add(<minecraft:gold_block>, <minecraft:iron_block>, 200, false);
// 删除共振仪配方格式:
// Resonator.remove(IItemStack outout);
// 如下实例表示删除所有通过共振仪合成红石的配方:
// Resonator.remove(<minecraft:redstone>);
林业 - Forestry

木工机

1
2
3
4
5
6
7
8
9
10
import mods.forestry.Carpenter;
// 添加木工机配方格式(@Optional 表示可选项):
// Carpenter.addRecipe(IItemStack output, IIngredient[][] ingredients, int packagingTime, @Optional ILiquidStack fluidInput, @Optional IItemStack box);
// 其中 ILiquidStack 是流体栈数据类型, IIngredient[][] 是二维数组, box 表示木工机需要的模板
// 如下实例表示通过木工机消耗 200 mB 水, 以石头作为模版用 60 ticks 将铺满 9 个格子的红石合成为 1 个红石块:
Carpenter.addRecipe(<minecraft:redstone_block>, [[<minecraft:redstone>,<minecraft:redstone>,<minecraft:redstone>],[<minecraft:redstone>,<minecraft:redstone>,<minecraft:redstone>],[<minecraft:redstone>,<minecraft:redstone>,<minecraft:redstone>]], 60, <liquid:water> * 200, <minecraft:stone>);
// 删除木工机配方格式(@Optional 表示可选项):
// Carpenter.removeRecipe(IItemStack output, @Optional ILiquidStack fluidInput);
// 如下实例表示删除所有通过木工机消耗水合成木浆的配方:
Carpenter.removeRecipe(<forestry:wood_pulp>, <liquid:water>);
离心机

1
2
3
4
5
6
7
8
9
10
import mods.forestry.Centrifuge;
// 添加离心机配方格式:
// Centrifuge.addRecipe(WeightedItemStack[] output, IItemStack ingredients, int packagingTime);
// 其中 output 是一个数组, 可以用百分数表示产物概率
// 如下实例表示通过离心机用 100 ticks 将 1 个红石块离心, 80% 几率得到 9 个红石, 12% 几率得到 1 个金锭:
Centrifuge.addRecipe([(<minecraft:redstone> * 9) % 80, <minecraft:gold_ingot> % 12], <minecraft:redstone_block>, 100);
// 删除离心机配方格式:
// Centrifuge.removeRecipe(IIngredient input);
// 如下实例表示删除所有通过离心机离心蜂窝的配方:
Centrifuge.removeRecipe(<forestry:bee_combs:*>);
木炭堆

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
import mods.forestry.CharcoalWall;
// ModTweaker 可以修改多方块结构木炭堆的外壁方块, 有三种方法, 格式如下:
// CharcoalWall.addWall(IBlock block, int amount);
// CharcoalWall.addWallState(IBlockState state, int amount);
// CharcoalWall.addWallStack(IItemStack stack, int amount);
// 其中, amount 表示用该方块作为外壁时, 最终获得的灰烬块数量
// 第一种使用 IBlock 数据类型, 可使用 IItemStack.asBlock()
// 第二种使用 IBlockState 数据类型, 使用尖括号调用直接调取方块
// 第三种使用 IItemStack 数据类型, 必须具有与其对应的 IBlockState
// 如下实例使用三种不同方法将基岩设为木炭堆外壁, 且获得 10 个灰烬块:
CharcoalWall.addWall(<minecraft:bedrock>.asBlock(), 10);
CharcoalWall.addWallState(<blockstate:minecraft:bedrock>, 10);
CharcoalWall.addWallStack(<minecraft:bedrock>, 10);
// 删除木炭堆外壁方块的方法依然有三种, 格式如下:
// CharcoalWall.removeWall(IBlock block);
// CharcoalWall.removeWallState(IBlockState state);
// CharcoalWall.removeWallStack(IItemStack stack);
// 三种方法的数据类型使用参考上文
// 如下实例使用三种不同的方法让基岩不再能作为木炭堆外壁:
CharcoalWall.removeWall(<minecraft:bedrock>.asBlock());
CharcoalWall.removeWallState(<blockstate:minecraft:bedrock>);
CharcoalWall.removeWallStack(<minecraft:bedrock>);
发酵机

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
import mods.forestry.Fermenter;
// ModTweaker 可以修改发酵机的配方和燃料
// 添加发酵机配方格式:
// Fermenter.addRecipe(ILiquidStack fluidOutput, IItemStack resource, ILiquidStack fluidInput, int fermentationValue, float fluidOutputModifier);
// 其中, fermentationValue 表示有机物需要的发酵剂数量, fluidOutputModifier 表示该配方下的产物倍率
// 如下实例表示通过发酵机将 1 个黑曜石与 1000 mB 水发酵为 0.5 x 1000 = 500 mB 熔岩: 
Fermenter.addRecipe(<liquid:lava>, <minecraft:obsidian>, <liquid:water>, 1000, 0.5);
// 添加发酵机发酵生物燃料的有机物格式:
// Fermenter.addFuel(IItemStack item, int fermentPerCycle, int burnDuration);
// 其中, fermentPerCycle 表示有机物在每个发酵循环可处理的发酵剂数量, burnDuration 表示有机物持续的发酵循环数
// 如下实例表示添加树叶作为发酵机发酵生物燃料的有机物, 每个发酵循环处理 100 mB 水, 可以持续 5 个发酵循环
Fermenter.addFuel(<minecraft:leaves:1>, 100, 5);
// 删除发酵机配方格式:
// Fermenter.removeRecipe(IIngredient input);
// 如下实例表示删除所有在发酵机中输入水的配方:
Fermenter.removeRecipe(<liquid:water>);
// 删除发酵机发酵生物燃料的有机物格式:
// Fermenter.removeFuel(IIngredient fermenterItem);
// 如下实例表示不再将肥料作为发酵机发酵生物燃料的有机物:
Fermenter.removeFuel(<forestry:fertilizer_compound>);
加湿器

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
import mods.forestry.Moistener;
// ModTweaker 可以修改加湿器的配方和培养元
// 添加加湿器配方格式:
// Moistener.addRecipe(IItemStack output, IItemStack input, int packagingTime);
// 其中, packagingTime 表示加工总值, 其与下述培养元的 moistenerValue 相除所得的商即为使用该培养元加工的加工次数
// 如下实例表示使用加湿器将草方块加湿为菌丝, 加工总值为 60:
Moistener.addRecipe(<minecraft:mycelium>, <minecraft:grass>, 60);
// 添加加湿器培养元格式:
// Moistener.addFuel(IItemStack item, IItemStack product, int moistenerValue, int stage);
// 其中, moistenerValue 表示加工单值, 上述配方中的 packagingTime 与其相除所得的商即为使用该培养元加工的加工次数
// stage 表示培养元等级, 等级较低的培养元将被优先消耗
// 如下实例表示将金锭作为加湿器的培养元, 产物为铁锭, 加工单值为 20, 培养元等级为 2
Moistener.addFuel(<minecraft:gold_ingot>, <minecraft:iron_ingot>, 20, 2);
// 删除加湿器配方格式:
// Moistener.removeRecipe(IIngredient output);
// 如下实例表示删除所有通过加湿器得到菌丝的配方:
Moistener.removeRecipe(<minecraft:mycelium>);
// 删除加湿器培养元格式:
// Moistener.removeFuel(IIngredient moistenerItem);
// 如下实例表示不再将金锭作为加湿器的培养元:
Moistener.removeFuel(<minecraft:gold_ingot>);
榨汁机

1
2
3
4
5
6
7
8
9
10
11
import mods.forestry.Squeezer;
// 添加榨汁机配方格式:
// Squeezer.addRecipe(ILiquidStack fluidOutput, IItemStack[] ingredients, int timePerItem, @Optional WeightedItemStack itemOutput);
// 其中, @Optional 表示可选项, timePerItem 表示一份有机物榨出液体的量, itemOutput 表示副产物及其概率
// 如下实例表示使用榨汁机将 1 个黑曜石转化为 120 mB 熔岩, 同时有 20% 概率产出副产物红石
Squeezer.addRecipe(<liquid:lava>, [<minecraft:obsidian>], 120, <minecraft:redstone> % 20);
// 删除榨汁机配方格式:
// Squeezer.removeRecipe(ILiquidStack liquid, @Optional IIngredient[] ingredients);
// 其中, @Optional 表示可选项, 你不能删除承装产出液体的容器, 比如你不能禁止桶承装产出的液体
// 如下实例表示删除所有通过榨汁机将小麦种子榨成种子油的配方:
Squeezer.removeRecipe(<liquid:seed.oil>, [<minecraft:wheat_seeds>]);
蒸馏器

1
2
3
4
5
6
7
8
9
10
11
import mods.forestry.Still;
// 添加蒸馏器配方格式:
// Still.addRecipe(ILiquidStack fluidOutput, ILiquidStack fluidInput, int timePerUnit);
// 其中, timePerUnit 表示单轮蒸馏的最大液体体积
// 如下实例表示通过蒸馏器将水转化为熔岩, 且单轮蒸馏最多转化 200 mB 水:
Still.addRecipe(<liquid:lava>, <liquid:water>, 200);
// 删除蒸馏器配方格式:
// Still.removeRecipe(ILiquidStack output, @Optional ILiquidStack fluidInput);
// 其中, @Optional 表示可选项
// 如下实例表示删除所有通过蒸馏器的得到乙醇的配方:
Still.removeRecipe(<liquid:bio.ethanol>);
热电子加工台

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import mods.forestry.ThermionicFabricator;
// 添加热电子加工台配方格式:
// ThermionicFabricator.addCast(IItemStack output, IIngredient[][] ingredients, ILiquidStack liquidStack, @Optional IItemStack plan);
// 其中, @Optional 表示可选项, plan 表示在热电子加工台 GUI 中右上角的物品, ingredients 表示合成表内的物品, 记得用二维数组书写
// 如下实例表示通过热电子加工台加工 144 mB 液态玻璃, 在打蜡工具的参与下, 消耗 1 个淡蓝色染料, 得到 1 个淡蓝色染色玻璃:
ThermionicFabricator.addCast(<minecraft:stained_glass:3>, [[<ore:dyeLightBlue>,null,null],[null,null,null],[null,null,null]], <liquid: glass> * 144, <forestry:wax_cast>);
// 添加热电子加工台熔融配方格式:
// ThermionicFabricator.addSmelting(ILiquidStack liquidStack, IItemStack itemInput, int meltingPoint);
// 其中, meltingPoint 表示熔点, 考虑到林业模组的稳定性, 不建议输出除液态玻璃外的其他流体
// 如下实例表示在热电子加工台内将 1 个石头熔成 120 mB 液态玻璃, 熔点为 500
ThermionicFabricator.addSmelting(<liquid:glass> * 120, <minecraft:stone>, 500);
// 删除热电子加工台配方格式:
// ThermionicFabricator.removeCast(IIngredient product);
// 如下实例表示删除所有通过热电子加工台得到钻石电子管的配方:
ThermionicFabricator.removeCast(<forestry:thermionic_tubes:5>);
// 删除热电子加工台熔融配方格式:
// ThermionicFabricator.removeSmelting(IIngredient itemInput);
// 如下实例表示热电子工作台不再熔化沙子:
ThermionicFabricator.removeSmelting(<minecraft:sand>);
灵感 - Inspirations

炼药锅

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
import mods.inspirations.Cauldron;
// 定义单位: 1 桶 = 1 炼药锅 = 3 瓶
// 添加"物品+流体→物品"形式的配方格式:
// Cauldron.addFluidRecipe(IItemStack output, IIngredient input, ILiquidStack fluid, @Optional int levels, @Optional boolean boiling);
// 其中, @Optional 表示可选项, levels 表示进行一次制作消耗的流体, 范围在 0 到 3 之间, boiling 表示是否需要火焰加热
// leaves 默认为 1, boiling 默认为 false
// 如下实例表示在炼药锅中加入熔岩, 消耗炼药锅内全部 3 瓶熔岩将 1 根烈焰棒转化为 8 个烈焰粉, 不需要加热:
Cauldron.addFluidRecipe(<minecraft:blaze_powder> * 8, <minecraft:blaze_rod>, <liquid:lava>, 3, false);
// 删除"物品+流体→物品"形式的配方格式:
// Cauldron.removeFluidRecipe(IIngredient output, @Optional IIngredient input, @Optional ILiquidStack fluid);
// 其中, @Optional 表示可选项
// 如下实例表示删除所有通过炼药锅制作甜菜汤的"物品+流体→物品"形式配方:
Cauldron.removeFluidRecipe(<minecraft:beetroot_soup>);
// 添加"物品+流体→流体"形式的配方格式:
// Cauldron.addFluidTransform(ILiquidStack output, IIngredient input, ILiquidStack fluid, @Optional int maxLevels, @Optional boolean boiling);
// 其中, @Optional 表示可选项, maxLevels 表示进行一次制作不能超过的流体数量, 范围在 1 到 3 之间, boiling 表示是否需要火焰加热
// 如下实例表示通过炼药锅将最多 2 瓶水用 1 个烈焰粉转化为 2 瓶熔岩, 不需要加热:
Cauldron.addFluidTransform(<liquid:lava>, <minecraft:blaze_powder>, <liquid:water>, 2, false);
// 删除"物品+流体→流体"形式的配方格式:
// Cauldron.removeFluidTransform(IIngredient output, @Optional IIngredient input, @Optional IFluidStack fluid);
// 其中, @Optional 表示可选项
// 如下实例表示删除所有通过炼药锅获取甜菜汤流体的"物品+流体→流体"形式配方:
Cauldron.removeFluidTransform(<liquid:beetroot_soup>);
// 添加通过物品填充流体的配方格式:
// Cauldron.addFillRecipe(IIngredient input, ILiquidStack fluid, @Optional int levels, @Optional IItemStack container);
// 其中, @Optional 表示可选项, levels 表示单次填充的流体数量, 范围在 1 到 3 之间, container 表示返还的物品, 不填即表示不返还
// 如下实例表示使用 1 个钻石可以向炼药锅内填充 2 瓶熔岩, 返还 1 个绿宝石:
Cauldron.addFillRecipe(<ore:gemDiamond>, <liquid:lava>, 2, <minecraft:emerald>);
// 删除通过物品填充流体的配方格式:
// Cauldron.removeFillRecipe(IIngredient input, @Optional ILiquidStack fluid);
// 其中, @Optional 表示可选项
// 如下实例表示删除所有填充蘑菇煲流体的配方:
Cauldron.removeFillRecipe(<*>, <liquid:mushroom_stew>);
// 由于 inspirations 采用 Strings 而非 IPotion 来表示药水, 可使用 /ct inspirations potions 来查询所有药水的字符串
// 添加药水酿造配方格式:
// Cauldron.addBrewingRecipe(String output, String input, IIngredient reagent);
// 如下实例表示用钻石和粗制的药水酿造隐身药水:
Cauldron.addBrewingRecipe("minecraft:invisibility", "minecraft:thick", <minecraft:diamond>);
// 删除药水酿造配方格式:
// Cauldron.removeBrewingRecipe(String output, @Optional String input, @Optional IIngredient reagent);
// 其中, @Optional 表示可选项
// 如下实例表示删除所有通过炼药锅药水酿造得到急迫药水的配方:
Cauldron.removeBrewingRecipe("inspirations:haste");
// 添加"物品+药水→物品"形式的配方格式:
// Cauldron.addPotionRecipe(IItemStack output, IIngredient input, String potion, @Optional int levels, @Optional boolean boiling);
// 其中, @Optional 表示可选项, levels 表示进行一次制作消耗的流体, 范围在 0 到 3 之间, boiling 表示是否需要火焰加热
// 如下实例表示在加热的条件下, 苹果消耗炼药锅内 2 瓶再生药水得到金苹果:
Cauldron.addPotionRecipe(<minecraft:golden_apple>, <minecraft:apple>, "minecraft:regeneration", 2, true);
// 删除"物品+药水→物品"形式的配方格式:
// Cauldron.removePotionRecipe(IIngredient output, @Optional IIngredient input, @Optional String potion);
// 其中, @Optional 表示可选项
// 如下实例表示删除所有通过炼药锅制作金苹果的"物品+药水→物品"形式配方:
Cauldron.removePotionRecipe(<minecraft:golden_apple>);
// 由于 inspirations 采用 Strings 来表示不同颜色的水, 可使用 /ct inspirations dyes 来查询所有不同颜色水的字符串
// 添加物品染色配方格式:
// Cauldron.addDyeRecipe(IItemStack output, IIngredient input, String dye);
// 如下实例表示通过蓝色的水将绿宝石染成钻石:
Cauldron.addDyeRecipe(<minecraft:diamond>, <minecraft:emerald>, "blue");
// 删除物品染色配方格式:
// Cauldron.removeDyeRecipe(IIngredient output, @Optional IIngredient input, @Optional String dye)
// 其中, @Optional 表示可选项
// 如下实例表示删除所有使用蓝色的水进行染色的物品染色配方:
Cauldron.removeDyeRecipe(<*>, <*>, "blue");
精致存储 - Refined Storage

压印器

1
2
3
4
5
6
7
8
9
10
11
import mods.refinedstorage.Solderer;
// 注意: 压印器已经在该模组的 1.6 版本后被移除, ModTweaker 的这个方法实际上无效, 仅作为兼容意义而存在!
// 添加压印器配方格式:
// Solderer.addRecipe(IItemStack output, int time, IItemStack[] rows);
// 其中, time 的单位是 tick, 原料是一个一维数组, 内部必须为 3 个元素, 不需要 3 个物品的可以使用 null
// 如下实例表示通过压印器经过 5 秒将 3 个铁锭压印成 1 个金锭:
Solderer.addRecipe(<minecraft:gold_ingot>, 100, [<minecraft:iron_ingot>, <minecraft:iron_ingot>, <minecraft:iron_ingot>]);
// 删除压印器配方格式:
// Solderer.removeRecipe(IItemStack output);
// 如下实例表示删除所有通过压印器制作铁锭的配方:
Solderer.removeRecipe(<minecraft:iron_ingot>);
匠魂2 - Tinkers' Construct 2

匠魂2相关命令

名称	语法	作用
匠魂材料
/ct ticmat
输出游戏内所有匠魂材料为一个列表
匠魂2相关尖括号调用

ModTweaker 为匠魂材料提供了尖括号调用

可使用 <ticmat:mat> 来调用匠魂材料, 如 <ticmat:stone> 调用了匠魂材料圆石

该尖括号调用返回对象的数据类型为 ITICMaterial, 关于此普通数据类型的详细信息, 参考: https://docs.blamejared.com/1.12/en/Mods/Modtweaker/TConstruct/Materials/ITICMaterial/

匠魂2配方修改

合金

1
2
3
4
5
6
7
8
9
10
11
import mods.tconstruct.Alloy;
// 添加合金配方格式:
// Alloy.addRecipe(ILiquidStack output, ILiquidStack[] inputs);
// 如下实例表示 2mB 熔融玛玉灵, 1mB 熔融精金, 2mB 熔融末影可以合金得到 2mB 熔融聚合矩阵, 该配方实例来自贪婪整合包:
Alloy.addRecipe(<liquid:fusion_matrix> * 2, [<liquid:manyullyn> * 2, <liquid:adamant_fluid> * 1, <liquid:enderium> * 2]);
// 删除合金配方格式:
// Alloy.removeRecipe(ILiquidStack output, @Optional ILiquidStack[] inputs);
// 其中, Optional 表示可选项
// 如下实例表示删除所有通过合金得到熔融聚合矩阵的配方:
Alloy.removeRecipe(<liquid:fusion_matrix>);
// 注意: 实例中的流体未必是模组本身就添加的, 因为 ContentTweaker 可以自定义流体, 或许是整合包作者添加的自定义流体
浇筑

1
2
3
4
5
6
7
8
9
10
11
12
13
import mods.tconstruct.Casting;
// 添加浇筑配方格式:
// 浇筑台: Casting.addTableRecipe(IItemStack output, IIngredient cast, ILiquidStack fluid, int amount, @Optional boolean consumeCast, @Optional int time);
// 铸造盆: Casting.addBasinRecipe(IItemStack output, IIngredient cast, ILiquidStack fluid, int amount, @Optional boolean consumeCast, @Optional int time);
// 其中, @Optional 表示可选项, amount 表示所需流体的数量, 单位为 mB, consumeCast 表示是否消耗铸模物品, time 表示流体在容器中等待成型的时间, 单位为 tick
// 如下实例表示用 10 桶极寒之凛冰浇筑并消耗 1 颗绿宝石, 等待 10 秒成型后得到 1 个极寒圣物, 该配方实例来自贪婪整合包:
Casting.addTableRecipe(<additions:greedycraft-cryonic_artifact>, <minecraft:emerald>, <liquid:cryotheum>, 10000, true, 200);
// 删除浇筑配方格式:
// 浇筑台: Casting.removeTableRecipe(IItemStack output, @Optional ILiquidStack input);
// 铸造盆: Casting.removeBasinRecipe(IItemStack output, @Optional ILiquidStack input);
// 其中, @Optional 表示可选项
// 如下实例表示删除所有通过浇筑得到铁锭的配方:
Casting.removeTableRecipe(<minecraft:iron_ingot>);
晾干

1
2
3
4
5
6
7
8
9
10
11
import mods.tconstruct.Drying;
// 添加晾干配方格式:
// Drying.addRecipe(IItemStack output, IIngredient input, int time);
// 其中, time 表示晾干需要的时间, 单位为 tick
// 如下实例表示在晾干架上将 1 个腐肉晾晒 5 秒得到 1 个皮革:
Drying.addRecipe(<minecraft:leather>, <minecraft:rotten_flesh>, 100);
// 删除晾干配方格式:
// Drying.removeRecipe(IItemStack output, @Optional IItemStack input);
// 其中, @Optional 表示可选项
// 如下实例表示删除所有通过晾干腐肉得到皮革的配方:
Drying.removeRecipe(<minecraft:leather>, <minecraft:rotten_flesh>);
熔融

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
import mods.tconstruct.Melting;
// 定义温标关系: K = °C + 300
// 匠魂定义 1 个锭的熔融物质数量为 144mB
// 添加熔融物品配方格式:
// Melting.addRecipe(ILiquidStack output, IIngredient input, @Optional int temp);
// 其中, @Optional 表示可选项, temp 是熔点温度, 使用 K 式温标, 默认值为 500
// 如下实例表示在燃料温度高于 500K 时, 可使用冶炼炉将 1 个铁锭熔为 144mB 熔融铁:
Melting.addRecipe(<liquid:iron> * 144, <minecraft:iron_ingot>, 500);
// 删除熔融物品配方格式:
// Melting.removeRecipe(ILiquidStack output, @Optional IItemStack input);
// 其中, @Optional 表示可选项
// 如下实例表示删除所有通过熔化铁锭得到熔融铁的配方:
Melting.removeRecipe(<liquid:iron>, <minecraft:iron_ingot>);
// 添加熔融实体配方格式:
// Melting.addEntityMelting(IEntityDefinition entity, ILiquidStack stack);
// 该类型配方无需先删后增, 会直接覆写原配方
// 如下实例表示熔融羊可以得到极寒之凛冰:
Melting.addEntityMelting(<entity:minecraft:sheep>, <liquid:cryotheum>);
// 删除熔融实体配方格式:
// Melting.removeEntityMelting(IEntityDefinition entity);
// 如下实例表示删除所有熔融村民的配方:
Melting.removeEntityMelting(<entity:minecraft:villager>);
冶炼炉燃料

1
2
3
4
5
6
7
8
import mods.tconstruct.Fuel;
// 冶炼炉燃料注册格式:
// Fuel.registerFuel(ILiquidStack fuel, int duration); 
// fuel 可以填写数量, 表示冶炼炉单次最少消耗的流体数量, 单位为 mB
// duration 表示单次消耗最少流体数量后, 该燃料的持续供给时长, 单位为 tick
// 如下实例表示向冶炼炉燃料中注册水, 单次最少消耗 2mB 并持续供给 15 秒:
Fuel.registerFuel(<liquid:water> * 2, 300);
// 温馨提示: 自定义流体的温度是通过 ContentTweaker 注册流体时定义的
匠魂补充 - Tinkers' Complement

微缩冶炼炉黑名单

1
2
3
4
5
6
7
8
9
10
11
12
13
import mods.tcomplement.Blacklist;
// 匠魂补充的配置文件tcomplement.cfg中定义了一个黑名单, 微型冶炼炉不能熔融黑名单里的物品, 使它变为熔融焦黑石头
// 在 blacklistStone=false 时, 石头和圆石及其部件可以被熔融, 此时你可以使用添加黑名单的方法, 让某些东西无法被熔融
// 在 blacklistStone=true 时, 石头和圆石及其部件无法被熔融，此时你可以使用移除黑名单的方法，让某些东西可以被熔融
// 注意, 填写其他配方是无效的, 你不能通过这个黑名单让焦黑石头无法被熔融，这个方法只能让你交互模组已定义的黑名单!
// 添加微缩冶炼炉黑名单配方格式:
// Blacklist.addRecipe(ILiquidStack output, IItemStack input);
// 如下实例使得在 blacklistStone=false 时, 石头依然无法被熔融成熔融焦黑石头:
Blacklist.addRecipe(<liquid:stone>, <minecraft:stone>);
// 移除微缩冶炼炉黑名单配方格式:
// Blacklist.removeRecipe(IItemStack input);
// 如下实例使得在 blacklistStone=true 时, 圆石仍能被熔融成熔融焦黑石头:
Blacklist.removeRecipe(<minecraft:cobblestone>);
微缩冶炼炉配方覆写

1
2
3
4
5
6
7
8
9
10
11
12
import mods.tcomplement.Overrides;
// 通过覆写你可以修改微缩冶炼炉的配方
// 添加微缩冶炼炉配方格式:
// Overrides.addRecipe(ILiquidStack output, IItemStack input, @Optional int temp);
// 其中, @Optional 表示可选项, temp 是熔点温度, 使用 K 式温标
// 如下实例表示通过微缩冶炼炉将 1 个金锭熔融为 100mB 熔融金, 并需要 1000K 的温度:
Overrides.addRecipe(<liquid:gold> * 100, <minecraft:gold_ingot>, 1000);
// 删除微缩冶炼炉配方格式:
// Overrides.removeRecipe(ILiquidStack output, @Optional IItemStack input);
// 其中, @Optional 表示可选项
// 如下实例表示删除所有通过微缩冶炼炉熔融金矿石得到熔融金的配方:
Overrides.removeRecipe(<liquid:gold>, <minecraft:gold_ore>);
高炉

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
import mods.tcomplement.highoven.HighOven;
// 添加高炉燃料格式:
// HighOven.addFuel(IIngredient fuel, int time, int rate);
// 其中, time 表示燃烧持续时间, 单位为 tick; rate 表示燃烧每秒升高的温度
// 如下实例表示添加干草块作为高炉燃料, 1 个燃烧 3 分钟, 每秒提高 5K 的温度
HighOven.addFuel(<minecraft:hay_block>, 3600, 5);
// 删除高炉燃料格式:
// HighOven.removeFuel(IIngredient fuel);
// 如下实例表示不再让木炭作为高炉的燃料:
HighOven.removeFuel(<minecraft:coal:1>);
// 高炉可以使用匠魂冶炼炉的熔融配方, 但匠魂冶炼炉不能应用高炉的熔融配方
// 添加高炉熔融物品配方格式:
// HighOven.addMeltingOverride(ILiquidStack output, IIngredient input, @Optional int temp)
// 其中, @Optional 表示可选项, temp 是熔点温度, 使用 K 式温标
// 如下实例表示在温度高于 2567K 时, 可使用高炉将 1 个铁锭熔为 144mB 熔融钢:
HighOven.addMeltingOverride(<liquid:steel> * 144, <ore:ingotIron>, 2567);
// 删除高炉熔融物品配方格式:
// HighOven.removeMeltingOverride(ILiquidStack output, @Optional IItemStack input)
// 其中, @Optional 表示可选项
// 如下实例表示删除所有通过熔化铁锭得到熔融铁的配方:
HighOven.removeMeltingOverride(<liquid:iron>, <minecraft:iron_ingot>);
// 添加高炉加热配方格式:
// HighOven.addHeatRecipe(ILiquidStack output, ILiquidStack input, int temp);
// 其中, temp 是熔点温度, 使用 K 式温标
// 如下实例表示在温度高于 1450K 时, 可使用高炉将 1000mB 熔岩加热为 144mB 熔融铁:
HighOven.addHeatRecipe(<liquid:iron> * 144, <liquid:lava> * 1000, 1450);
// 删除高炉加热配方格式:
// HighOven.removeHeatRecipe(ILiquidStack output, @Optional ILiquidStack input);
// 其中, @Optional 表示可选项
// 如下实例表示删除所有通过高炉加热使水变为水蒸气的配方:
HighOven.removeHeatRecipe(<liquid:steam>, <liquid:water>);
高炉合金

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
import mods.tcomplement.highoven.HighOven;
import mods.tcomplement.highoven.MixRecipeBuilder;
import mods.tcomplement.highoven.MixRecipeManager;
// 删除高炉合金配方格式:
// HighOven.removeMixRecipe(ILiquidStack output, @Optional ILiquidStack input);
// 其中, @Optional 表示可选项
// 如下实例表示删除熔融钢的所有高炉合金配方
HighOven.removeMixRecipe(<liquid:steel>);
// 添加高炉合金配方格式:
// HighOven.newMixRecipe(ILiquidStack output, ILiquidStack input, int temp);
// 其中, temp 是熔点温度, 使用 K 式温标
// 你可以使用配方构建器和链式调用实现更多功能
// 如下实例使用链式调用, 配合注释使用:
// 更多的方法可参考: https://docs.blamejared.com/1.12/en/Mods/Modtweaker/TComplement/Handlers/MixRecipeBuilder/
HighOven.newMixRecipe(<liquid:steel> * 288, <liquid:crude_steel> * 288, 750) //产出流体, 输入流体, 温度
    .addOxidizer(<ore:dustChrome>, 80) //氧化剂, 概率（百分比）
    .addReducer(<ore:dustCoal>, 90) //还原剂, 概率
    .addPurifier(<contenttweaker:iron_sand>, 100) //净化剂, 概率
    .register();
// 修改已有高炉合金配方格式:
// HighOven.manageMixRecipe(ILiquidStack output, ILiquidStack input);
// 你可以使用配方构建器和链式调用实现更多功能
// 如下实例使用链式调用, 配合注释使用:
// 更多的方法可参考: https://docs.blamejared.com/1.12/en/Mods/Modtweaker/TComplement/Handlers/MixRecipeManager/
HighOven.manageMixRecipe(<liquid:knightslime>,<liquid:iron>) //输出流体, 输入流体
    .removeOxidizer() //移除氧化剂
    .addOxidizer(<ore:dustChrome>, 80) //添加氧化剂, 概率
    .removeReducer(<tconstruct:edible:2>) //移除还原剂
    .addReducer(<tconevo:material:1>,40) //添加还原剂, 概率
    .removePurifier(<minecraft:gravel>) //移除净化剂
    .addPurifier(<tconstruct:seared>,50) //添加净化剂, 概率
    .addPurifier(<minecraft:stone>,100); //添加净化剂, 概率
神秘时代6 - Thaumcraft 6

要素与要素类

1
2
3
4
5
6
7
8
9
10
11
12
import thaumcraft.aspect.CTAspect;
import thaumcraft.aspect.CTAspectStack;
// ModTweaker 与神秘时代联动了要素相关的类 CTAspectStack 和 CTAspect
// 通过 <aspect:name> 的尖括号调用来获取一个 CTAspectStack
// 设置和删除实体要素如下实例所示:
// 以下函数的参数也可以是 CTAspectStack[] 类型
<entity:sheep>.setAspects(<aspect:terra>*5);
<entity:blaze>.removeAspects(<aspect:ignis>);
// 设置和删除物品要素如下实例所示:
// 以下函数的参数也可以是 CTAspectStack[] 类型
<minecraft:stone>.setAspects(<aspect:ignis>*5);
<minecraft:iron_ore>.removeAspects(<aspect:terra>);
神秘时代相关命令

名称	语法	作用
信息转储	/ct thaumcraftDump	将所有神秘时代的信息转储到 crafttweaker.log 文件
神秘时代配方修改

奥术工作台

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import mods.thaumcraft.ArcaneWorkbench;
// 添加有序奥术合成配方格式:
// ArcaneWorkbench.registerShapedRecipe(String name, String research, int vis, CTAspectStack[] aspectList, IItemStack output, IIngredient[][] input);
// 其中, name 是配方名, 不能重复; research 是该配方需要的研究; vis 是该配方消耗的灵气值
// 如下实例表示通过奥术工作台, 在使用风火地元素的情况下, 消耗 20 灵气将泥土, 木棍, 草方块有序合成得到钻石, 无前置研究:
ArcaneWorkbench.registerShapedRecipe("test1", "", 20, [<aspect:aer>, <aspect:ignis>, <aspect:terra>], <minecraft:diamond>, [[<minecraft:dirt>], [<minecraft:stick>], [<minecraft:grass>]]);
// 添加无序奥术合成配方格式:
// ArcaneWorkbench.registerShapelessRecipe(String name, String research, int vis, CTAspectStack[] aspectList, IItemStack output, IIngredient[] input);
// 其中, name 是配方名, 不能重复; research 是该配方需要的研究; vis 是该配方消耗的灵气值
// 如下实例表示通过奥术工作台, 在使用水火地要素的情况下, 消耗 20 灵气将沙子, 木棍, 草方块无序合成得到钻石, 无前置研究:
ArcaneWorkbench.registerShapelessRecipe("test2", "", 20, [<aspect:aqua>, <aspect:ignis>, <aspect:terra>], <minecraft:diamond>, [<minecraft:sand>, <minecraft:stick>, <minecraft:grass>]);
// 通过配方名删除奥术合成配方格式:
// ArcaneWorkbench.removeRecipe(String name);
// 如下实例表示删除名为 test1 的奥术合成配方:
ArcaneWorkbench.removeRecipe("test1");
// 通过输出物品删除奥术合成配方格式:
// ArcaneWorkbench.removeRecipe(IItemStack output);
// 如下实例表示删除所有得到揭示之护目镜的奥术合成配方:
ArcaneWorkbench.removeRecipe(<thaumcraft:goggles>);
坩埚

1
2
3
4
5
6
7
8
9
10
11
12
13
14
import mods.thaumcraft.Crucible;
// 添加坩埚配方格式:
// Crucible.registerRecipe(String name, String researchKey, IItemStack output, IIngredient input, CTAspectStack[] aspects);
// 其中, name 是配方名, 不能重复; researchKey 是该配方需要的研究; aspects 是需要的要素
// 如下实例表示通过坩埚将 1 个铁锭和 1 点风要素炼制为 1 个金锭, 无前置研究:
Crucible.registerRecipe("crucibleTest", "", <minecraft:gold_ingot>, <minecraft:iron_ingot>, [<aspect:aer>]);
// 通过配方名删除坩埚配方格式:
// Crucible.removeRecipe(String name);
// 如下实例表示删除名为 crucibleTest 的坩埚配方:
Crucible.removeRecipe("crucibleTest");
// 通过输出物品删除坩埚配方格式:
// Crucible.removeRecipe(IItemStack output);
// 如下实例删除所有通过坩埚炼得皮革的配方:
Crucible.removeRecipe(<minecraft:leather>);
奥术注魔

1
2
3
4
5
6
7
8
9
10
11
12
13
14
import mods.thaumcraft.Infusion;
// 添加奥术注魔配方格式:
// Infusion.registerRecipe(String name, String research, IItemStack output, int instability, CTAspectStack[] aspects, IIngredient centralItem, IIngredient[] input);
// 其中, name 是配方名, 不能重复; research 是该配方需要的研究; aspects 是需要的要素; instability 是注魔风险; centralItem 是中心奥术基座上的物品
// 如下实例表示通过注魔风险为危险的奥术注魔, 将中心物品金苹果与 8 个金块, 消耗 50 生命要素聚合为 1 个 附魔金苹果, 无前置研究:
Infusion.registerRecipe("apple", "", <minecraft:golden_apple:1>, 10, [<aspect:victus> * 50], <minecraft:golden_apple>, [<minecraft:gold_block> * 8]);
// 通过配方名删除奥术注魔配方格式:
// Infusion.removeRecipe(String name);
// 如下实例表示删除名为 apple 的奥术注魔配方:
Infusion.removeRecipe("apple");
// 通过输出物品删除奥术注魔配方格式:
// Infusion.removeRecipe(IItemStack output);
// 如下实例表示删除所有通过奥术注魔得到源质之镜的配方:
Infusion.removeRecipe(<thaumcraft:mirror_essentia>);
藏宝袋

1
2
3
4
5
6
7
8
9
10
11
import mods.thaumcraft.LootBag;
// 添加藏宝袋物品格式:
// LootBag.addLoot(WeightedItemStack stack, int[] bagTypes)
// 其中, bagTypes 是藏宝袋类型, 0-2 分别对应寻常, 稀有, 罕见
// 物品权重参考: 金币为 2000, 钻石为 50
// 如下实例表示向三种类型的藏宝袋中添加泥土, 权重为 20000:
LootBag.addLoot(<minecraft:dirt>%20000, [0,1,2]);
// 删除藏宝袋物品格式:
// LootBag.removeLoot(IItemStack stack, int[] bagTypes);
// 如下实例表示删除稀有和罕见藏宝袋中的金粒:
LootBag.removeLoot(<minecraft:gold_nugget>, [1,2]);
世界盐

1
2
3
4
5
6
7
8
9
10
11
12
13
import mods.thaumcraft.SalisMundus;
// 添加世界盐配方格式:
// SalisMundus.addSingleConversion(IBlock in, IItemStack out, @Optional String research);
// SalisMundus.addSingleConversion(IOreDictEntry in, IItemStack out, @Optional String research);
// 其中, research 是该配方需要的研究
// 如下实例表示通过世界盐将泥土转化为基岩, 无前置研究:
SalisMundus.addSingleConversion(<blockstate:minecraft:dirt>.block, <minecraft:bedrock>);
// 如下实例表示通过世界盐将铁块转化为基岩, 无前置研究:
SalisMundus.addSingleConversion(<ore:blockIron>, <minecraft:bedrock>);
// 删除世界盐配方格式:
SalisMundus.removeSingleConversion(IIngredient output);
// 如下实例表示删除所有通过世界盐得到坩埚的配方:
SalisMundus.removeSingleConversion(<thaumcraft:crucible>);
炼狱熔炉副产物

1
2
3
4
5
6
7
8
9
import mods.thaumcraft.SmeltingBonus;
// 添加炼狱熔炉副产物格式:
// SmeltingBonus.addSmeltingBonus(IIngredient input, WeightedItemStack stack)
// 如下实例表示使用炼狱熔炉烧制圆石时有 20 的权重产出按钮:
SmeltingBonus.addSmeltingBonus(<minecraft:cobblestone>, <minecraft:button> % 20);
// 删除炼狱熔炉副产物格式:
// SmeltingBonus.removeSmeltingBonus(IIngredient input, IItemStack stack);
// 如下实例表示删除使用炼狱熔炉烧制金矿石时产出的金粒副产物:
SmeltingBonus.removeSmeltingBonus(<minecraft:gold_ore>, <minecraft:gold_nugget>);
扭曲

1
2
3
4
5
import mods.thaumcraft.Warp;
// 设置物品的扭曲值格式:
// Warp.setWarp(IItemStack stack, int amount);
// 如下实例表示将泥土的扭曲值设为 500:
Warp.setWarp(<minecraft:dirt>, 500);
热力膨胀5 - Thermal Expansion 5

各类能源炉配方修改

压缩能源炉

1
2
3
4
5
6
7
8
9
10
import mods.thermalexpansion.CompressionDynamo;
// 添加压缩能源炉燃料格式:
// CompressionDynamo.addFuel(ILiquidStack stack, int energy);
// 其中, energy 必须处于 10000 到 200000000 之间
// 如下实例表示将水作为压缩能源炉的燃料, 单次产能 20000RF:
CompressionDynamo.addFuel(<liquid:water>, 20000);
// 删除压缩能源炉燃料格式:
// CompressionDynamo.removeFuel(ILiquidStack stack);
// 如下实例表示不再将水作为压缩能源炉的燃料:
CompressionDynamo.removeFuel(<liquid:water>);
弱化能源炉

1
2
3
4
5
6
7
8
9
10
import mods.thermalexpansion.EnervationDynamo;
// 添加弱化能源炉燃料格式:
// EnervationDynamo.addFuel(IItemStack stack, int energy);
// 其中, energy 必须处于 2000 到 200000000 之间
// 如下实例表示将木棍作为弱化能源炉的燃料, 单次产能 20000RF:
EnervationDynamo.addFuel(<minecraft:stick>, 20000);
// 删除弱化能源炉燃料格式:
// EnervationDynamo.removeFuel(IItemStack stack);
// 如下实例表示不再将木棍作为弱化能源炉的燃料:
EnervationDynamo.removeFuel(<minecraft:stick>);
热力能源炉

1
2
3
4
5
6
7
8
9
10
import mods.thermalexpansion.MagmaticDynamo;
// 添加热力能源炉燃料格式:
// MagmaticDynamo.addFuel(ILiquidStack stack, int energy);
// 其中, energy 必须处于 10000 到 200000000 之间
// 如下实例表示将水作为热力能源炉的燃料, 单次产能 20000RF:
MagmaticDynamo.addFuel(<liquid:water>, 20000);
// 删除热力能源炉燃料格式:
// MagmaticDynamo.removeFuel(ILiquidStack stack);
// 如下实例表示不再将水作为热力能源炉的燃料:
MagmaticDynamo.removeFuel(<liquid:water>);
蒸汽能源炉

1
2
3
4
5
6
7
8
9
10
import mods.thermalexpansion.SteamDynamo;
// 添加蒸汽能源炉燃料格式:
// SteamDynamo.addFuel(IItemStack stack, int energy);
// 其中, energy 必须处于 2000 到 200000000 之间
// 如下实例表示将木棍作为蒸汽能源炉的燃料, 单次产能 20000RF:
SteamDynamo.addFuel(<minecraft:stick>, 20000);
// 删除蒸汽能源炉燃料格式:
// SteamDynamo.removeFuel(IItemStack stack);
// 如下实例表示不再将木棍作为蒸汽能源炉的燃料:
SteamDynamo.removeFuel(<minecraft:stick>);
通货能源炉

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
import mods.thermalexpansion.NumisticDynamo;
// 添加通货能源炉普通燃料格式:
// NumisticDynamo.addFuel(IItemStack stack, int energy);
// 其中, energy 必须处于 2000 到 200000000 之间
// 如下实例表示将木棍作为通货能源炉的普通燃料, 单次产能 20000RF:
NumisticDynamo.addFuel(<minecraft:stick>, 20000);
// 删除通货能源炉普通燃料格式:
// NumisticDynamo.removeFuel(IItemStack stack);
// 如下实例表示不再将木棍作为通货能源炉的普通燃料:
NumisticDynamo.removeFuel(<minecraft:stick>);
// 通货能源炉安装宝石印刻校准升级后只能以宝石作为燃料
// 添加通货能源炉宝石燃料格式:
// NumisticDynamo.addGemFuel(IItemStack stack, int energy);
// 其中, energy 必须处于 2000 到 200000000 之间
// 如下实例表示将木棍作为通货能源炉的宝石燃料, 单次产能 20000RF:
NumisticDynamo.addGemFuel(<minecraft:stick>, 20000);
// 删除通货能源炉宝石燃料格式:
// NumisticDynamo.removeGemFuel(IItemStack stack);
// 如下实例表示不再将木棍作为通货能源炉的宝石燃料:
NumisticDynamo.removeGemFuel(<minecraft:stick>);
反应能源炉

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
import mods.thermalexpansion.ReactantDynamo;
// 添加反应能源炉反应格式:
// ReactantDynamo.addReaction(IItemStack item, ILiquidStack liquid, int energy);
// 其中, energy 必须处于 10000 到 200000000 之间
// 如下实例表示允许反应能源炉进行基岩和水的反应, 单次产能 20000RF:
ReactantDynamo.addReaction(<minecraft:bedrock>, <liquid:water>, 20000);
// 删除反应能源炉反应格式:
// ReactantDynamo.removeReaction(IItemStack item, ILiquidStack liquid);
// 如下实例表示不再将基岩和水作为反应能源炉的反应:
ReactantDynamo.removeReaction(<minecraft:bedrock>, <liquid:water>);
// 反应能源炉安装基础反应催化升级后只能进行基本反应
// 添加反应能源炉基本反应格式:
// ReactantDynamo.addReactionElemental(IItemStack item, ILiquidStack liquid, int energy);
// 其中, energy 必须处于 10000 到 200000000 之间
// 如下实例表示允许反应能源炉进行基岩和水的基本反应, 单次产能 20000RF:
ReactantDynamo.addReactionElemental(<minecraft:bedrock>, <liquid:water>, 20000);
// 删除反应能源炉基本反应格式:
// ReactantDynamo.removeReactionElemental(IItemStack item, ILiquidStack liquid);
// 如下实例表示不再将基岩和水作为反应能源炉的基本反应:
ReactantDynamo.removeReactionElemental(<minecraft:bedrock>, <liquid:water>);
冷却剂管理

1
2
3
4
5
6
7
8
9
10
11
12
13
14
import mods.thermalexpansion.Coolant;
// 部分机器的运行需要使用冷却剂, 使用该方法可以管理冷却剂
// 添加冷却剂格式:
// Coolant.addCoolant(ILiquidStack fluid, int coolantRf, int coolantFactor);
// 其中, coolantRf 不能为负值, coolantFactor 必须介于 1 到 100 之间, 否则冷却剂添加失败
// 如下实例表示将熔岩添加为冷却剂:
Coolant.addCoolant(<liquid:lava>, 0, 1);
// 热力膨胀自带的冷却剂用该格式写出来如下:
// Coolant.addCoolant(<liquid:water>, 250000, 20);
// Coolant.addCoolant(<liquid:cryotheum>, 3000000, 60);
// 删除冷却剂格式:
// Coolant.removeCoolant(ILiquidStack fluid);
// 如下实例表示不再将水作为冷却剂:
Coolant.removeCoolant(<liquid:water>);
热力机器配方修改

药水酿造机

1
2
3
4
5
6
7
8
9
import mods.thermalexpansion.Imbuer;
// 添加药水酿造机配方格式:
// Imbuer.addRecipe(ILiquidStack output, IItemStack input, ILiquidStack inputFluid, int energy);
// 如下实例表示通过药水酿造机消耗 2048RF 用泥土将水酿造为熔岩:
Imbuer.addRecipe(<liquid:lava>, <minecraft:dirt>, <liquid:water>, 2048);
// 删除药水酿造机配方格式:
// Imbuer.removeRecipe(IItemStack input, ILiquidStack secondInput);
// 如下实例表示删除所有通过药水酿造机用泥土和水酿造的配方:
Imbuer.removeRecipe(<minecraft:dirt>, <liquid:water>);
附魔机

1
2
3
4
5
6
7
8
9
import mods.thermalexpansion.Enchanter;
// 添加附魔机配方格式:
// Enchanter.addRecipe(IItemStack output, IItemStack input, IItemStack secondInput, int energy, int experience, boolean empowered);
// 如下实例表示通过附魔机消耗 1 颗钻石,12000RF 和 3000mB 知识精华给 1 本书附魔时运:
Enchanter.addRecipe(<minecraft:enchanted_book>.withTag({StoredEnchantments: [{id: 35}]}), <minecraft:book>, <minecraft:diamond>, 12000, 3000, false);
// 删除附魔机配方格式:
// Enchanter.removeRecipe(IItemStack input, IItemStack secondInput);
// 如下实例表示删除所有通过附魔机消耗钻石给书附魔的配方:
Enchanter.removeRecipe(<minecraft:book>, <minecraft:diamond>);
离心机

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
import mods.thermalexpansion.Centrifuge;
// 添加离心机配方格式:
// Centrifuge.addRecipe(WeightedItemStack[] outputs, IItemStack input, ILiquidStack fluid, int energy);
// 如下实例表示通过离心机消耗熔岩和 2000RF 将 1 个金矿石离心, 10% 获得 5 个金锭, 50% 获得 1 个铁锭:
Centrifuge.addRecipe([(<minecraft:gold_ingot> * 5) % 10, <minecraft:iron_ingot> % 50], <minecraft:gold_ore>, <liquid:lava>, 2000);
// 删除离心机配方格式:
// Centrifuge.removeRecipe(IItemStack input);
// 如下实例表示删除所有通过离心机离心金矿石的配方:
Centrifuge.removeRecipe(<minecraft:gold_ore>);
// 离心机安装生物离心分解升级后能且只能处理生物球的离心
// 添加离心机生物离心分解配方格式:
// Centrifuge.addRecipeMob(IEntityDefinition entity, WeightedItemStack[] outputs, @Nullable ILiquidStack fluid, int energy, int xp);
// 其中, @Nullable 表示可空项, 若 fluid 为空, 将默认为知识精华, 根据 xp 计算得来
// 若 fluid 不为空, 则 xp 项被忽略
// 如下实例表示通过离心机消耗 5xp 对应知识精华和 2000RF 将史莱姆生物球离心, 50% 获得 1 个黏土球, 10% 获得 1 个恶魂之泪:
Centrifuge.addRecipeMob(<entity:minecraft:slime>, [<minecraft:clay_ball> % 50, <minecraft:ghast_tear> % 10], null, 2000, 5);
// 如下实例表示通过离心机消耗 20mB 熔岩和 2000RF 将史莱姆生物球离心, 100% 获得 1 个火药:
Centrifuge.addRecipeMob(<entity:minecraft:slime>, [<minecraft:gunpowder>%100], <liquid:lava>*20, 2000, 0);
// 删除离心机生物离心分解配方格式:
// Centrifuge.removeRecipeMob(IEntityDefinition entity);
// 如下实例表示删除所有通过离心机生物离心分解史莱姆生物球的配方:
Centrifuge.removeRecipeMob(<entity:minecraft:slime>);
压缩机

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
import mods.thermalexpansion.Compactor;
// 压缩机支持 4 种不同类型的配方: 货币铸造(Mint), 辊压(Press), 压缩(Storage), 齿轮制造(Gear)
// 辊压: 压缩机基础模式, 负责类似将金属处理成金属板的配方
// 压缩: 压缩机基础模式, 负责类似将烈焰粉处理成烈焰棒的配方
// 货币铸造: 安装通货铸造授权升级后的压缩机能且只能处理这类配方
// 齿轮制造: 安装齿轮工作模具升级后的压缩机能且只能处理这类配方
// 压缩机配方修改大同小异, 实例省去
// 添加压缩机配方格式:
// 辊压: Compactor.addPressRecipe(IItemStack output, IItemStack input, int energy);
// 压缩: Compactor.addStorageRecipe(IItemStack output, IItemStack input, int energy);
// 货币铸造: Compactor.addMintRecipe(IItemStack output, IItemStack input, int energy);
// 齿轮制造: Compactor.addGearRecipe(IItemStack output, IItemStack input, int energy);
// 删除压缩机配方格式:
// 辊压: Compactor.removePressRecipe(IItemStack input);
// 压缩: Compactor.removeStorageRecipe(IItemStack input);
// 货币铸造: Compactor.removeMintRecipe(IItemStack input);
// 齿轮制造: Compactor.removeGearRecipe(IItemStack input);
能量灌注机

1
2
3
4
5
6
7
8
9
import mods.thermalexpansion.Infuser;
// 添加能量灌注机配方格式:
// Infuser.addRecipe(IItemStack output, IItemStack input, int energy);
// 如下实例表示通过能量灌注机消耗 1000RF 将铁锭灌注为金锭:
Infuser.addRecipe(<minecraft:gold_ingot>, <minecraft:iron_ingot>, 1000);
// 删除能量灌注机配方格式:
// Infuser.removeRecipe(IItemStack input);
// 如下实例表示删除所有通过能量灌注机灌注金矿石的配方:
Infuser.removeRecipe(<minecraft:gold_ore>);
公式处理器

1
2
3
4
5
6
7
8
9
10
11
12
13
import mods.thermalexpansion.Factorizer;
// 公式处理器支持 3 种不同类型的配方: 分割(Split), 合并(Combine), 两者(Both)
// 分割: 处理类似将金块分解为金锭的配方
// 合并: 处理类似将金锭合成为金块的配方
// 两者: 同时修改分割与合并模式的配方
// 公式处理器配方修改大同小异, 实例省去
// 添加公式处理器配方格式:
// 分割: Factorizer.addRecipeSplit(IItemStack in, IItemStack out);
// 合并: Factorizer.addRecipeCombine(IItemStack in, IItemStack out);
// 两者: Factorizer.addRecipeBoth(IItemStack combined, IItemStack split);
// 删除公式处理器配方格式:
// 分割: Factorizer.removeRecipeSplit(IItemStack in);
// 合并: Factorizer.removeRecipeCombine(IItemStack in);
流体转置机

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
import mods.thermalexpansion.Transposer;
// 添加流体转置机提取配方格式:
// Transposer.addExtractRecipe(ILiquidStack output, IItemStack input, int energy, @Optional WeightedItemStack itemOut);
// 其中, Optional 表示可选项
// 如下实例表示通过流体转置机消耗 360RF 从 1 个云杉树叶中提取 250mB 水, 30% 返还 1 个橡树树叶:
Transposer.addExtractRecipe(<liquid:water> * 250, <minecraft:leaves:1>, 360, <minecraft:leaves:0> % 30);
// 添加流体转置机灌注配方格式:
// Transposer.addFillRecipe(IItemStack output, IItemStack input, ILiquidStack fluid, int energy);
// 如下实例表示通过流体转置机消耗 20RF 将 200mB 水灌注入 1 个橡树树叶, 得到 1 个云杉树叶:
Transposer.addFillRecipe(<minecraft:leaves:1>, <minecraft:leaves:0>, <liquid:water> * 200, 20);
// 删除流体转置机提取配方格式:
// Transposer.removeExtractRecipe(IItemStack input);
// 如下实例表示删除所有通过流体转置机从金矿石中提取流体的配方:
Transposer.removeExtractRecipe(<minecraft:gold_ore>);
// 删除流体转置机填充配方格式:
// Transposer.removeFillRecipe(IItemStack input, ILiquidStack fluid);
// 如下实例表示删除所有通过流体转置机将水灌注入桶的配方:
Transposer.removeFillRecipe(<minecraft:bucket>, <liquid:water>);
流体精炼机

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
import mods.thermalexpansion.Refinery;
// 添加流体精炼机普通配方格式:
// Refinery.addRecipe(ILiquidStack output, WeightedItemStack outputItem, ILiquidStack input, int energy);
// 如下实例表示通过流体精炼机消耗 50RF 将 100mB 水精炼为 5mB 熔岩, 1% 产出副产物 1 颗钻石:
Refinery.addRecipe(<liquid:lava> * 5, <minecraft:diamond> % 1, <liquid:water> * 100, 50);
// 删除流体精炼机普通配方格式:
// Refinery.removeRecipe(ILiquidStack input);
// 如下实例表示删除所有通过流体精炼机精炼树脂的普通配方:
Refinery.removeRecipe(<liquid:resin>);
// 流体精炼机安装炼金术反应釜升级后能且只能处理药水配方
// 添加流体精炼机药水配方格式:
// Refinery.addRecipePotion(ILiquidStack output, ILiquidStack input, int energy);
// 如下实例表示通过流体精炼机消耗 100RF 将 100mB 再生药水精炼为 100mB 再生药水 II:
Refinery.addRecipePotion(<liquid:potion>.withTag({Potion: "minecraft:strong_regeneration"}) * 100, <liquid:potion>.withTag({Potion: "minecraft:regeneration"}) * 100, 100);
// 删除流体精炼机药水配方格式:
// Refinery.removeRecipePotion(ILiquidStack input);
// 如下实例表示删除所有通过流体精炼机精炼再生药水的药水配方:
Refinery.removeRecipePotion(<liquid:potion>.withTag({Potion: "minecraft:regeneration"}));
感应炉

1
2
3
4
5
6
7
8
9
10
import mods.thermalexpansion.InductionSmelter;
// 添加感应炉配方格式:
// InductionSmelter.addRecipe(IItemStack primaryOutput, IItemStack primaryInput, IItemStack secondaryInput, int energy, @Optional IItemStack secondaryOutput, @Optional int secondaryChance);
// 其中, @Optional 表示可选项
// 如下实例表示通过感应炉消耗 1500RF 将 1 根木棍和 1 个铁矿石感应为 1 颗钻石, 20% 产出副产物 1 个石头:
InductionSmelter.addRecipe(<minecraft:diamond>, <minecraft:stick>, <minecraft:iron_ore>, 1500, <minecraft:stone>, 20);
// 删除感应炉配方格式:
// InductionSmelter.removeRecipe(IItemStack primaryInput, IItemStack secondaryInput);
// 如下实例表示删除所有通过感应炉将桶和沙子感应为其他物品的配方:
InductionSmelter.removeRecipe(<minecraft:bucket>, <minecraft:sand>);
熔岩炉

1
2
3
4
5
6
7
8
9
import mods.thermalexpansion.Crucible;
// 添加熔岩炉配方格式:
// Crucible.addRecipe(ILiquidStack output, IItemStack input, int energy);
// 如下实例表示通过熔岩炉消耗 50RF 将钻石熔化为精炼油:
Crucible.addRecipe(<liquid:refined_oil>, <minecraft:diamond>, 50);
// 删除熔岩炉配方格式:
// Crucible.removeRecipe(IItemStack input);
// 如下实例表示删除所有通过熔岩炉熔化荧石的配方:
Crucible.removeRecipe(<minecraft:glowstone>);
红石炉

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
import mods.thermalexpansion.RedstoneFurnace;
// 添加红石炉配方格式:
// RedstoneFurnace.addRecipe(IItemStack output, IItemStack input, int energy);
// 如下实例表示通过红石炉消耗 3600RF 燃烧 1 个铁锭获得 1 个金锭:
RedstoneFurnace.addRecipe(<minecraft:gold_ingot>, <minecraft:iron_ingot>, 3600);
// 删除红石炉配方格式:
// RedstoneFurnace.removeRecipe(IItemStack input);
// 如下实例表示删除所有通过红石炉燃烧金矿石的配方
RedstoneFurnace.removeRecipe(<minecraft:gold_ore>);
// 红石炉安装高温热解转化升级后能且只能处理部分配方
// 添加红石炉高温热解配方格式:
// RedstoneFurnace.addPyrolysisRecipe(IItemStack output, IItemStack input, int energy, int creosote);
// 其中, energy 表示能量, 机器的实际耗能是该处所填数值的 1.5 倍; creosote 表示获得杂酚油的数量, 单位为 mB
// 如下实例表示通过红石炉消耗 3000RF 燃烧 1 个木炭获得 1 个焦炭, 同时获得 250mB 杂酚油:
RedstoneFurnace.addPyrolysisRecipe(<thermalfoundation:material:802>, <minecraft:coal:1>, 2000, 250);
// 删除红石炉高温热解配方格式:
// RedstoneFurnace.removePyrolysisRecipe(IItemStack input);
// 如下实例表示删除所有通过红石炉燃烧煤炭的高温热解配方:
RedstoneFurnace.removePyrolysisRecipe(<minecraft:coal>);
有机灌注机

1
2
3
4
5
6
7
8
9
10
11
12
13
14
import mods.thermalexpansion.Insolator;
// 添加有机灌注机配方格式:
// Insolator.addRecipe(IItemStack primaryOutput, IItemStack primaryInput, IItemStack secondaryInput, int energy, @Optional IItemStack secondaryOutput, @Optional int secondaryChance, @Optional int water);
// 如下实例表示通过有机灌注机消耗 1500RF 和 1B 水灌注 1 根木棍和 1 个铁矿石获得 1 颗钻石, 同时 20% 产出副产物 1 个石头:
Insolator.addRecipe(<minecraft:diamond>, <minecraft:stick>, <minecraft:iron_ore>, 1500, <minecraft:stone>, 20, 1000);
// 删除有机灌注机配方格式:
// Insolator.removeRecipe(IItemStack primaryInput, IItemStack secondaryInput);
// 如下实例表示删除所有通过有机灌注机灌注西瓜种子和富集光合堆肥的配方:
Insolator.removeRecipe(<minecraft:melon_seeds>, <thermalfoundation:fertilizer:1>);
// 有机灌注机安装树苗灌注基底升级后可以处理树苗获得原木
// 添加有机灌注机树苗灌注配方格式:
// Insolator.addRecipeSaplingInfuser(IItemStack primaryOutput, IItemStack primaryInput, IItemStack secondaryInput, int energy, @Optional IItemStack secondaryOutput, @Optional int secondaryChance, @Optional int water);
// 如下实例表示通过有机灌注机消耗 1200RF 和 300mB 水灌注 1 个地狱岩和 1 个圆石获得 1 个下界石英, 同时 150% 产出副产物 1 个泥土:
Insolator.addRecipeSaplingInfuser(<minecraft:quartz>, <minecraft:netherrack>, <minecraft:cobblestone>, 1200, <minecraft:dirt>, 150, 300);
磨粉机

1
2
3
4
5
6
7
8
9
import mods.thermalexpansion.Pulverizer;
// 添加磨粉机配方格式:
// Pulverizer.addRecipe(IItemStack output, IItemStack input, int energy, @Optional IItemStack secondaryOutput, @Optional int secondaryChance);
// 如下实例表示通过磨粉机消耗 1500RF 将 1 根木棍磨成 1 颗钻石, 同时 20% 产出副产物 1 个石头:
Pulverizer.addRecipe(<minecraft:diamond>, <minecraft:stick>, 1500, <minecraft:stone>, 20);
// 删除磨粉机配方格式:
// Pulverizer.removeRecipe(IItemStack input);
// 如下实例表示删除所有通过磨粉机研磨金矿石的配方:
Pulverizer.removeRecipe(<minecraft:gold_ore>);
锯木机

1
2
3
4
5
6
7
8
9
import mods.thermalexpansion.Sawmill;
// 添加锯木机配方格式:
// Sawmill.ddRecipe(IItemStack output, IItemStack input, int energy, @Optional IItemStack secondaryOutput, @Optional int secondaryChance);
// 如下实例表示通过锯木机消耗 1500RF 将 1 根木棍切割成 1 颗钻石, 同时 20% 产出副产物 1 个石头:
Sawmill.addRecipe(<minecraft:diamond>, <minecraft:stick>, 1500, <minecraft:stone>, 20);
// 删除锯木机配方格式:
// Sawmill.removeRecipe(IItemStack input);
// 如下实例表示删除所有通过锯木机切割画的配方:
Sawmill.removeRecipe(<minecraft:painting>);